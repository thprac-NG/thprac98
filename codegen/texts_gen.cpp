#if (__cplusplus < 201103L) && !defined(__INTELLISENSE__)
#error "This file requires a modern C++ with C++11 support to compile." \
  "Are you compiling this with Borland's Turbo C++4.0J?"
#endif

#include <array>
#include <cctype>
#include <cstdio>
#include <cstdlib>  // size_t
#include <cstdint>
#include <exception>
#include <fstream>
#include <map>
#include <iostream>
#include <set>
#include <string>
#include <streambuf>

#include "nlohmann/json.hpp"

#include "codegen/common/warning.hpp"

/**
 * @brief Check if a byte is a leading byte in Shift JIS.
 */
bool shiftjis_leading_byte(unsigned char ch) noexcept {
  return (0x80 <= ch && ch <= 0x9F) || (0xE0 <= ch && ch <= 0xEF);
}

std::string textsdef_cpp, textsdef_hpp;

std::string escape(char ch) {
  switch (ch) {
    case '\"':
    case '\\':
      return std::string("\\") + ch;
    case '\n':
      return std::string("\\n");
    case '\t':
      return std::string("\\t");
    case '\0':
      return std::string("\\0");
    default:
      if (0x20 <= ch && ch <= 0x7E) {
        return std::string() + ch;
      }
      char buffer[10];
      std::sprintf(buffer, "\\x%02x", ch);
      return std::string(buffer);
  }
}
std::string escape(std::string str) {
  std::string ret = "";
  for (auto ch : str) {
    ret += escape(ch);
  }
  return ret;
}

/**
 * @brief Generates content of textsdef.cpp and textsdef.hpp. Store the file
 * content in textsdef_cpp and textsdef_hpp.
 * @details Many characters are encoding as `[4-digit hex], which will be
 * replaced when writing to the files.
 * The encoding is due to nlohmann::json only supporting UTF-8/UTF-16/UTF-32.
 *
 * @param encoded_str the content of texts.json, probably with some characters
 * encoded
 *
 * @throw std::invalid_argument if the generation fails.
 * @throw nlohmann::json::exception if JSON parsing fails.
 */
void code_generate(const std::string& encoded_str) {
  using json = nlohmann::json;
  textsdef_cpp = textsdef_hpp = "";

  struct glossary_t {
    std::string key;
    std::array<std::string, 3> texts;
  };
  std::vector<glossary_t> glossaries;
  std::set<std::string> glossary_key_set;

  auto&& texts_json = json::parse(encoded_str, nullptr, true, true);
  auto&& glossary_json = texts_json["glossary"];
  for (auto&& kv : glossary_json.items()) {
    auto&& key = kv.key();
    auto&& value = kv.value();
    if (!value.is_array() || value.size() != 3u || !value[0].is_string() ||
        !value[1].is_string() || !value[2].is_string()) {
      throw std::invalid_argument(
          "Glossary '" + key + "' in texts.json doesn't map to an array of 3 "
          "strings."
      );
    }
    glossary_key_set.insert(key);
    glossaries.push_back(glossary_t{key, std::array<std::string, 3>({
      value[0].get<std::string>(), value[1].get<std::string>(),
      value[2].get<std::string>()
    })});
  }

  struct group_t {
    std::string name;
    std::vector<std::string> glossaries;
  };
  std::vector<group_t> groups;
  auto &&group_json = texts_json["groups"];
  for (auto&& kv : group_json.items()) {
    auto&& key = kv.key();
    auto&& value = kv.value();
    if (!value.is_array()) {
      throw std::invalid_argument(
        "Group '" + key + "' in texts.json doesn't map to an array."
      );
    }
    std::vector<std::string> current_glossaries;
    for (std::size_t i = 0; i < value.size(); ++i) {
      auto&& current = value[i];
      if (!current.is_string()) {
        throw std::invalid_argument(
          "Index " + std::to_string(i) + " of group '" + key + "' in "
          "texts.json isn't a string."
        );
      }
      if (glossary_key_set.find(current.get<std::string>()) ==
          glossary_key_set.end()) {
        throw std::invalid_argument(
          "'" + current.get<std::string>() + "', indexed " +
          std::to_string(i) + " in group '" + key + "' in texts.json, isn't "
          "a key in 'glossary'."
        );
      }
      current_glossaries.push_back(current.get<std::string>());
    }
    groups.push_back(group_t{key, current_glossaries});
  }

  std::string autogenerated_warning = THPRAC98_CODEGEN_WARNING_TEXT;
  textsdef_hpp += autogenerated_warning;

  textsdef_hpp +=
    "#ifndef THPRAC98_SRC_TEXTSDEF_HPP_" ENDL
    "#define THPRAC98_SRC_TEXTSDEF_HPP_" ENDL ENDL
  ;

  textsdef_hpp += "enum th_glossary_t {" ENDL;
  for (std::size_t i = 0; i < glossaries.size(); ++i) {
    textsdef_hpp += INDENT + glossaries[i].key;
    if (i < glossaries.size() - 1) {
      textsdef_hpp += ",";
    }
    textsdef_hpp += ENDL;
  }
  textsdef_hpp += "};" ENDL ENDL;
  textsdef_hpp += "extern const char* th_glossary_str[3][" +
      std::to_string(glossaries.size()) + "];" ENDL ENDL;

  for (auto group : groups) {
    textsdef_hpp += "extern const th_glossary_t " + group.name + "[" +
        std::to_string(group.glossaries.size()) + "];" ENDL;
  }
  textsdef_hpp += ENDL;

  textsdef_hpp += "#endif  // #ifndef THPRAC98_SRC_TEXTSDEF_HPP_" ENDL;

  textsdef_cpp += autogenerated_warning;
  textsdef_cpp += "#include \"src/textsdef.hpp\"" ENDL ENDL;

  textsdef_cpp += "const char* th_glossary_str[3][" +
      std::to_string(glossaries.size()) + "] = {" ENDL;
  for (std::size_t language = 0; language < 3; ++language) {
    textsdef_cpp += INDENT "{" ENDL;
    for (std::size_t i = 0; i < glossaries.size(); ++i) {
      textsdef_cpp += INDENT INDENT "\"" +
                      escape(glossaries[i].texts[language]) + "\"";
      if (i != glossaries.size() - 1) {
        textsdef_cpp += ",";
      }
      textsdef_cpp += ENDL;
    }
    textsdef_cpp += INDENT "}";
    if (language != 2) {
      textsdef_cpp += ",";
    }
    textsdef_cpp += ENDL;
  }
  textsdef_cpp += "};" ENDL ENDL;

  for (auto group : groups) {
    textsdef_cpp += "const th_glossary_t " + group.name + "[" +
        std::to_string(group.glossaries.size()) + "] = {" ENDL;
    for (std::size_t i = 0; i < group.glossaries.size(); ++i) {
      textsdef_cpp += INDENT + group.glossaries[i];
      if (i != group.glossaries.size() - 1) {
        textsdef_cpp += ",";
      }
      textsdef_cpp += ENDL;
    }
    textsdef_cpp += "};" ENDL ENDL;
  }
  return;
}

bool is_hexdigit(unsigned char ch) noexcept {
  return std::isdigit(ch) || ('a' <= ch && ch <= 'f') ||
         ('A' <= ch && ch <= 'F');
}
/**
 * @brief Converts a hexadecimal digit to integer.
 */
int to_hex(unsigned char ch) noexcept {
  if (std::isdigit(ch)) {
    return ch - '0';
  }
  if ('a' <= ch && ch <= 'f') {
    return ch - 'a' + 0xa;
  }
  return ch - 'A' + 0xA;
}

/**
 * @brief Output a string to a file, with all `[4-digit hex] as Shift-JIS
 * characters.
 *
 * @throw std::invalid_arguemnt if fails to open the file.
 */
void decode_and_print(const char* filename, std::string str) {
  std::ofstream output;

  output.open(filename, std::ios::binary);
  if (output.rdstate() & std::ios_base::failbit) {
    throw std::invalid_argument("Fail to open file textsdef.hpp.");
  }

  for (std::size_t i = 0; i < str.length(); ++i) {
    if (str[i] != '`') {
      output << str[i];
      continue;
    }
    i++;
    if (str[i] == '`') {
      output.put('`');
      continue;
    }
    std::uint16_t now = 0x00;
    for (int j = 0; j < 4; ++j) {
      if (j != 0) {
        i++;
      }
      now = (now << 4) | to_hex(str[i]);
    }
    #ifdef THPRAC98_DEBUG
    std::cout << "Printing character 0x" << std::hex << now << std::endl;
    #endif
    if ((now >> 8) != 0) {
      output.put(now >> 8);
    }
    output.put(now & 0xFF);
  }
  return;
}

int main() {
  std::ifstream input;
  input.open("codegen/texts.json", std::ios::binary);
  if (input.rdstate() & std::ios_base::failbit) {
    std::cerr << "Fail to open file texts.json." << std::endl;
    return 1;
  }

  std::vector<unsigned char> input_str(std::istreambuf_iterator<char>(input),
                                       {});

  // Convert the raw byte array into Shift-JIS string

  std::wstring input_wstr = L"";
  for (std::size_t i = 0; i < input_str.size(); i++) {
    uint16_t ch = static_cast<unsigned char>(input_str[i]);
    if (shiftjis_leading_byte(ch)) {
      if (i == input_str.size()) {
        std::cerr << "Unexpected EOF while reading a double-byte Shift-JIS "
                     "character." << std::endl;
        return 1;
      }
      i++;
      input_wstr.push_back((ch << 8) | input_str[i]);
      #ifdef THPRAC98_DEBUG
      std::cout << "Reading character " << std::hex
                << ((ch << 8) | input_str[i]) << std::endl;
      #endif
    } else {
      input_wstr.push_back(ch);
    }
  }

  int line_no = 1, last_lf_pos = 0;
  for (std::size_t i = 0; i < input_wstr.size(); ++i) {
    if (input_wstr[i] == '\n') {
      line_no++;
      last_lf_pos = i;
    }
    if (input_wstr[i] == '`') {
      if (i == input_wstr.size() - 1) {
        std::cerr << "Unexpected EOF after reading character '`'." << std::endl;
        return 0;
      }
      if (input_wstr[i + 1] == '`') {
        continue;
      }
      for (int j = 1; j <= 4; ++j) {
        if (i + j == input_wstr.size() - 1) {
          std::cerr << "Unexpected EOF when reading `[4-digit hex] sequence."
                    << std::endl;
          return 0;
        }
        wchar_t ch = input_wstr[i + j];
        if (!is_hexdigit(ch)) {
          std::cerr << "Expect a hexadecimal digit in line " << line_no
                    << ", character " << (i + j - last_lf_pos + 1)
                    << ", but found character '";
          if (0x0000 <= ch && ch <= 0x007F) {
            std::cerr << escape(ch);
          } else {
            char buffer[10];
            std::sprintf(buffer, "\\x%04x", static_cast<uint16_t>(ch));
            std::cerr << buffer;
          }
          std::cerr << "'." << std::endl;
          return 0;
        }
      }
    }
  }

  // Encode every character as `[4-digit hex]. Exceptions are visible ASCII
  // characters, white space, carriage return, line feed, and horizontal tab.

  std::string encoded_str = "";
  for (std::uint16_t ch : input_wstr) {
    if ((0x0020 <= ch && ch <= 0x7E) ||
        ch == '\n' || ch == '\r' || ch == '\t') {
      encoded_str.push_back(static_cast<char>(ch));
    } else {
      char tmp[10];
      std::sprintf(tmp, "`%04x", ch);
      encoded_str.append(tmp);
    }
  }

  try {
    code_generate(encoded_str);
    decode_and_print("src/textsdef.hpp", textsdef_hpp);
    decode_and_print("src/textsdef.cpp", textsdef_cpp);
  } catch (std::invalid_argument e) {
    std::cerr << e.what() << std::endl;
    return 1;
  } catch (nlohmann::json::exception e) {
    std::cerr << "Error when parsing json: " << e.what() << std::endl;
    return 1;
  }

  std::cout << "Successfully generated src/textsdef.hpp and src/textsdef.cpp."
            << std::endl;
  return 0;
}
