------------------------------------------------------------------------
                              masters.lib
                              masterm.lib
                              masterc.lib
                              masterl.lib
            なんだかわからんがごちゃごちゃ入ってるライブラリ

            著作・恋塚 昭彦 + 奥田 仁 + 千野 裕司 + 澤 隆司
                              version 0.23

------------------------------------------------------------------------

*** このライブラリで扱う内容

        　なんでもアリ。
        あ、主に NEC  PC-9801シリーズおよびPC/AT互換機+DOS/Vが対
        象です。

*** 利用方法

        　このライブラリを利用する場合、プログラムの先頭に次の文
        を書いて下さい。

        C言語版:
           ・MSC ver.6以降, Turbo C以降, Symantec C++ 6.1J  など
             でコンパイルメモリモデルと同じモデルのライブラリを
             使う場合:
                #include "master.h"

           ・small版を強制する場合
                #include "masters.h"

           ・large版を強制する場合
                #include "masterl.h"

           ・compact版を強制する場合
                #include "masterc.h"

           ・medium版を強制する場合
                #include "masterm.h"


*** メモリ管理に関して

        　このライブラリのメモリ管理は、起動直後に必要なすべての
        メモリを取得し、その中をやりくりする仕組みになっています。
        (mem_assign_dos 参照)
        　そして  DOSから自動的に最大のメモリを取得する(デフォル
        ト)以外にも、 自分で好きな手段で確保したメモリ領域をこの
        ライブラリに引き渡す方法も用意してあります。

        　常駐パレットを作成する場合や、子プロセスを起動する場合
        など、ライブラリ内のメモリ管理機構とは別に DOS  からメモ
        リを確保する必要がある場合には、デフォルトの動作以外にな
        るように明示的にライブラリにメモリ領域を指定する必要があ
        る点には注意が必要です。

*** 98とDOS/Vについて
        　動作環境を98専用にする場合は、どの関数も直接呼び出せま
        す。
        　逆に、DOS/V用や、あるいは98,DOS/V両用にする場合は、 必
        ず get_machine()を最初に実行することにより、
        Machine_State 変数を設定してください。

        　98用のソースは、コンパイルオプションに -DMASTER98=0 を
        つけるか、master.hをincludeする前に、#define MASTER98  0
        をつけることにより、多くの関数が DOS/V 用に変換されます。
        運が良ければそのまま移植完了してしまうこともあります(笑)

*** 従来の super.lib 利用者への注意

        　まず、メモリ管理に注意してください。
        　従来は、super.lib自体が必要に応じて直接DOSからメモリを
        取得していましたが、本バージョンでは最初に必要になった時
        点で自動的に利用可能な DOSのすべてのメモリを占有し、その
        中をやりくりするするようになっています。
        　全てのメモリを占有されることを避けるためには、メモリを
        必要とする関数を呼び出す前に、mem_assign()を呼び出して管
        理メモリ領域を明示するようにしてください。

        　あ、あとパレットに少し気を付ける必要もありますね。
        　super_entry_bfnt()ではハードウェアパレットには設定しま
        せん。必要なタイミングで、palette_show()を実行することで
        はじめて画面に色があらわれることになります。

        　master.lib 0.16で、super_put_mitch()関数の名前を
        super_put_clip_8()という名前に変更しました。


*** 従来の BGMLIB 利用者への注意

        　voice機能(PCM再生)は削除しました。代わりに  master.lib
        側の pcm_convert, pcm_play を使用してください。

*** 従来の pf.lib 利用者への注意

        　ソースの修正が必要です。といっても簡単ですが。
        　PFILE * は pf_t に、BFILE * は bf_t に書き換えてくださ
        い。

*** C言語版について

        　C言語版には、small,medium,compact,large版がありますが、
        これは対応メモリモデルで分類しています。

        TYPE\MODEL  tiny  small  compact  medium  large  huge
        masters.lib  *1    ○      …       …     …     …
        masterc.lib  *1    ○      ○       …     …     …
        masterm.lib  …    ○      …       ○     …     …
        masterl.lib  …    ○      ○       ○     ○     *2

                                ○:  充分に利用可能
                                …:  利用には多くの知識を要する
                                *1:  farポインタ,割り込みが使え
                                     ません
                                *2:  Microsoft  なら使えますが、
                                     Borland では使えません

        　この表を見ると、 large版があればすべてできることがわか
        りますが、 small版にするとポインタや関数呼び出しがnearで
        行われるため、少しだけ速く、小さくなります。 (呼び出し側
        も小さくなります)

        ライブラリルーチンの仮定は、以下のようになっています。

        　・リターン方法:
                small,compact:  retn
                medium,large:   retf
        　・ポインタのサイズ:
                small,medium:   near(offsetのみ)
                compact,large:  far(segment, offset)
        　・保存レジスタ:
                共通:   SI,DI,SS,BP
        　・レジスタの値仮定
                共通:   DS=DGROUP  i-flag=1  d-flag=0
                Nearのみ: CS=_TEXT
        　・スタックセグメントの仮定
                small,medium:   SS=DGROUP (割り込み系は除く)
                compact,large:  SSは自由
        　・パラメータの渡し方:
                先頭から順に PUSHして呼び出す。
                スタックは呼ばれた側が開放します。
        　・終了コードの戻し方:
                16bitなら AXに、32bitなら DX AX にいれて戻す。

*** 表の見方


        ------------------------------------------98N 98H AT DOS-
        <関数名>                                   ○  ○    ○
        ---------------------------------------------<ｿｰｽﾌｧｲﾙ名>-

                98N欄:
                        　NEC PC-9801シリーズの、 ノーマルモード
                        で使えるかどうかを表します。
                        　○ならば全てのノーマルモード(または
                            NEC   MSDOSに固有の機能)、  Ｖならば
                            PC-9801U,V以降となります。
                          空欄ならばノーマルモード固有の機能を利
                          用していませんが、もちろん使えます。

                98H欄:
                        　NEC PC-9801シリーズの、 ハイレゾモード
                        で使えるかどうかを表します。
                        　○ならばハイレゾモード固有の機能を使用
                            して対応しています。
                          空欄ならばハイレゾモード固有の機能を利
                          用していませんが、もちろん使えます。

                AT欄:
                        　IBM PS/55, PC/AT互換機,  J3100系で使え
                        るかどうかを表します。
                        　○ならば、いずれかの機種に対応していま
                            す。詳しくは関数説明を読んで下さい。
                        　×ならば、いずれにも対応していません。
                        　Ｖならば、VGAが必要です。
                        　＊ならば、MASTER98=0とマクロ定義してコ
                            ンパイルした場合に、AT互換機用の相当
                            する処理に自動的に置き変わります。
                        　空欄ならば、 きっと動くでしょう(おいお
                        い)

                DOS欄:
                        　MS-DOS  のどのバージョンに対応している
                        かを表します。
                        　５ならば Version 2〜5まで対応、 ３なら
                        ばVersion 2〜3対応となります。
                        　○ならば、 DOSのバージョンには関係ない
                            と思われる機能を利用しています。
                        　Ｖならば、 DOS/V固有の機能を使っていま
                        す。DOS/Vでなければ動作しません。
                        　空欄ならば、 DOSの固有機能を利用してい
                        ませんので、 DOSの種類にかかわらず使えま
                        す。

                上記のことから、98N欄と98H欄が共に空欄であれば、
                DOS汎用または8086汎用であることになります。

        表の続きにある説明の左端の記号の意味

        ●      動作説明
        ←      引数の説明
        →      リターン値の説明
        ★      注意事項
        ○      ひとこと(笑)
        △      メモリ管理機構を使用(mem_assign参照)

*** 関数(手続き)一覧

        ● 機種関係

        ○ 機種判定
        get_machine                  起動機種の判定
        get_machine_98               起動機種の判定(98)
        get_machine_at               起動機種の判定(PC/AT)

        ○ CPU関係
        cx486_cacheoff               Cx486のキャッシュ禁止
        cx486_read                   Cx486キャッシュ制御情報の読み込み
        cx486_write                  Cx486キャッシュ制御情報の書き込み
        get_cpu                      CPUの判別

        ● メモリ関係

        ○ メインメモリ関係
        hmem_alloc                   ヒープからのメモリ確保(16bit パラグ
                                     ラフ)
        hmem_allocbyte               ヒープからのメモリ確保(16bit バイト)
        hmem_free                    hmem_*で確保したメモリの開放
        hmem_getid                   hmem_*で確保したブロックの用途を知
                                     る
        hmem_getsize                 hmem_*で確保したブロックの大きさを
                                     知る
        hmem_lallocate               ヒープからのメモリ確保(20bit バイト
                                     単位)
        hmem_maxfree                 hmem_*で確保可能な最大の大きさを知
                                     る
        hmem_realloc                 hmem_*で確保したブロックの大きさ変
                                     更(16bitパラグラフ)
        hmem_reallocbyte             hmem_*で確保したブロックの大きさ変
                                     更(16bitバイト)
        mem_allocate                 DOSメインメモリを上位から確保する
        mem_assign                   呼び出し側が割り当てたメモリを使用
        mem_assign_all               DOSの最大空きメモリブロックを取得
        mem_assign_dos               指定サイズのメモリブロックをDOSから
                                     取得
        mem_free                     DOSメモリブロックの開放
        mem_lallocate                DOSメインメモリを上位から確保する
                                     (long版)
        mem_unassign                 管理メモリ領域を放棄
        smem_lget                    高速メモリ確保(20bit)
        smem_maxfree                 smem_*で確保できる最大量を計算する
        smem_release                 smem_*で確保したメモリの開放
        smem_wget                    高速メモリ確保(16bit)

        ○ LIM EMS 4.0 操作
        ems_allocate                 EMSメモリの確保
        ems_dos_read                 ファイルからEMSへの読込み
        ems_dos_write                EMSからファイルへの書き込み
        ems_enablepageframe          NEC EMSページフレームバンクの操作
        ems_exist                    EMSの存在検査
        ems_findname                 名前からEMSハンドルを探す
        ems_free                     EMSメモリの開放
        ems_getsegment               EMS物理セグメント情報の取得
        ems_maphandlepage            EMSハンドルページのマップ
        ems_movememoryregion         EMSメモリ領域の移動
        ems_read                     EMSメモリを読む
        ems_reallocate               EMSメモリの再確保
        ems_restorepagemap           EMSページマップの復元
        ems_savepagemap              EMSページマップの待避
        ems_setname                  EMSハンドルに名前を設定する
        ems_size                     EMSハンドルの大きさを得る
        ems_space                    EMSの空きバイト数を得る
        ems_write                    EMSメモリに書き込む

        ○ XMS操作
        xms_allocate                 EMBの確保
        xms_exist                    XMSの存在確認と使用開始
        xms_free                     EMBの開放
        xms_maxfree                  EMBの最大フリーブロックの大きさを得
                                     る
        xms_movememory               EMB−メインメモリ間の転送
        xms_reallocate               EMBの再確保
        xms_size                     EMBハンドルの大きさを得る
        xms_space                    EMBの残り総バイト数を得る

        ○ 常駐データ
        resdata_create               常駐データの作成
        resdata_exist                常駐データの検索
        resdata_free                 常駐データの開放

        ○ 文字、文字列処理
        jis_to_sjis                  JISコードをシフトJISに変換
        sjis_to_jis                  シフトJISコードをJISに変換
        str_comma                    整数のカンマ付き文字列化
        str_ctopas                   C文字列をパスカル文字列に書き換える
        str_iskanji2                 文字列の指定位置の漢字2バイト目判定
        str_pastoc                   パスカル文字列をC文字列に書き換える
        str_printf                   sprintfの簡易版

        ● ディスク・ファイル関連

        ○ MS-DOS 単純ファイル操作
        file_append                  ファイルの追加・読み書きオープン
        file_assign_buffer           作業バッファの割り当て
        file_basename                ファイル名部分を見つける
        file_close                   ファイルを閉じる
        file_create                  ファイルの作成・書き込みオープン
        file_delete                  ファイルの削除
        file_eof                     ファイル末尾を読み込んだかどうか
        file_error                   書き込みエラーの有無
        file_exist                   ファイルの存在検査
        file_flush                   作業バッファのフラッシュ
        file_getc                    ファイルからの1バイト読み込み
        file_gets                    指定文字またはサイズまで読み込む
        file_getw                    ファイルからの1ワード読み込み
        file_lread                   ファイルの読み込み(long版)
        file_lsettime                ファイルの最終更新時刻を変更する
                                     (long版)
        file_lwrite                  ファイルの書き込み(long版)
        file_putc                    ファイルへの1バイト書き込み
        file_putw                    ファイルへの1ワード書き込み
        file_read                    ファイルの読み込み
        file_ropen                   ファイルの読み込みオープン
        file_seek                    ファイルポインタの移動
        file_settime                 ファイルの最終更新時刻を変更する
        file_size                    ファイルの大きさを得る
        file_skip_until              指定文字まで読み捨てる
        file_splitpath               パス名を構成要素に分解
        file_splitpath_slash         パス名を構成要素に分解
        file_tell                    ファイルポインタの読み取り
        file_time                    ファイルの最終更新時刻を得る
        file_write                   ファイルの書き込み

        ○ pf.lib バッファされたファイルアクセス
        bcloser                      ファイルの読み込みクローズ
        bclosew                      ファイルの書き込みクローズ
        bdopen                       ファイルハンドルからの再オープン
        bflush                       書き込みファイルバッファのフラッシ
                                     ュ
        bgetc                        ファイルからの1バイト読み込み
        bopenr                       ファイルの読み込みオープン
        bopenw                       ファイルの書き込みオープン
        bputc                        ファイルへの1バイト書き込み
        bputs                        ファイルへの文字列書き込み
        bputw                        ファイルへの2バイト整数書き込み
        bread                        ファイルからの読み込み
        bseek                        ファイルからの読み込み位置を進める
        bseek_                       ファイルからの読み込み位置の移動
        bsetbufsiz                   次回オープン時のファイルバッファの
                                     大きさの指定
        bwrite                       ファイルへの書き込み

        ○ pf.lib parファイルアクセス
        pfcloser                     parファイルのクローズ
        pfend                        pfオートマチックモード終了
        pfgetc                       parファイルから1文字読み込みます
        pfgetw                       parファイルから2バイト整数を読み込
                                     む
        pfopen                       parファイルのオープン
        pfread                       parファイルからの読み込み
        pfrewind                     parファイルの読み込み位置を先頭に戻
                                     す
        pfseek                       parファイルの読み込み位置を進める
        pfstart                      pfオートマチックモード開始
        pftell                       parファイルの読み込み位置を得る

        ○ MS-DOS一般
        dos_absread                  セクタ指定によるディスク読み込み
        dos_abswrite                 セクタ指定によるディスク書き込み
        dos_allocate                 メモリブロックの確保
        dos_axdx                     文字列を渡してMS-DOSを呼ぶ
        dos_chdir                    カレントディレクトリの設定
        dos_close                    ファイルを閉じる
        dos_copy                     ファイルのコピー
        dos_cputp                    高速なコンソールパスカル文字列出力
        dos_cputs                    高速なコンソール文字列出力
        dos_cputs2                   改行文字変換付きコンソール文字列出
                                     力
        dos_create                   ファイルの作成
        dos_filesize                 ファイルサイズの取得
        dos_findfirst                最初に一致するファイルの検索
        dos_findmany                 一度に複数のファイル検索
        dos_findnext                 次に一致するファイルの検索
        dos_free                     メモリブロックの開放
        dos_get_argv0                起動パス名を得る
        dos_getch                    ^Cで止まらない文字入力
        dos_getcwd                   カレントディレクトリの読み出し
        dos_getdiskfree              ディスクの残り容量の読み出し
        dos_getdrive                 カレントドライブを得る
        dos_get_driveinfo            ディスク容量を得る
        dos_getenv                   環境変数を得る
        dos_getkey                   入力を待たない文字入力
        dos_getkey2                  入力を待たない文字入力(2)
        dos_gets                     文字列の入力(編集なし)
        dos_get_verify               ベリファイフラグの読み取り
        dos_ignore_break             ^Cを無視する設定をする
        dos_keyclear                 キーバッファの消去
        dos_makedir                  深いサブディレクトリの作成
        dos_maxfree                  最大空きメモリブロックサイズの取得
        dos_mkdir                    サブディレクトリの作成
        dos_move                     ディレクトリエントリの移動
        dos_putc                     ^Cで止まらない文字出力
        dos_putch                    高速なコンソール文字出力
        dos_putp                     パスカル文字列出力
        dos_puts                     文字列出力
        dos_puts2                    改行文字変換付き文字列出力
        dos_read                     ファイルの読み込み
        dos_rmdir                    サブディレクトリの削除
        dos_ropen                    ファイルの読み込みオープン
        dos_seek                     ファイルポインタの移動
        dos_setbreak                 ブレーク検査フラグの読み取りと設定
        dos_setdrive                 カレントドライブの設定
        dos_setdta                   ディスク転送アドレスの設定
        dos_setvect                  割り込みベクタの読み取りとフック
        dos_set_verify_off           ベリファイOFF
        dos_set_verify_on            ベリファイON
        dos_write                    ファイルの書き込み
        rsl_exist                    RSLの常駐検査
        rsl_linkmode                 シンボリックリンク変換モードの設定
        rsl_readlink                 シンボリックリンクの読み取り

        ● 入力・操作関係

        ○ キーボード関係
        key_back                     キーバッファへの書き戻し
        key_beep_off                 キーバッファフル音の禁止
        key_beep_on                  キーバッファフル音の許可
        key_end                      特殊キー読み取り設定の破棄
        key_pressed                  先行入力の検査
        key_reset                    キーボードインターフェイスのリセッ
                                     ト
        key_scan                     特殊キーの読み取り
        key_sense                    キーの押し下げ状態の取得
        key_sense_bios               BIOSによるキー入力のセンス
        key_set_label                ファンクションキー表示内容の設定
        key_shift                    シフトキー状態の取得
        key_start                    特殊キー読み取りのための準備
        key_wait                     特殊キーの入力待ち
        key_wait_bios                BIOSによるキー入力待ち
        vkey_scan                    <AT>待たないキー入力
        vkey_shift                   <AT>シフトキー読み取り
        vkey_to_98                   98用キーコードを得る
        vkey_wait                    <AT>キー入力待ち

        ○ 日本語FEPの制御
        fep_exist                    日本語FEPの存在判定
        fep_hide                     日本語FEPの非表示
        fep_show                     日本語FEPの表示
        fep_shown                    日本語FEPの表示状態取得

        ○ マウス制御
        mouse_cmoveto                マウスとカーソルの移動
        mouse_get                    マウスの位置とボタンの読み取り
        mouse_int_disable            マウス割り込みの禁止
        mouse_int_enable             マウス割り込みの許可
        mouse_int_end                マウス割り込みの復帰
        mouse_int_start              マウス割り込みの開始
        mouse_proc                   マウス管理ルーチン
        mouse_proc_init              マウス管理の初期化
        mouse_resetrect              マウス管理矩形の初期化
        mouse_setmickey              マウスの移動速度を指定する
        mouse_setrect                マウス管理矩形の設定
        mouse_vend                   VSYNC割り込みマウス終了
        mouse_vstart                 VSYNC割り込みマウス設定
        mouse_iend                   マウス割り込みマウス終了
        mouse_istart                 マウス割り込みマウス設定
        mousex_end                   外部マウスドライバ使用終了
        mousex_iend                  外部優先マウスの使用終了(簡単)
        mousex_istart                外部優先マウスの使用開始(簡単)
        mousex_moveto                外部マウスドライバカーソル位置設定
        mousex_setrect               外部マウスドライバ移動範囲設定
        mousex_start                 外部マウスドライバ使用開始

        ○ ジョイスティック読み取り
        at_js_calibrate              ジョイスティックのキャリブレート
        at_js_get_calibrate          常駐キャリブレート情報取得
        at_js_resptr                 常駐キャリブレート構造体を得る
        at_js_wait                   ジョイスティックのボタン待ち
        js_analog                    アナログジョイスティック読み取り
        js_end                       ジョイスティック読み取り終了
        at_js_end                    ジョイスティック読み取り終了
        js_key                       (キー割り当て変更・内部関数)
        js_key2player                キーボードでの二人操作設定
        at_js_key2player             キーボードでの二人操作設定
        js_keyassign                 キー割当変更
        js_sense                     現在のジョイスティック状態の取得
        at_js_sense                  現在のジョイスティック状態の取得
        js_sense2                    ジョイスティック読み取り補助
        js_start                     ジョイスティック読み取り開始
        at_js_start                  ジョイスティック読み取り開始

        ● テキスト画面

        ○ PC/AT 画面モード制御
        backup_video_state           復元を前提としたビデオモード取得
        get_video_mode               ビデオモードの取得
        restore_video_state          ビデオモードの復元
        set_video_mode               ビデオモードの設定

        ○ テキスト画面操作
        text_20line                  20行モードにする
        text_25line                  25行モードにする
        text_accesspage              テキスト画面のアクセスページを設定
                                     する
        text_backup                  テキスト画面の保存
        vtext_backup                 テキスト画面の保存
        text_boxfilla                指定範囲の文字属性変更
        vtext_boxfilla               指定範囲の文字属性変更
        text_cemigraph               セミグラフィックを有効にする
        text_clear                   テキスト画面の消去
        vtext_clear                  テキスト画面の消去
        text_cursor_hide             カーソルを消す
        vtext_cursor_hide            カーソルを消す
        _text_cursor_off             BIOSを使用してカーソルを消す
        _text_cursor_on              BIOSを使用してカーソルを表示
        text_cursor_show             カーソルを表示する
        vtext_cursor_show            カーソルを表示する
        text_cursor_shown            カーソルの表示状態を得る
        vtext_cursor_shown           カーソルの表示状態を得る
        text_end                     テキスト画面処理の終了
        text_fillca                  テキスト画面の塗りつぶし
        text_frame                   テキストウィンドウの描画
        vtext_frame                  テキストウィンドウの描画
        text_get                     テキスト画面の領域保存
        vtext_get                    テキスト画面の領域保存
        text_getcurpos               カーソル位置を得る
        vtext_getcurpos              カーソル位置を得る
        text_height                  テキスト画面の行数を得る
        vtext_height                 テキスト画面の行数を得る
        text_hide                    テキスト画面の表示を隠す
        text_locate                  カーソル位置の変更
        vtext_locate                 カーソル位置の変更
        text_preset                  セミグラフィック点消去
        text_pset                    セミグラフィック点描画(属性なし)
        text_pseta                   セミグラフィック点描画(属性つき)
        text_put                     テキスト画面の領域復元
        vtext_put                    テキスト画面の領域復元
        text_putc                    文字の書き込み(属性無し)
        vtext_putc                   文字の書き込み(属性無し)
        text_putca                   文字の書き込み(属性あり)
        vtext_putca                  文字の書き込み(属性あり)
        text_putnp                   文字数指定のパスカル文字列の書き込
                                     み(属性無し)
        text_putnpa                  文字数指定のパスカル文字列の書き込
                                     み(属性あり)
        text_putns                   文字数指定の文字列の書き込み(属性無
                                     し)
        vtext_putns                  文字数指定の文字列の書き込み(属性無
                                     し)
        text_putnsa                  文字数指定の文字列の書き込み(属性あ
                                     り)
        vtext_putnsa                 文字数指定の文字列の書き込み(属性あ
                                     り)
        text_putp                    パスカル文字列の書き込み(属性無し)
        text_putpa                   パスカル文字列の書き込み(属性あり)
        text_puts                    文字列の書き込み(属性無し)
        vtext_puts                   文字列の書き込み(属性無し)
        text_putsa                   文字列の書き込み(属性あり)
        vtext_putsa                  文字列の書き込み(属性あり)
        text_restore                 テキスト画面の復元
        vtext_restore                テキスト画面の復元
        text_roll_area               スクロール範囲の指定
        text_roll_down_c             下スクロール(属性なし)
        vtext_roll_down_c            下スクロール(属性なし)
        text_roll_down_ca            下スクロール(属性つき)
        vtext_roll_down_ca           下スクロール(属性つき)
        text_roll_left_c             左スクロール(属性なし)
        text_roll_left_ca            左スクロール(属性つき)
        text_roll_right_c            右スクロール(属性なし)
        text_roll_right_ca           右スクロール(属性つき)
        text_roll_up_c               上スクロール(属性なし)
        vtext_roll_up_c              上スクロール(属性なし)
        text_roll_up_ca              上スクロール(属性つき)
        vtext_roll_up_ca             上スクロール(属性つき)
        text_setcursor               カーソル形状の変更
        vtext_setcursor              カーソル形状の変更
        text_show                    テキスト画面の表示
        text_shown                   テキスト画面の表示状態を得る
        text_showpage                テキスト画面の表示ページを設定する
        text_smooth                  テキストスムーススクロールのシフト
                                     値を指定
        text_smooth_end              テキストスムーススクロールの終了
        text_smooth_start            テキストスムーススクロール範囲の指
                                     定
        text_start                   テキスト画面処理の開始
        vtext_start                  テキスト画面処理の開始
        text_systemline_hide         画面最下行のシステムラインの消去
        vtext_systemline_hide        画面最下行のシステムラインの消去
        text_systemline_show         画面最下行のシステムラインの表示
        vtext_systemline_show        画面最下行のシステムラインの表示
        text_systemline_shown        画面最下行のシステムラインの表示状
                                     態を得る
        vtext_systemline_shown       画面最下行のシステムラインの表示状
                                     態を得る
        text_vertical                セミグラフィックを無効にする
        text_vputs                   文字列の縦書き(属性なし)
        text_vputsa                  文字列の縦書き(属性あり)
        text_width                   テキスト画面の桁数を得る
        vtext_width                  テキスト画面の桁数を得る
        text_worddota                セミグラフィックの水平16ドットイメ
                                     ージ描画(属性つき)
        TX_GETSIZE                   テキスト領域保存に必要なメモリの大
                                     きさを得る
        vtext_color_98               PC-9801文字属性を PC/AT 用に変換
        vtext_getcursor              カーソル形状を得る
        vtext_font_height            テキストフォントの縦ドット数を得る
        vtext_refresh                仮想テキスト画面の一部の再描画
        vtext_refresh_all            仮想テキスト画面全体を再描画
        vtext_refresh_off            描画非リフレッシュ指定
        vtext_refresh_on             描画即リフレッシュ指定
        vtextx_end                   グラフィック画面テキスト処理の終了
        vtextx_start                 グラフィック画面テキスト処理の開始

        ○ PC-9801 30行BIOS制御
        bios30_exist                 30行BIOS API の存在検査
        bios30_getclock              30行BIOSによるGDCクロックの取得
        bios30_getlimit              30行関連の設定可能行数範囲の取得
        bios30_getline               30行BIOSの管理行数の読み取り
        bios30_getmode               30行BIOSのモード取得
        bios30_getparam              30行BIOSのGDCパラメータの取得
        bios30_getversion            30行BIOS/TTのバージョン取得
        bios30_getvsync              30行BIOSにによるVSYNC周波数の取得
        bios30_lock                  30行BIOSの常駐解除禁止
        bios30_pop                   30行BIOSのモード復元
        bios30_push                  30行BIOSのモード保存
        bios30_setclock              30行BIOSによるGDCクロックの変更
        bios30_setline               30行BIOSに行間なしの時の行数を設定
                                     する
        bios30_setmode               30行BIOSのモード設定
        bios30_tt_exist              30行関連(30bios,TT)の存在検査
        bios30_unlock                30行BIOSの常駐解除許可

        ● グラフィック処理

        ○ グラフィック画面関係
        GB_GETSIZE                   グラフィック領域保存に必要なメモリ
                                     の大きさを得る
        graph_16color                9821 16色モードに設定
        graph_200line                グラフィック画面を200lineに設定する
        graph_24kHz                  9821水平周波数を24kHzに設定する
        graph_256color               9821 256色モードに設定
        graph_31kHz                  9821水平周波数を31kHzに設定する
        graph_400line                グラフィック画面を400lineに設定する
        at98_graph_400line           グラフィック画面を400lineに設定する
        graph_480line                9821画面を480lineモードに設定する
        graph_accesspage             グラフィック画面CPUアクセスページ設
                                     定
        at98_accesspage              グラフィック画面CPUアクセスページ設
                                     定
        graph_analog                 パレットモードをアナログ16色にする
        graph_ank_putc               半角文字の描画
        graph_ank_putp               半角(パスカル)文字列の描画
        graph_ank_puts               半角文字列の描画
        graph_clear                  グラフィック画面の消去
        vga4_clear                   グラフィック画面の消去
        graph_copy_page              グラフィック画面の内容を他のページ
                                     から複写する
        graph_backup                 グラフィック画面(表裏とも)のEMSへの
                                     保存
        graph_bfnt_putc              BFNT文字の描画
        vgc_bfnt_putc                BFNT文字の描画
        graph_bfnt_putp              パスカル文字列描画(BFNT)
        graph_bfnt_puts              BFNT文字列の描画
        vgc_bfnt_puts                BFNT文字列の描画
        graph_byteget                グラフィック画面の領域保存
        vga4_byteget                 グラフィック画面の領域保存
        graph_byteput                グラフィック画面の領域復元
        vga4_byteput                 グラフィック画面の領域復元
        graph_crt                    画面のドットずれ補正解除
        graph_digital                パレットモードをデジタル8色にする
        graph_end                    グラフィック画面一括終了処理
        vga4_end                     グラフィック画面一括終了処理
        graph_enter                  グラフィック画面を消さない初期設定
        graph_extmode                9821拡張グラフィックモードの設定／
                                     取得
        graph_font_put               1文字描画
        vgc_font_put                 1文字描画
        graph_font_putp              パスカル文字列描画
        graph_font_puts              文字列描画
        vgc_font_puts                文字列描画
        graph_gaiji_putc             外字描画
        graph_gaiji_puts             外字文字列描画
        graph_getextmode             9821拡張グラフィックモードの取得
        graph_hide                   グラフィック画面の表示を隠す
        graph_is256color             9821 256色モードかどうか判定
        graph_is31kHz                9821が水平周波数31kHzかどうか得る
        graph_kanji_put              全角文字描画
        graph_kanji_large_put        4倍角漢字描画
        graph_kanji_puts             全角文字列描画
        graph_leave                  グラフィック画面を消さない終了処理
        graph_pack_get_8             パックデータ読み取り(8dot単位)
        vga4_pack_get_8              パックデータ読み取り(8dot単位)
        graph_pack_put_8             パックデータ描画(8dot単位)
        vga4_pack_put_8              パックデータ描画(8dot単位)
        graph_pi_comment_load        Pi画像ファイルのコメント部分読み込
                                     み
        graph_pi_free                Pi画像をメモリから開放
        graph_pi_load_pack           16色Pi画像fileのメモリへの読み込み
                                     (1バイト=2dot)
        graph_plasma                 画面のドットずれ補正
        graph_readdot                グラフィック画面の任意の地点の色を
                                     得る
        vga4_readdot                 グラフィック画面の任意の地点の色を
                                     得る
        graph_restore                EMSに退避したグラフィック画面の復元
        graph_setextmode             9821拡張グラフィックモードの設定
        graph_show                   グラフィック画面を表示する
        graph_shown                  グラフィック画面の表示状態を得る
        graph_showpage               グラフィック画面表示ページ設定
        at98_showpage                グラフィック画面表示ページ設定
        graph_scroll                 グラフィック画面をハードウェアスク
                                     ロールする
        at98_scroll                  グラフィック画面をハードウェアスク
                                     ロールする
        graph_scrollup               グラフィック画面をハードウェア縦ス
                                     クロールする
        graph_start                  16色グラフィック画面一括初期設定
        vga4_start                   16色グラフィック画面一括初期設定
        graph_unpack_get_8           バイト単位データ読み取り(8dot単位)
        vga4_unpack_get_8            バイト単位データ読み取り(8dot単位)
        graph_unpack_large_put_8     バイト単位4倍角データ描画(8dot単位)
        graph_unpack_put_8           バイト単位データ描画(8dot単位)
        vga4_unpack_put_8            バイト単位データ描画(8dot単位)
        graph_wank_putc              圧縮半角文字描画
        graph_wank_putca             圧縮半角文字描画(色指定)
        graph_wank_puts              圧縮半角文字列描画
        graph_wank_putsa             圧縮半角文字列描画(色指定)
        graph_wfont_plane            圧縮半角文字描画のプレーン設定
        graph_wfont_put              圧縮1文字描画
        graph_wfont_puts             圧縮文字列描画
        graph_wkanji_put             圧縮全角文字描画
        graph_wkanji_puts            圧縮全角文字列描画
        graph_xlat_dot               グラフィック画面の点の色を置き換え
                                     る
        graph_xorboxfill             XOR矩形塗り潰し
        mag_free                     MAG画像をメモリから開放
        mag_load_pack                16色MAG画像fileのメモリへの読み込み
        vga4_bfnt_putc               BFNT文字描画(上書き)
        vga4_bfnt_puts               BFNT文字列描画(上書き)
        vga4_byte_move               矩形部分の転送(横8dot単位)
        vga_dc_modify                VGAレジスタのビット操作
        vga_setline                  表示ライン数の設定
        vga_startaddress             表示開始アドレスの設定
        vga_vzoom_off                縦2倍拡大モードOFF
        vga_vzoom_on                 縦2倍拡大モードON
        vgc_kanji_putc               全角文字の描画
        vgc_kanji_puts               全角文字列の描画
        vgc_start                    640x480dot 16色グラフィック設定

        ○ アナログ16色パレット制御
        palette_100                  明るさを100%にする
        dac_100                      明るさを100%にする
        palette_black                画面を真っ黒にする
        dac_black                    画面を真っ黒にする
        palette_black_in             画面を黒からフェードインする
        dac_black_in                 画面を黒からフェードインする
        palette_black_out            画面を黒にフェードアウトする
        dac_black_out                画面を黒にフェードアウトする
        palette_entry_rgb            RGBファイルを読み込む
        palette_init                 パレット変数の初期化
        dac_init                     パレット変数の初期化
        palette_set                  パレットを一つ設定する
        palette_set_all              パレットを全部設定する(256階調)
        palette_set_all_16           パレットを全部設定する(16階調)
        palette_settone              パレットの明るさを設定する
        dac_settone                  パレットの明るさを設定する
        palette_show                 パレット変数の画面への反映
        dac_show                     パレット変数の画面への反映
        palette_show100              パレット変数の画面への反映(100%固定)
        palette_white                画面を真っ白にする
        dac_white                    画面を真っ白にする
        palette_white_in             画面を白からフェードインする
        dac_white_in                 画面を白からフェードインする
        palette_white_out            画面を白にフェードアウトする
        dac_white_out                画面を白にフェードアウトする

        ○ PC-9801 ノーマルモード常駐パレット操作
        respal_create                常駐パレットの作成
        respal_exist                 常駐パレットの存在検査
        respal_free                  常駐パレットの開放
        respal_get_palettes          常駐パレットからパレット変数への読
                                     み込み
        respal_set_palettes          パレット変数から常駐パレットへの書
                                     き込み

        ○ PC-9801 外字処理
        gaiji_backup                 外字の退避
        gaiji_entry_bfnt             外字をBFNTファイルから登録する
        gaiji_putc                   外字で1文字表示(属性なし)
        gaiji_putca                  外字で1文字表示(属性あり)
        gaiji_putni                  外字で数字列を表示(幅指定あり,属性
                                     なし)
        gaiji_putnia                 外字で数字列を表示(幅指定あり,属性
                                     あり)
        gaiji_putp                   外字でパスカル文字列を表示(属性なし)
        gaiji_putpa                  外字でパスカル文字列を表示(属性あり)
        gaiji_puts                   外字で文字列を表示(属性なし)
        gaiji_putsa                  外字で文字列を表示(属性あり)
        gaiji_read                   外字の読み取り(1文字)
        gaiji_read_all               外字の読み取り(256文字)
        gaiji_restore                外字の復元
        gaiji_write                  外字の登録(1文字)
        gaiji_write_all              外字の登録(256文字)

        ○ フォント処理
        font_at_entry_cgrom          <AT>システム半角fontを内部半角フォ
                                     ントに登録
        font_at_init                 <AT>フォントの読み取り準備
        font_at_read                 <AT>フォントの読み取り
        font_entry_bfnt              フォントのBFNTファイルからの登録
        font_entry_cgrom             フォントのCG ROMからの登録
        font_entry_gaiji             フォントの外字からの登録
        font_entry_kcg               フォントの2バイト半角からの登録
        font_read                    フォントの読み取り
        font_write                   フォントの登録
        wfont_entry_bfnt             圧縮フォントのBFNTファイルからの登
                                     録

        ○ グラフィックカーソル
        cursor_hide                  カーソルの表示カウンタ減少
        cursor_init                  カーソル表示状態の初期化
        cursor_moveto                カーソルの移動
        cursor_pattern               カーソルパターンの定義1
        cursor_pattern2              カーソルパターンのMOUSE.COM風定義
        cursor_setpattern            カーソルパターンの定義2
        cursor_show                  カーソルの表示カウンタ増加

        ○ パターン/キャラクタの登録/削除
        super_backup_ems             登録されたパターンをEMSに待避
        super_cancel_pat             パターンの削除
        super_change_erase_pat       消去パターンの変更
        super_clean                  複数パターンの削除
        super_convert_tiny           パターンデータ形式を高速表示用に変
                                     換
        super_dup                    パターンの複製を登録
        super_duplicate              パターンの複製を指定番号に登録
        super_entry_at               パターンを直接登録
        super_entry_char             パターンをキャラクタに登録
        super_entry_pack             パック16色データからパターンを登録
        super_entry_pat              パターンのアドレスを指定して登録
        super_free                   すべてのパターンとキャラクタの削除
        super_free_ems               EMSに待避されたパターンを開放
        super_hrev                   パターンを左右反転
        super_restore_ems            EMSに待避されたパターンを再登録

        ○ BFNT/BFNT+
        bfnt_change_erase_pat        (低)BFNTファイルから消去パターンを
                                     設定
        bfnt_entry_pat               (低)BFNT+ファイルからパターンを登録
        bfnt_extend_header_analysis  (低)BFNT+ファイルから透明色を得る
        bfnt_extend_header_skip      (低)BFNT+ファイルの拡張ヘッダを飛ば
                                     す
        bfnt_header_load             BFNT/BFNT+ファイルのヘッダを読む
        bfnt_header_read             (低)BFNT+ファイルのヘッダを読む
        bfnt_palette_set             (低)BFNT+ファイルからパレット情報を
                                     読む
        bfnt_palette_skip            (低)BFNT+ファイルのパレット情報を無
                                     視する
        fontfile_close               (低)BFNT+ファイルを閉じる
        fontfile_open                (低)BFNT+ファイルを開く
        super_change_erase_bfnt      (高)BFNTファイルから消去パターンを
                                     一括設定
        super_entry_bfnt             (高)BFNT+ファイルからパターンに一括
                                     登録

        ○ パターンの調査
        super_check_entry            パターンの存在検査
        super_getsize_pat            パターンの大きさを得る
        super_getsize_pat_x          パターンの幅を得る
        super_getsize_pat_y          パターンの高さを得る

        ○ パターンの表示(super_put系)
        repair_back                  パターンを裏画面の絵で消去(8dot単位)
        vga4_repair_back             パターンを裏画面の絵で消去(8dot単位)
        slice_put                    パターンの指定ラインを表示(8dot単位)
        super_put                    パターンの表示
        vga4_super_put               パターンの表示
        super_put_8                  パターンの表示(8dot単位)
        vga4_super_put_8             パターンの表示(8dot単位)
        super_put_clip               パターンの表示(y clip)
        vga4_super_put_clip          パターンの表示(y clip)
        super_put_clip_8             パターンの表示(y clip, 8dot単位)
        super_put_tiny               16xｎdotパターンの高速表示
        super_put_tiny_small         8xｎdotパターンの高速表示
        super_put_tiny_small_vrev    8xｎdotパターンの高速表示(上下反転)
        super_put_tiny_vrev          16xｎdotパターンの高速表示(上下反転)
        super_put_vrev               パターンの表示(上下反転)
        vga4_super_put_vrev          パターンの表示(上下反転)
        super_repair                 パターンを裏画面の絵で消去
        super_roll_put               パターンの表示(画面上下接続)
        vga4_super_roll_put          パターンの表示(画面上下接続)
        super_roll_put_8             パターンの表示(画面上下接続, 8dot単
                                     位)
        super_roll_put_tiny          16x16dotパターンの高速表示(画面上下
                                     接続)

        ○ キャラクタの表示(super_in系)
        repair_out                   キャラクタの除去(8dot単位)
        vga4_repair_out              キャラクタの除去(8dot単位)
        super_in                     キャラクタの表示
        vga4_super_in                キャラクタの表示
        super_out                    キャラクタの除去

        ○ 仮想VRAM系
        virtual_copy                 仮想VRAMの確保と実画面からの転送
        vga4_virtual_copy            仮想VRAMの確保と実画面からの転送
        virtual_free                 仮想VRAMの開放
        virtual_repair               仮想VRAMから実画面へ転送
        vga4_virtual_repair          仮想VRAMから実画面へ転送
        virtual_vram_copy            実画面を仮想VRAMに転送する
        vga4_virtual_vram_copy       実画面を仮想VRAMに転送する

        ○ plane系
        super_roll_put_1plane        パターンを指定プレーンに表示(画面上
                                     下接続)
        super_roll_put_1plane_8      パターンを指定プレーンに表示(8dot単
                                     位, 画面上下接続)
        super_put_1plane             パターンを指定プレーンに表示
        vga4_super_put_1plane        パターンを指定プレーンに表示
        super_put_1plane_8           パターンを指定プレーンに表示(8dot単
                                     位)
        vga4_super_put_1plane_8      パターンを指定プレーンに表示(8dot単
                                     位)

        ○ window系
        super_put_rect               枠クリッピング型パターン表示
        vga4_super_put_rect          枠クリッピング型パターン表示
        super_put_vrev_rect          枠クリッピング型パターン表示(上下反
                                     転)
        vga4_super_put_vrev_rect     枠クリッピング型パターン表示(上下反
                                     転)
        super_put_window             上下クリップ枠に対応したパターン表
                                     示
        super_set_window             上下クリップ枠を設定する

        ○ over_put系
        over_put_8                   パターンの上書き(8dot単位)
        vga4_over_put_8              パターンの上書き(8dot単位)
        over_roll_put_8              パターンの上書き(画面上下接続, 8dot
                                     単位)
        vga4_over_roll_put_8         パターンの上書き(画面上下接続, 8dot
                                     単位)

        ○ 拡大/縮小/変形表示
        over_small_put_8             パターンの2分の1縮小表示(8dot単位)
        super_large_put              パターンの2倍拡大表示
        vga4_super_large_put         パターンの2倍拡大表示
        super_vibra_put              パターンを縦方向に伸縮変形表示
        vga4_super_vibra_put         パターンを縦方向に伸縮変形表示
        super_vibra_put_1plane       パターンを縦方向に揺らして表示(指定
                                     プレーン)
        super_wave_put               パターンを横方向に波状変形表示
        vga4_super_wave_put          パターンを横方向に波状変形表示
        super_wave_put_1plane        パターンを横方向に波状変形表示(指定
                                     プレーン)
        vga4_super_wave_put_1plane   パターンを横方向に波状変形表示(指定
                                     プレーン)
        super_zoom                   パターンの任意拡大表示
        vga4_super_zoom              パターンの任意拡大表示
        super_zoom_put               パターンの拡大/縮小表示
        vga4_super_zoom_put          パターンの拡大/縮小表示
        super_zoom_put_1plane        パターンの拡大/縮小表示(指定プレー
                                     ン)
        super_zoom_v_put             パターンの縦拡大/縮小表示
        super_zoom_v_put_1plane      パターンの縦拡大/縮小表示(指定プレ
                                     ーン)
        vga4_super_zoom_v_put_1plane パターンの縦拡大/縮小表示(指定プレ
                                     ーン)

        ○ 図形描画・設定関係
        grc_setclip                  クリップ枠を設定する

        ○ 図形描画・色設定
        grcg_and                     GRCGの描画モード(AND)設定
        grcg_off                     GRCGのスイッチを切る
        grcg_or                      GRCGの描画モード(OR)設定
        grcg_setcolor                GRCGのモードおよび色設定
        grcg_setmode                 GRCGのモード設定
        grcg_settile_1line           GRCGのモードおよびタイルパターン
                                     (1line)設定
        vgc_setcolor                 描画色の指定

        ○ 図形描画
        grc_clip_line                直線データのクリッピング
        grc_clip_polygon_n           凸/凹多角形データのクリッピング
        grcg_boxfill                 長方形描画
        vgc_boxfill                  長方形描画
        grcg_byteboxfill_x           横8ドット単位の長方形描画
        vgc_byteboxfill_x            横8ドット単位の長方形描画
        grcg_bytemesh_x              横8ドット単位の市松模様塗り潰し
        vgc_bytemesh_x               横8ドット単位の市松模様塗り潰し
        grcg_circle                  円描画
        vgc_circle                   円描画
        grcg_circle_x                円描画(クリッピングなし)
        vgc_circle_x                 円描画(クリッピングなし)
        grcg_circlefill              円塗りつぶし
        vgc_circlefill               円塗りつぶし
        grcg_fill                    クリップ枠全面塗りつぶし
        grcg_hline                   水平線描画
        vgc_hline                    水平線描画
        grcg_line                    直線描画
        vgc_line                     直線描画
        grcg_polygon_c               凸多角形描画
        vgc_polygon_c                凸多角形描画
        grcg_polygon_cx              凸多角形描画(クリッピングなし)
        vgc_polygon_cx               凸多角形描画(クリッピングなし)
        grcg_polygon_vcx             凸多角形描画(クリッピングなし,可変
                                     引数)
        vgc_polygon_vcx              凸多角形描画(クリッピングなし,可変
                                     引数)
        grcg_pset                    点描画
        vgc_pset                     点描画
        grcg_round_boxfill           角の丸い長方形描画
        vgc_round_boxfill            角の丸い長方形描画
        grcg_thick_line              四角いペンによる直線描画
        vgc_thick_line               四角いペンによる直線描画
        grcg_trapezoid               台形塗り潰し
        vgc_trapezoid                台形塗り潰し
        grcg_triangle                三角形塗り潰し
        vgc_triangle                 三角形塗り潰し
        grcg_triangle_x              三角形描画(クリッピングなし)
        grcg_vline                   垂直線描画
        vgc_vline                    垂直線描画
        vgc_byteboxfill_x_pset       長方形塗り潰し(8dot単位,演算なし)
        vgc_line2                    直線描画(ラインスタイルつき)

        ○ PC-9801 GDCによる描画
        gdc_circle                   GDC による円描画
        gdc_line                     GDC による直線描画
        gdc_setaccessplane           VRAM アクセスプレーンの設定
        gdc_setcolor                 描画色と演算の設定
        gdc_setlinestyle             ラインスタイルの設定
        gdc_wait                     GDC 描画完了待ち

        ○ PC-9801 EGC操作
        egc_end                      EGCの終了処理
        egc_off                      EGCをGRCG互換モードに設定する
        egc_on                       EGCを拡張モードに設定する
        egc_scroll_left              EGCによる円筒左スクロール
        egc_scroll_right             EGCによる円筒右スクロール
        egc_selectfg                 P入力にFG色を選択
        egc_selectbg                 P入力にBG色を選択
        egc_selectpat                P入力にパターンレジスタを選択
        egc_setbgcolor               BG色の設定
        egc_setfgcolor               FG色の設定
        egc_setrop                   EGCのモードとROPを設定する
        egc_shift_down               EGCによる部分下スクロール
        egc_shift_down_all           EGCによる下スクロール
        egc_shift_left               EGCによる部分左スクロール
        egc_shift_left_all           EGCによる左スクロール
        egc_shift_right              EGCによる部分右スクロール
        egc_shift_right_all          EGCによる右スクロール
        egc_shift_up                 EGCによる部分上スクロール
        egc_shift_up_all             EGCによる上スクロール
        egc_start                    EGCの初期設定
        has_egc                      EGCが利用できるかどうかの判定

        ● 割り込み

        ○ VSYNC割り込み
        vsync_end                    VSYNC割り込みの使用終了
        vga_vsync_end                VSYNC割り込みの使用終了
        vsync_enter                  VSYNC割り込みのチェイン設定
        vsync_leave                  VSYNC割り込みのチェイン解放
        vsync_proc_reset             VSYNC毎に実行する関数の指定解除
        vsync_proc_set               VSYNC毎に実行する関数の指定
        vsync_start                  VSYNC割り込みの設定およびカウンタリ
                                     セット
        vga_vsync_start              VSYNC割り込みの設定およびカウンタリ
                                     セット
        vsync_wait                   次のVSYNC開始を待つ
        vga_vsync_wait               次のVSYNC開始を待つ

        ○ タイマ割り込み
        timer_end                    タイマ割り込みの使用停止
        timer_start                  タイマ割り込みの設定およびカウンタ
                                     リセット

        ● 音関係

        ○ BEEP音関係
        beep_end                     BEEP音の停止と周波数の復帰
        beep_freq                    BEEP音の周波数を設定する
        vbeep_freq                   BEEP音の周波数を設定する
        beep_off                     BEEP音を止める
        beep_on                      BEEP音を鳴らす

        ○ BEEP PCM関係
        pcm_convert                  PCMデータの変換
        pcm_play                     PCMデータの再生

        ○ BEEP音によるBGMと効果音の再生
        bgm_cont_play                曲の演奏の再開
        bgm_finish                   演奏機能の後始末
        bgm_init                     演奏機能の準備
        bgm_read_data                BGMファイルから曲データを読み込む
        bgm_read_sdata               EFSファイルから効果音データを読み込
                                     む
        bgm_read_status              演奏機能の状態の読み取り
        bgm_repeat_off               曲のくり返し演奏を行わない
        bgm_repeat_on                曲のくり返し演奏を行う
        bgm_select_music             演奏する曲の選択
        bgm_set_mode                 曲演奏／効果音出力動作の可否を設定
        bgm_set_tempo                曲のテンポを設定
        bgm_sound                    効果音出力の開始
        bgm_start_play               曲の演奏の開始
        bgm_stop_play                曲の演奏の中断
        bgm_stop_sound               効果音出力の停止
        bgm_wait_play                演奏中の曲の終了待ち
        bgm_wait_sound               効果音出力の終了待ち

        ● 通信関係

        ○ PC-9801 RS-232C関係
        sio_bit_off                  DTR,RTS,BREAK制御線OFF
        sio_bit_on                   DTR,RTS,BREAK制御線ON
        sio_disable                  (RS-232C割り込み禁止)
        sio_enable                   (RS-232C割り込み許可)
        sio_end                      RS-232C制御ルーチンの開放(1)
        sio_enter                    RS-232C制御ルーチンの初期化(2)
        sio_error_reset              パリティエラーなどのフラグをクリア
                                     する
        sio_getc                     1文字受信
        sio_leave                    RS-232C制御ルーチンの開放(2)
        sio_putc                     1文字送信
        sio_putp                     パスカル文字列送信
        sio_puts                     文字列送信
        sio_read                     データブロック受信
        sio_read_dr                  DR(DSR)信号線読み取り
        sio_read_err                 パリティエラーなどのフラグを読む
        sio_read_signal              CI,CS,CD信号線読み取り
        sio_receivebuf_len           受信バッファ内のバイト数を得る
        sio_sendbuf_len              送信バッファ内のバイト数を得る
        sio_sendbuf_space            送信バッファ内の空きバイト数を得る
        sio_setspeed                 RS-232C速度指定
        sio_start                    RS-232C制御ルーチンの初期化(1)
        sio_write                    データブロック送信

        ● その他

        ○ その他
        Atan8                        アークタンジェント(256度系)
        AtanDeg                      アークタンジェント(360度系)
        BYTE2PARA                    バイト数をパラグラフ数に変換する
        FP2LONG                      farポインタを0:0からのlongオフセッ
                                     トに変換
        FPADD                        farポインタにlongオフセットを加算
        FP_REGULAR                   farポインタの正規化
        FP_REGULAR_SEG               farポインタの正規セグメントを得る
        FP_REGULAR_OFF               farポインタの正規オフセットを得る
        get_ds                       データセグメントを得る
        iatan2                       (x,y)の角度を得る(アークタンジェン
                                     ト)(256度系)
        iatan2deg                    (x,y)の角度を得る(アークタンジェン
                                     ト)(360度系)
        ihypot                       距離
        INPB                         I/Oポートからの読み込み(バイト/ワー
                                     ド)
        INPW                         I/Oポートからの読み込み(バイト/ワー
                                     ド)
        irand                        擬似乱数
        irand_init                   乱数系列の初期化
        isqrt                        平方根
        LONG2FP                      0:0からのlongオフセットをfarポイン
                                     タに変換
        MK_FP                        segment,offsetからfarポインタを合成
        OUTB                         I/Oポートへの書き込み(バイト/ワード)
        OUTW                         I/Oポートへの書き込み(バイト/ワード)
        peekb2                       メモリからの1バイト読み出し
        poke2                        メモリを指定データで埋める
        pokeb2                       メモリへの1バイト書き込み
        SEG2FP                       セグメント値をポインタに変換する
        Sin8                         サイン、コサイン(256度系)
        Cos8                         サイン、コサイン(256度系)
        SinDeg                       サイン、コサイン(360度系)
        CosDeg                       サイン、コサイン(360度系)

==================================================--- Function Reference


------------------------------------------------------------------------
■ 機種関係 ■■■■■■■■■■■■■■■■■■■■■■■■■■■■■■


------------------------------------------------------------------------
■ 機種判定 ■■■■■■■■■■■■■■■■■■■■■■■■■■■■■■

        　master.lib 0.22 からは AT互換機も動作対象としているため、 起動
        された機種を判定して処理を分ける必要があります。

------------------------------------------------------------------------
□ 構造体／グローバル変数

const unsigned Machine_State ;  get_machine()によって設定された機種判別
                                情報

------------------------------------------------------------------------
□ 定数

        ● 機種判定ビットマスク

        ・98関係                ・AT互換機関係
        表記    値              表記    値
        PC9801  0x0020          PC_AT   0x0010

        DESKTOP 0x0001          LANG_US 0x0001
        EPSON   0x0002          PS55    0x0000
        PC_MATE 0x0004          DOSV    0x0002
        HIRESO  0x0008          PC_AX   0x0004
                                J3100   0x0006
        ・FMR関係               DR_DOS  0x0008
        表記    値              MSDOSV  0x000a
        FMR     0x0080          DOSVEXTENTION 0x0040
                                ANSISYS 0x0100

        ・全機種
        表記    値
        DOSBOX  0x8000

------------------------------------------------------------------------
□ get_machine - 起動機種の判定

C:      unsigned get_machine(void);

        ------------------------------------------98N 98H AT DOS-
        get_machine                                ○  ○ ○
        ------------------------------------------<getmachi.asm>-

                ● 起動された機種を判定します。また、
                   Machine_State変数にも戻り値と同じ値を格納しま
                   す。

                →  PC9801 が ONのとき:    get_machine_98参照
                    PC_AT が ONのとき:     get_machine_at参照
                    どちらもONでないとき:  機種は不明


                ★ PC-9801,PC/AT(互換機,J3100含む) 上での動作のみ
                   想定しています。その他の機種で起動した場合、結
                   果は不定です。機種不明と返されるとは限りません
                   し、ハングアップする可能性もあります。

                ○ 参照:  get_machine_98(), get_machine_at()

------------------------------------------------------------------------
□ get_machine_98 - 起動機種の判定(98)

C:      unsigned get_machine_98(void);

        ------------------------------------------98N 98H AT DOS-
        get_machine_98                             ○  ○ ×
        ------------------------------------------<getmac98.asm>-

                ● 起動された 98 の大まかな種別を判定します。また、
                   Machine_State変数にも戻り値と同じ値を格納しま
                   す。

                → 以下のビットの組み合わせ
                    PC9801   (常にON)
                    DESKTOP  (ONなら DESKTOP, OFFなら98NOTE)
                    EPSON    (ONなら EPSON, OFFなら NEC)
                    PC_MATE  (ONなら MATEの480line機能が存在する,
                             OFFならノーマル機)
                    HIRESO   (ONなら現在ハイレゾモード, OFFならノ
                             ーマルモード)
                    DOSBOX   (ONなら Windows  386エンハンストモー
                             ドか WindowsNTか OS/2内, OFFなら普通
                             のDOSから起動された)

                ★ 動作機種が 98 であると断定された状況でのみ正常
                   に動作します。

                例: m = get_machine_98();
                    if ( m & HIRESO ) {
                      /* ハイレゾ用処理 */
                    }

                ○ EPSON note は、以下の 8 機種の場合 note と判断
                   されます。
                   　これ以外は、DESK TOP と判断されます。 これら
                   8 機種以外に Note が存在する場合(新製品等)、ご
                   一報ください。追加致します。
                   　ただし、追加時に環境を調べる必要がありますの
                   で、その note を触れる環境にある人が連絡して頂
                   かなくては、意味がありません。

                PC286NoteE,     PC286NoteF,     PC386NoteA,
                PC386NoteW,     PC386NoteAE,    PC386NoteWR,
                PC386NoteAR,    PC486NoteAS

                ○ 参照:  get_machine(), get_machine_at()

------------------------------------------------------------------------
□ get_machine_at - 起動機種の判定(PC/AT)

C:      unsigned get_machine_at(void);

        ------------------------------------------98N 98H AT DOS-
        get_machine_at                             ×  × ○
        ------------------------------------------<getmacat.asm>-

                ● 起動された PC/AT互換機などの大まかな種別を判定
                   します。また、 Machine_State変数にも戻り値と同
                   じ値を格納します。

                → 以下のビットの組み合わせ
                    PC_AT    (常にON)
                    LANG_US  (ONなら英語モード, OFFなら日本語モー
                             ド)
                    PC_TYPE_MASK との論理積の結果によって、以下の
                    ように分類されます。
                      PS55      IBM PS/55
                      DOSV      DOS/V
                      PC_AX     AX
                      J3100     東芝 J3100
                      DR_DOS    DR-DOS
                      MSDOSV    MS-DOS/V
                    DOSBOX   (ONなら Windows  386エンハンストモー
                             ドか WindowsNTか OS/2内, OFFなら普通
                             のDOSから起動された)

                例: m = get_machine_at();
                    if ( m & LANG_US ) {
                      /* 英語モードの処理 */
                    } else {
                      /* 日本語モードの処理 */
                    }
                    if ( (m & PC_TYPE_MASK) == J3100 ) {
                      /* J3100の処理 */
                    }

                ★ 動作機種が PS/55,PC/AT,J3100系であると断定され
                   た状況でのみ正常に動作します。

                ○ 参照:  get_machine(), get_machine_98()


------------------------------------------------------------------------
■ CPU関係 ■■■■■■■■■■■■■■■■■■■■■■■■■■■■■■

        動作しているコンピュータのCPUの判別や、Cyrix製Cx486のキャ
        ッシュ制御などを行います。

------------------------------------------------------------------------
□ 構造体／グローバル変数

struct Cx486CacheInfo {
        unsigned ccr0 ;         キャッシュ制御レジスタ
        unsigned ccr1 ;
        unsigned long ncr[4] ;  キャッシュ禁止領域レジスタ
} ;

------------------------------------------------------------------------
□ 定数

        ● CPUメーカー定数(get_cpu())
        表記            値      意味
        CPU_CYRIX       0x4000  Cyrix Cx486
        CPU_NEC         0x8000  NEC V30

        ● CPUモード定数(get_cpu())
        表記            値      意味
        CPU_V86MODE     0x0100  仮想86モード

        ● CPU種別定数(get_cpu())
        表記            値      意味
        CPU_TYPEMASK    0x00ff  CPU種別のビットマスク
        CPU_TYPE086     0x0000  8086
        CPU_TYPE186     0x0001  80186
        CPU_TYPE286     0x0002  80286
        CPU_TYPE386     0x0003  386
        CPU_TYPE486     0x0004  486
        CPU_TYPEPENTIUM 0x0005  Pentium

------------------------------------------------------------------------
□ cx486_cacheoff - Cx486のキャッシュ禁止

C:      void cx486_cacheoff(void);

        ------------------------------------------98N 98H AT DOS-
        cx486_cacheoff
        -------------------------------------------<cx486rw.asm>-

                ● Cx486の4GBのメモリ空間すべてをキャッシュ禁止に
                   します。

                ★ Cx486以外で実行してはいけません。  get_cpu()で
                   CPU_CYRIXのビットが立っていることを確認してか
                   ら実行してください。
                ★ 実行環境で動作することを確認してから使ってくだ
                   さい。たとえば、Cx486DLC  +  MEMORY-SERVERIIの
                   cache onの状態ではハングアップしている様子です。

                ○ 参照:  cx486_read(), cx486_write(), get_cpu()

------------------------------------------------------------------------
□ cx486_read - Cx486キャッシュ制御情報の読み込み

C:      void cx486_read( struct Cx486CacheInfo * rec );

        ------------------------------------------98N 98H AT DOS-
        cx486_read
        -------------------------------------------<cx486rw.asm>-

                ● Cx486の現在のキャッシュ制御レジスタの内容を読
                   み取ります。

                ★ Cx486以外で実行してはいけません。  get_cpu()で
                   CPU_CYRIXのビットが立っていることを確認してか
                   ら実行してください。

                ○ 参照:  cx486_cacheoff(), cx486_write(),
                          get_cpu()

------------------------------------------------------------------------
□ cx486_write - Cx486キャッシュ制御情報の書き込み

C:      void cx486_write( const struct Cx486CacheInfo * rec );

        ------------------------------------------98N 98H AT DOS-
        cx486_write
        -------------------------------------------<cx486rw.asm>-

                ● Cx486のキャッシュ制御レジスタに書き込みます。

                ★ Cx486以外で実行してはいけません。  get_cpu()で
                   CPU_CYRIXのビットが立っていることを確認してか
                   ら実行してください。
                ★ Cx486DLC + MEMORY-SERVERIIのcache onの状態では
                   ハングアップしている様子です。ううむ。

                ○ 参照:  cx486_cacheoff(), cx486_read(),
                          get_cpu()

------------------------------------------------------------------------
□ get_cpu - CPUの判別

C:      unsigned get_cpu(void);

        ------------------------------------------98N 98H AT DOS-
        get_cpu
        --------------------------------------------<getcpu.asm>-

                ● CPUを判定します。
                   対応しているCPUは、以下の通りです。
                      8086, 80186, V30, V50, 80286, 80386,  i486,
                      Cx486, Pentium

                → cpuval
                   この値から、以下の情報が解ります。
                   ・メーカー
                   (cpuval & CPU_CYRIX) != 0    Cyrix Cx486など
                   (cpuval & CPU_NEC) != 0      NEC V30/V50
                   上記どちらも0                Intel製

                   ・種類
                   (cpuval & CPU_TYPEMASK) ==
                      CPU_TYPE086               8086
                      CPU_TYPE186               80186/V30/V50
                      CPU_TYPE286               80286
                      CPU_TYPE386               80386
                      CPU_TYPE486               i486/Cx486
                      CPU_TYPEPENTIUM           Pentium

                   ・モード
                   (cpuval & CPU_V86MODE) != 0  仮想86モード
                   0のとき                      仮想86以外

                ○ 参照:  cx486_cacheoff(), cx486_read(),
                          cx486_write()


------------------------------------------------------------------------
■ メモリ関係 ■■■■■■■■■■■■■■■■■■■■■■■■■■■■■


------------------------------------------------------------------------
■ メインメモリ関係 ■■■■■■■■■■■■■■■■■■■■■■■■■■

        　master.lib 0.14以降では、メインメモリ管理は DOS  から随
        時確保していく形ではなく、 最初に一回使用メモリ領域を割り
        当て、その中で割り当て、開放する形が主体となっています。
        　そして、これらの内部割り当てメモリ管理処理の中で、 まだ
        最初の割り当てがされていなかった時には自動的に DOS から最
        大のメモリを確保してしまいます。
        　このため、従来の  mem_alloc..などの関数の多くは使おうと
        するとメモリ不足になるので、hmem_*や smem_*に置き換えてく
        ださい。

        ● メモリの配置

          　smem_*は、 管理メモリブロックの先頭から順次後ろに向か
          って確保されます。
          　hmem_*は、 管理メモリブロックの末尾から順次先頭に向か
          って確保されます。
          　smem/hmem両者は完全に独立して自由に操作することができ
          ます。

          　しかし、 smemの中では必ず最初に確保したものが最後に開
          放される(最後に確保されたものから順に開放される)ように
          なっていなければなりません。

          　最後に確保されたsmem_*ブロックを拡大するには、 増分の
          大きさだけsmem_で確保するだけです。これがメモリ不足を返
          さなければ、拡大できたことになります。

          　smemもhmemも、 メモリブロックの大きさの単位は16バイト
          (1パラグラフ)です。また、hmemは、メモリブロック一つごと
          に管理構造体として16バイト消費します。

------------------------------------------------------------------------
□ 構造体／グローバル変数

unsigned mem_TopSeg;            管理メモリ領域の先頭セグメント-1
unsigned mem_OutSeg;            管理メモリ領域の末尾の次のセグメ
                                ント
unsigned mem_EndMark;           smem_*の確保ポインタ(末尾位置)
unsigned mem_TopHeap;           hmem_*で確保された最低位置-1
unsigned mem_FirstHole;         hmem_freeで開放された穴の最低位置
                                -1
unsigned mem_MyOwn;             0 なら mem_assign()  で割り当てら
                                れたことを、
                                1 なら
                                mem_assign_dos()/mem_assign_all()
                                で DOS から直接確保されたことを表
                                す。
unsigned mem_AllocID;           hmem_*で確保するときに用途を書き
                                込むための変数。hmem_alloc参照。

------------------------------------------------------------------------
□ 定数

        ● mem_AllocID および hmem_getid()で使用する値
        表記            値  用途
        MEMID_UNKNOWN    0  用途指定なし
        MEMID_FONT       1  font_*で確保
        MEMID_GAIJI      2  gaiji_*で確保
        MEMID_WFONT      3  wfont_*で確保
        MEMID_SUPER      4  super_*で確保
        MEMID_VVRAM      5  virtual_*で確保
        MEMID_BFILE      6  bopenなどで確保
        MEMID_PFILE      7  pfopenで確保
        MEMID_BGM        8  bgm_*で確保(bgm)
        MEMID_EFS        9  bgm_*で確保(efs)
        MEMID_PI        10  graph_pi_*で確保
        MEMID_MAG       11  mag_load_packで確保
        MEMID_TEXTBACK  12  text(vtext)_backupで確保
        MEMID_VTEXTX    13  vtextx_startで確保

------------------------------------------------------------------------
□ hmem_alloc - ヒープからのメモリ確保(16bit パラグラフ)

C:      unsigned hmem_alloc( unsigned parasize );

        ------------------------------------------98N 98H AT DOS-
        hmem_alloc                                           ５
        -------------------------------------------<memheap.asm>-

                ● パラグラフサイズを指定して通常のメモリを確保し
                   ます。
                   このメモリブロックは、確保した順と異なった順で
                   開放することができますので、長時間使用するメモ
                   リなどの確保に向いています。
                   開放には必ず hmem_free()を使用してください。

                → 0      管理メモリ領域が足りない
                   0以外  確保できたセグメントアドレス

                ○ この際、メモリブロックの管理情報に mem_AllocID
                   変数の内容を書き込み、そのあとmem_AllocIDを0に
                   します。
                ○ この関数を呼ぶ直前に mem_AllocIDに値を書き込む
                   と、後でメモリブロックから  hmem_getid()で識別
                   することができます。なお、この値は以下の定数が
                   予約されています。
                     MEMID_UNKNOWN, MEMID_FONT, MEMID_GAIJI,
                     MEMID_WFONT, MEMID_SUPER, MEMID_VVRAM,
                     MEMID_BFILE, MEMID_PFILE, MEMID_BGM,
                     MEMID_EFS, MEMID_PI, MEMID_MAG,
                     MEMID_TEXTBACK, MEMID_VTEXTX

                ○ 参照:  hmem_allocbyte(), hmem_free(),
                          hmem_getid(), hmem_getsize(),
                          hmem_lallocate(), hmem_maxfree(),
                          hmem_realloc(), hmem_reallocbyte(),
                          mem_assign()

------------------------------------------------------------------------
□ hmem_allocbyte - ヒープからのメモリ確保(16bit バイト)

C:      unsigned hmem_allocbyte( unsigned bytesize );

        ------------------------------------------98N 98H AT DOS-
        hmem_allocbyte                                       ５
        -------------------------------------------<memheap.asm>-

                ● バイト単位でサイズを指定して通常のメモリを確保
                   します。
                   このメモリブロックは、確保した順と異なった順で
                   開放することができますので、長時間使用するメモ
                   リなどの確保に向いています。
                   開放には必ず hmem_free()を使用してください。

                → 0      管理メモリ領域が足りない
                   0以外  確保できたセグメントアドレス

                ○ 参照:  hmem_alloc(), hmem_free(), hmem_getid(),
                          hmem_getsize(), hmem_lallocate(),
                          hmem_maxfree(), hmem_realloc(),
                          hmem_reallocbyte(), mem_assign()

------------------------------------------------------------------------
□ hmem_free - hmem_*で確保したメモリの開放

C:      void hmem_free( unsigned memseg );

        ------------------------------------------98N 98H AT DOS-
        hmem_free                                            ５
        -------------------------------------------<memheap.asm>-

                ● hmem_alloc, hmem_allocbyte, hmem_lallocate  の
                   いずれかで確保したメモリを開放します。

                ○ 参照:  hmem_alloc(), hmem_allocbyte(),
                          hmem_lallocate(), hmem_maxfree(),
                          hmem_realloc(), hmem_reallocbyte()

------------------------------------------------------------------------
□ hmem_getid - hmem_*で確保したブロックの用途を知る

C:      unsigned hmem_getid(unsigned mseg);                マクロ

        ------------------------------------------98N 98H AT DOS-
        hmem_getid
        -----------------------------------------------------<->-

                ● hmem_alloc, hmem_allocbyte, hmem_lallocate  の
                   いずれかで確保したメモリブロックのセグメント値
                   を指定して、そのブロックの用途を得ます。

                ← mseg  hmemメモリブロックのセグメント値

                → 用途  MEMID_UNKNOWN など(hmem_alloc() 参照)

                ★ hmemメモリブロックでない場所を指定すると、でた
                   らめな値が返ります。

                ○ 参照:  hmem_alloc(), hmem_allocbyte(),
                          hmem_getsize(), hmem_lallocate(),
                          hmem_realloc(), hmem_reallocbyte()

------------------------------------------------------------------------
□ hmem_getsize - hmem_*で確保したブロックの大きさを知る

C:      unsigned hmem_getsize(unsigned mseg);              マクロ

        ------------------------------------------98N 98H AT DOS-
        hmem_getsize
        -----------------------------------------------------<->-

                ● hmem_alloc, hmem_allocbyte, hmem_lallocate  の
                   いずれかで確保したメモリブロックのセグメント値
                   を指定して、そのブロックのパラグラフサイズを得
                   ます。

                ← mseg  hmemメモリブロックのセグメント値

                → パラグラフサイズ

                ★ hmemメモリブロックでない場所を指定すると、でた
                   らめな値が返ります。

                ○ 参照:  hmem_alloc(), hmem_allocbyte(),
                          hmem_getid(), hmem_lallocate(),
                          hmem_realloc(), hmem_reallocbyte()

------------------------------------------------------------------------
□ hmem_lallocate - ヒープからのメモリ確保(20bit バイト単位)

C:      unsigned hmem_lallocate( unsigned long bytesize );

        ------------------------------------------98N 98H AT DOS-
        hmem_lallocate                                       ５
        ------------------------------------------<memlaloc.asm>-

                ● バイト単位でサイズを指定して通常のメモリを確保
                   します。
                   このメモリブロックは、確保した順と異なった順で
                   開放することができますので、長時間使用するメモ
                   リなどの確保に向いています。
                   開放には必ず hmem_free()を使用してください。

                → 正数  得た先頭セグメント
                   0     管理メモリ領域が足りない

                ○ 参照:  hmem_alloc(), hmem_allocbyte(),
                          hmem_free(), hmem_getid(),
                          hmem_getsize(), hmem_maxfree(),
                          hmem_realloc(), hmem_reallocbyte(),
                          mem_assign()

------------------------------------------------------------------------
□ hmem_maxfree - hmem_*で確保可能な最大の大きさを知る

C:      unsigned hmem_maxfree(void);

        ------------------------------------------98N 98H AT DOS-
        hmem_maxfree
        ------------------------------------------<hmemmaxf.asm>-

                ● hmem_alloc, hmem_allocbyte, hmem_lallocate  で
                   現在確保可能な最大の空間の大きさを、パラグラフ
                   単位で得ます。

                → パラグラフサイズ

                ○ バイト単位にするには 16倍すればいいよん。 この
                   ときに 16bitを越えることがままあるので、long整
                   数で計算するようにしてね。

                ○ 参照:  hmem_alloc(), hmem_allocbyte(),
                          hmem_free(), hmem_lallocate(),
                          hmem_realloc(), hmem_reallocbyte()

------------------------------------------------------------------------
□ hmem_realloc - hmem_*で確保したブロックの大きさ変更(16bitパラグラフ)

C:      unsigned hmem_realloc( unsigned oseg, unsigned parasize );

        ------------------------------------------98N 98H AT DOS-
        hmem_realloc
        ------------------------------------------<hmemreal.asm>-

                ● hmem_alloc, hmem_allocbyte, hmem_lallocate  で
                   確保されたメモリブロックの大きさを変更します。

                ← oseg      hmemメモリブロック
                   parasize  新しい大きさ(パラグラフ単位)

                → 0      メモリ不足
                   0以外  成功。新しいメモリブロック

                ○ 新しい大きさが、現在の大きさと同じか小さくなる
                   場合は、メモリブロックのアドレスは変化せず、ま
                   た必ず成功します。
                ○ 大きくなる場合は、アドレスが移動する場合があり
                   ます。このとき、以前の内容はそのまま新しいアド
                   レスにコピーされます。後ろに増加した部分の内容
                   は不定です。

                ○ 参照:  hmem_alloc(), hmem_allocbyte(),
                          hmem_free(), hmem_getid(),
                          hmem_getsize(), hmem_lallocate(),
                          hmem_maxfree(), hmem_reallocbyte(),
                          mem_assign()

------------------------------------------------------------------------
□ hmem_reallocbyte - hmem_*で確保したブロックの大きさ変更(16bitバイト)

C:      unsigned hmem_reallocbyte( unsigned oseg, unsigned bytesize );

        ------------------------------------------98N 98H AT DOS-
        hmem_reallocbyte
        ------------------------------------------<hmemreal.asm>-

                ● hmem_alloc, hmem_allocbyte, hmem_lallocate  で
                   確保されたメモリブロックの大きさを変更します。

                ← oseg      hmemメモリブロック
                   bytesize  新しい大きさ(バイト単位)

                → 0      メモリ不足
                   0以外  成功。新しいメモリブロック

                ○ 新しい大きさが、現在の大きさと同じか小さくなる
                   場合は、メモリブロックのアドレスは変化せず、ま
                   た必ず成功します。
                ○ 大きくなる場合は、アドレスが移動する場合があり
                   ます。このとき、以前の内容はそのまま新しいアド
                   レスにコピーされます。後ろに増加した部分の内容
                   は不定です。

                ○ 参照:  hmem_alloc(), hmem_allocbyte(),
                          hmem_free(), hmem_getid(),
                          hmem_getsize(), hmem_lallocate(),
                          hmem_maxfree(), hmem_realloc(),
                          mem_assign()

------------------------------------------------------------------------
□ mem_allocate - DOSメインメモリを上位から確保する

C:      unsigned mem_allocate( unsigned para );

        ------------------------------------------98N 98H AT DOS-
        mem_allocate                                         ５
        ------------------------------------------<memalloc.asm>-

                ● DOSアロケーションストラテジを変更して、 最上位
                   からメモリを確保します。
                   アロケーションステラテジは実行前の値に復元しま
                   す。

                ← para  確保するパラグラフサイズ(1=16バイト)

                → 0      メモリ不足
                   0以外  確保したセグメントアドレス

                ○ 現在のDOSメモリから確保できる(空いている)最大
                   の大きさは、dos_maxfree()で得られます。

                ★ hmem_*やsmem_*を間接的にも全く使わないのでなけ
                   れば、あらかじめ mem_assign で DOSに空きメモリ
                   が存在するようにしておかなければ常に確保に失敗
                   します。

                ○ 参照:  mem_free(), mem_lallocate()

------------------------------------------------------------------------
□ mem_assign - 呼び出し側が割り当てたメモリを使用

C:      void mem_assign( unsigned top_seg, unsigned parasize );

        ------------------------------------------98N 98H AT DOS-
        mem_assign                                           ５
        ------------------------------------------<memassig.asm>-

                ● master.libの管理メモリ領域を割り当てます。
                   引数には先頭のセグメントアドレスと、そこから使
                   用可能なパラグラフサイズを指定してください。
                  　DOSから確保する場合は次のような手順になります。
                      const unsigned  parasize = 4096; /* 64Kバイ
                                      ト */
                      unsigned  mem = mem_allocate( parasize );
                      mem_assign( mem, parasize );

                    パラグラフサイズは、 バイト数を16で割った値が
                    入ります。
                  割り当てる際には、 できるだけ広い領域を割り当て
                  るようにしてください。 特に、最低 64Kバイトは確
                  保しておくのが無難です。
                  　なお、virtual_copy()関数のような、 大きなメモ
                  リ領域を必要とするものには、 以下のような表示し
                  ました。 利用する関数の合計必要量を上回るように
                  割り当ててください。
                      △MEMORY: 2000パラグラフのブロックを4個確保
                        します。

                    割り当てを解除するには、 mem_unassign()を使用
                    してください。

                ★ 各コンパイラの標準メモリ管理関数群と衝突しない
                   ような割り当てができます。以下のように行うこと
                   で安全にメモリをやりくりすることができるように
                   なります。

                  Microsoft Cの場合:
                      #include "malloc.h"
                         /* ポインタ正規化のずれを考慮して1つ大き
                         めに確保 */
                      void huge * mem = halloc( parasize + 1,  16
                      );
                      mem_assign( FP_REGULAR_SEG(mem), parasize );
                      ....
                      mem_unassign();
                      hfree( mem );

                  Borland C++ の場合
                      void far * mem = farmalloc( (parasize +  1)
                      * 16 );
                      mem_assign( FP_REGULAR_SEG(mem), parasize );
                      ....
                      mem_unassign();
                      farfree( mem );

                ○ 参照:  mem_assign_all(), mem_assign_dos(),
                          mem_unassign()

------------------------------------------------------------------------
□ mem_assign_all - DOSの最大空きメモリブロックを取得

C:      void mem_assign_all(void);

        ------------------------------------------98N 98H AT DOS-
        mem_assign_all                                       ５
        ------------------------------------------<memassig.asm>-

                ● 現在DOSから確保できる最大のメモリブロックを取
                   得し、それを管理領域として割り当てます。

                ○ 管理領域を DOS に開放するには、 mem_unassign()
                   を使用してください。

                ★ mem_assign* のいずれも実行せずにメモリを確保す
                   ると、自動的にこの関数が呼び出されます。

                ○ 参照:  mem_assign(), mem_assign_dos(),
                          mem_unassign()

------------------------------------------------------------------------
□ mem_assign_dos - 指定サイズのメモリブロックをDOSから取得

C:      int mem_assign_dos( unsigned parasize );

        ------------------------------------------98N 98H AT DOS-
        mem_assign_dos                                       ５
        ------------------------------------------<memasdos.asm>-

                ● DOS から parasize パラグラフサイズのメモリブロ
                   ックを取得し、それを管理領域として割り当てます。

                → NoError             成功
                   InsufficientMemory  DOSメモリ領域が足りない

                ○ 管理領域を DOS に開放するには、 mem_unassign()
                   を使用してください。

                ○ 参照:  mem_assign(), mem_assign_all(),
                          mem_unassign()

------------------------------------------------------------------------
□ mem_free - DOSメモリブロックの開放

C:      void mem_free( unsigned seg );

        ------------------------------------------98N 98H AT DOS-
        mem_free                                             ５
        -------------------------------------------<dosfree.asm>-

                ● DOSによって確保されているメモリブロックを開放
                   します。

                ← seg  DOSメモリブロックのセグメントアドレス

                ○ dos_free関数の別名です。

                ○ 参照:  dos_free(), mem_allocate(),
                          mem_lallocate()

------------------------------------------------------------------------
□ mem_lallocate - DOSメインメモリを上位から確保する(long版)

C:      unsigned mem_lallocate( unsigned long bytesize );

        ------------------------------------------98N 98H AT DOS-
        mem_lallocate                                        ５
        ------------------------------------------<memlaloc.asm>-

                ● DOSアロケーションストラテジを変更して、 最上位
                   からメモリを確保します。
                   アロケーションステラテジは実行前の値に復元しま
                   す。
                   　バイト数で大きさを指定してください。

                ← bytesize  確保するバイト数

                → 0      メモリ不足
                   0以外  確保したセグメントアドレス

                ○ 現在のDOSメモリから確保できる(空いている)最大
                   の大きさは、dos_maxfree()で得られます。

                ★ hmem_*やsmem_*を間接的にも全く使わないのでなけ
                   れば、あらかじめ mem_assign で DOSに空きメモリ
                   が存在するようにしておかなければ常に確保に失敗
                   します。

                ○ 参照:  mem_allocate(), mem_free()

------------------------------------------------------------------------
□ mem_unassign - 管理メモリ領域を放棄

C:      int mem_unassign(void);

        ------------------------------------------98N 98H AT DOS-
        mem_unassign                                         ５
        ------------------------------------------<memunasi.asm>-

                ● hmem_*, smem_*で確保されたブロックが一つも存在
                   しない(すべて開放されている)ときに、master.lib
                   の管理するメモリ領域を放棄します。

                → 0  失敗。 何か確保されたままのメモリブロックが
                      中に存在する。
                   1  成功。割り当ては放棄された。

                ○ これによって、mem_assign()で割り当てられたメモ
                   リを開放することができます。また、
                   mem_assign_dos(), mem_assign_all()のどちらかに
                   よってメモリが直接確保されていた場合は DOSにそ
                   のメモリを返します(開放します)。

                ★ 事前に、hmem_*, smem_*で確保されたものはすべて
                   開放してください。なお、パターンの開放は
                   super_free(), 仮想VRAMの開放は  virtual_free()
                   で行えます。
                ★ この関数の戻り値が「失敗」を表している場合は、
                   割り当ては放棄されていませんので注意してくださ
                   い。

                ○ 参照:  mem_assign(), mem_assign_all(),
                          mem_assign_dos()

------------------------------------------------------------------------
□ smem_lget - 高速メモリ確保(20bit)

C:      unsigned smem_lget( unsigned long bytesize );

        ------------------------------------------98N 98H AT DOS-
        smem_lget                                            ５
        ------------------------------------------<smemlget.asm>-

                ● 20bit整数で大きさを指定する一時的なメモリ確保。
                   現在の確保ポインタをサイズ分うしろにずらして、
                   ずらす前の確保ポインタの値(セグメント)を返しま
                   す。
                   必ず開放は smem_release()を使用してください。

                → 正数                  得た先頭セグメント
                   ※InsufficientMemory  管理メモリ領域が足りない

                   ※ 戻り値の型が unsigned なのに対し、
                      InsufficientMemory は負の数なので、比較する
                      際にはつぎのようなキャストが必要です。

                    seg = smem_wget( size );
                    if ( seg == (unsigned)InsufficientMemory ) {
                             /* ~~~~~~~~~~ */
                        dos_puts( "メモリないってば"CRLF );
                    }

                ○ 参照:  mem_assign(), smem_maxfree(),
                          smem_release(), smem_wget()

------------------------------------------------------------------------
□ smem_maxfree - smem_*で確保できる最大量を計算する

C:      int smem_maxfree(void);                            マクロ

        ------------------------------------------98N 98H AT DOS-
        smem_maxfree                                         ５
        -----------------------------------------------------<->-

                ● mem_TopHeap と mem_EndMark  の差を見ることによ
                   って smem_* で確保可能な最大値を得ます。

                → 最大確保可能量(パラグラフ単位)

                ○ 参照:  mem_assign(), smem_lget(),
                          smem_release(), smem_wget()

------------------------------------------------------------------------
□ smem_release - smem_*で確保したメモリの開放

C:      void smem_release( unsigned memseg );

        ------------------------------------------98N 98H AT DOS-
        smem_release                                         ５
        -------------------------------------------<smemrel.asm>-

                ● 一時的に確保したメモリを開放します。
                   単に確保ポインタの値を memseg に設定するだけで
                   す。
                   　この構造により、ほんの一瞬メモリを使いたいと
                   きに、高速に割り当てと開放ができるのですが、割
                   り当てたのと逆の順序で開放しないと、おかしな動
                   作をすることになります。(逆に、 最初に割り当て
                   たアドレスで開放するだけで、すべての開放ができ
                   ます)

                ○ 参照:  mem_assign(), smem_lget(),
                          smem_maxfree(), smem_wget()

------------------------------------------------------------------------
□ smem_wget - 高速メモリ確保(16bit)

C:      unsigned smem_wget( unsigned bytesize );

        ------------------------------------------98N 98H AT DOS-
        smem_wget                                            ５
        ------------------------------------------<smemwget.asm>-

                ● 16bit整数で大きさを指定する一時的なメモリ確保。
                   現在の確保ポインタをサイズ分うしろにずらして、
                   ずらす前の確保ポインタの値(セグメント)を返しま
                   す。
                   必ず開放は smem_release()を使用してください。

                → 正数                  得た先頭セグメント
                   ※InsufficientMemory  管理メモリ領域が足りない

                   ※ 戻り値の型が unsigned なのに対し、
                      InsufficientMemory は負の数なので、比較する
                      際にはつぎのようなキャストが必要です。

                    seg = smem_wget( size );
                    if ( seg == (unsigned)InsufficientMemory ) {
                             /* ~~~~~~~~~~ */
                        dos_puts( "メモリないってば"CRLF );
                    }

                ○ 参照:  mem_assign(), smem_lget(),
                          smem_maxfree(), smem_release()


------------------------------------------------------------------------
■ LIM EMS 4.0 操作 ■■■■■■■■■■■■■■■■■■■■■■■■■■

        ・LIM EMS 4.0が必要です。
        ・ここの関数群を実行する場合、まず最初に
                ems_exist
        　を実行して、存在する事を確認してから他の  ems_関数を呼
        んでください。

------------------------------------------------------------------------
□ 構造体／グローバル変数

        struct EMS_move_source_dest {
                long region_length;
                char source_memory_type;
                unsigned source_handle;
                unsigned source_initial_offset;
                unsigned source_initial_seg_page;
                char dest_memory_type;
                unsigned dest_handle;
                unsigned dest_initial_offset;
                unsigned dest_initial_seg_page;
        };

------------------------------------------------------------------------
□ ems_allocate - EMSメモリの確保

C:      unsigned ems_allocate( unsigned long len );

        ------------------------------------------98N 98H AT DOS-
        ems_allocate
        ------------------------------------------<emsalloc.asm>-

                ● EMSメモリを確保します。 大きさはバイト単位で指
                   定してください。
                   成功すれば、EMSハンドルを返します。
                   失敗した場合、0を返します。

------------------------------------------------------------------------
□ ems_dos_read - ファイルからEMSへの読込み

C:      long ems_dos_read(  int   file_handle,   unsigned   short
                          ems_handle,   unsigned  long  ems_offs,
                          long read_bytes );

        ------------------------------------------98N 98H AT DOS-
        ems_dos_read                                         ○
        ------------------------------------------<emsdosre.asm>-

                ● EMSの指定位置に、DOSのファイルハンドルからファ
                   イルの内容を読込みます。

                ← file_handle  オープンされたファイルハンドル
                   ems_handle   EMSのハンドル
                   ems_offs     EMSハンドル内のオフセットアドレス
                   read_bytes   転送するバイト数

                → -1L    エラー
                   0以上  転送したバイト数

                △MEMORY: 一時的に(smem) 16KBの転送バッファを確保
                  します。

------------------------------------------------------------------------
□ ems_dos_write - EMSからファイルへの書き込み

C:      long ems_dos_write( int file_handle,
                           unsigned short ems_handle, unsigned
                           long ems_offs, long write_bytes );

        ------------------------------------------98N 98H AT DOS-
        ems_dos_write                                        ○
        ------------------------------------------<emsdoswr.asm>-

                ● EMSの指定位置からの内容を  DOSのファイルに書き
                   込みます。

                ← file_handle  オープンされたファイルハンドル
                   ems_handle   EMSのハンドル
                   ems_offs     EMSハンドル内のオフセットアドレス
                   write_bytes  転送するバイト数

                → -1L    エラー
                   0以上  転送したバイト数

                △MEMORY: 一時的に(smem) 16KBの転送バッファを確保
                  します。

------------------------------------------------------------------------
□ ems_enablepageframe - NEC EMSページフレームバンクの操作

C:      void ems_enablepageframe( int enable );

        ------------------------------------------98N 98H AT DOS-
        ems_enablepageframe                        ○
        ------------------------------------------<emsenabl.asm>-

                ● NECのEMSドライバにのみ意味のある処理です。
                   NECのドライバは、一部のEMSファンクションを実行
                   するとグラフィック画面の一部(B0000h〜)の上にペ
                   ージフレームを開いてしまいますので、enable = 0
                   にしてこの処理を行ってください。
                ○ NEC の EMS ドライバ以外の場合、 実行しても何も
                   起こりません。

------------------------------------------------------------------------
□ ems_exist - EMSの存在検査

C:      int ems_exist(void);

        ------------------------------------------98N 98H AT DOS-
        ems_exist
        ------------------------------------------<emsexist.asm>-

                ● EMSドライバの存在を検査します。

                → 1 存在
                   0 不在

------------------------------------------------------------------------
□ ems_findname - 名前からEMSハンドルを探す

C:      unsigned ems_findname( const char * hname );

        ------------------------------------------98N 98H AT DOS-
        ems_findname
        ------------------------------------------<emsfindn.asm>-

                ● 指定した名前と同じ名前をもつEMSハンドルを検索
                   します。

                → 0    エラー
                   1〜  見つかったEMSハンドル

------------------------------------------------------------------------
□ ems_free - EMSメモリの開放

C:      int ems_free( unsigned handle );

        ------------------------------------------98N 98H AT DOS-
        ems_free
        -------------------------------------------<emsfree.asm>-

                ● ems_allocateで確保したメモリを開放します。
                   成功すれば 0 を返します。
                   失敗したら、EMS エラーコードを返します。

------------------------------------------------------------------------
□ ems_getsegment - EMS物理セグメント情報の取得

C:      int ems_getsegment( unsigned * segments, int maxframe );

        ------------------------------------------98N 98H AT DOS-
        ems_getsegment
        ------------------------------------------<emsgetsg.asm>-

                ● EMSの物理ページフレームのセグメントアドレスの
                   配列を得ます。
                   この結果、 segments[0]が物理ページフレーム番号
                   0 のセグメントアドレス、以下番号順にセグメント
                   アドレスが格納されます。このとき、セグメントは
                   昇順とは限りません。

                ← segments  セグメントの配列を格納する場所
                   maxframe  読み取れる最大数(= segmentsの大きさ)

                → 0      エラー
                   1〜64  物理ページフレームの数

                ★ この関数は、 内部でEMSドライバの呼び出し結果を
                   加工していますので、 全く同じ機能はEMSドライバ
                   には存在しません。

------------------------------------------------------------------------
□ ems_maphandlepage - EMSハンドルページのマップ

C:      int ems_maphandlepage( int  phys_page,  unsigned  handle,
                              unsigned log_page );

        ------------------------------------------98N 98H AT DOS-
        ems_maphandlepage
        ------------------------------------------<emsmaphp.asm>-

                ● EMS の物理ページフレームに、 EMSハンドルの特定
                   ページを割り当てます。

                ← phys_page  物理ページ番号(0〜)
                   handle     割り当てるEMSハンドル
                   log_page   EMSハンドルhandle内の論理ページ番号
                              (先頭=0, 以後16Kごとに1増加)

                → 0      成功
                   0以外  EMSエラーコード

------------------------------------------------------------------------
□ ems_movememoryregion - EMSメモリ領域の移動

C:      int ems_movememoryregion( const struct EMS_move_source_dest * block );

        ------------------------------------------98N 98H AT DOS-
        ems_movememoryregion
        -------------------------------------------<emsmove.asm>-

                ● EMSとメインメモリの間でデータを転送します。
                   詳しくは EMSの資料を読んでください。
                   なお、 このライブラリには、 ems_write,ems_read
                   という上位関数が用意されているので、通常はそち
                   らを利用してください。

                → 成功  0
                   失敗  EMS エラーコード

------------------------------------------------------------------------
□ ems_read - EMSメモリを読む

C:      int ems_read( unsigned handle, long offset,
                     void far * mem, long size );

        ------------------------------------------98N 98H AT DOS-
        ems_read
        -------------------------------------------<emsread.asm>-

                ● EMSメモリからデータを読み込みます。
                   ems_movememoryregion と  ems_enablepageframeを
                   呼び出しています。

                ← handle  EMSハンドル
                   offset  そのハンドルが差すEMSメモリの先頭から
                           のオフセット
                   mem     格納先メモリ
                   size    転送するバイト数

                → 成功  0
                   失敗  EMS エラーコード

------------------------------------------------------------------------
□ ems_reallocate - EMSメモリの再確保

C:      int ems_reallocate( unsigned handle, unsigned long size );

        ------------------------------------------98N 98H AT DOS-
        ems_reallocate
        ------------------------------------------<emsrealc.asm>-

                ● EMSのハンドルの大きさを変更します。

                ← handle 大きさを変更するEMSハンドル
                   size   新しい大きさ(バイト数)

                → 0      成功
                   0以外  EMSエラーコード

------------------------------------------------------------------------
□ ems_restorepagemap - EMSページマップの復元

C:      int ems_restorepagemap( unsigned handle );

        ------------------------------------------98N 98H AT DOS-
        ems_restorepagemap
        ------------------------------------------<emsrestm.asm>-

                ● handleに待避した  EMSの最初の4つの物理ページフ
                   レームのマップ状態を復元します。

                → 0      成功
                   0以外  EMSエラーコード

------------------------------------------------------------------------
□ ems_savepagemap - EMSページマップの待避

C:      int ems_savepagemap( unsigned handle );

        ------------------------------------------98N 98H AT DOS-
        ems_savepagemap
        ------------------------------------------<emssavem.asm>-

                ● EMSの最初の4つの物理ページフレームのマップ状態
                   を、handleの待避領域に待避します。
                   ひとつのハンドルに対して２重待避はできません。

                → 0      成功
                   0以外  EMSエラーコード

------------------------------------------------------------------------
□ ems_setname - EMSハンドルに名前を設定する

C:      int ems_setname( unsigned handle, const char * name );

        ------------------------------------------98N 98H AT DOS-
        ems_setname
        ------------------------------------------<emssetnm.asm>-

                ● すでに確保されたメモリに、名前を付けます。名前
                   は必ず 8文字にしてください。
                   そして、 余った場合は  '\0'(キャラクタコード0)
                   で埋めてください。
                   成功すれば、0を返します。
                   失敗したら EMS エラーコードを返します。
                   すでに同じ名前がある場合にはエラーとなります。

------------------------------------------------------------------------
□ ems_size - EMSハンドルの大きさを得る

C:      unsigned long ems_size( unsigned handle );

        ------------------------------------------98N 98H AT DOS-
        ems_size
        -------------------------------------------<emssize.asm>-

                ● EMSハンドルの大きさをバイト数で得ます。

                → バイト数, 0ならエラー

------------------------------------------------------------------------
□ ems_space - EMSの空きバイト数を得る

C:      unsigned long ems_space(void);

        ------------------------------------------98N 98H AT DOS-
        ems_space
        ------------------------------------------<emsspace.asm>-

                ● EMSの空きメモリの合計量をバイト数で得ます。

                → バイト数, 0ならエラー

------------------------------------------------------------------------
□ ems_write - EMSメモリに書き込む

C:      int ems_write( unsigned handle, long offset,
                      const void far * mem, long size );

        ------------------------------------------98N 98H AT DOS-
        ems_write
        ------------------------------------------<emswrite.asm>-

                ● EMSメモリにメインメモリのデータを書き込みます。
                   ems_movememoryregion と  ems_enablepageframeを
                   呼び出しています。

                ← handle  EMSハンドル
                   offset  そのハンドルが差すEMSメモリの先頭から
                           のオフセット
                   mem     書き込むデータの先頭アドレス
                   size    転送するバイト数

                → 成功  0
                   失敗  EMS エラーコード


------------------------------------------------------------------------
■ XMS操作 ■■■■■■■■■■■■■■■■■■■■■■■■■■■■■■

        　XMS規格のメモリ管理ドライバ (HIMEM.SYSや MEMORY-SERVER,
        QEMM386など)を利用して、EMB領域(1MB以上のメモリ領域、プロ
        トテクトメモリなどとも呼ばれます)に一時的な作業用メモリを
        確保し、読み書きします。
        　これらの関数を使う場合、必ず xms_exist を実行してくださ
        い。これによって、実行の準備を行います。

------------------------------------------------------------------------
□ xms_allocate - EMBの確保

C:      unsigned xms_allocate( long memsize );

        ------------------------------------------98N 98H AT DOS-
        xms_allocate                                         ○
        ------------------------------------------<xmsalloc.asm>-

                ● EMBにメモリを確保します。
                   リアルモードでは、 アプリケーションが直接EMBに
                   アクセスすることはできませんので、
                   xms_movememoryなどを利用して転送することになり
                   ます。

                → 0      確保失敗
                   0以外  EMBハンドル

------------------------------------------------------------------------
□ xms_exist - XMSの存在確認と使用開始

C:      int xms_exist(void);

        ------------------------------------------98N 98H AT DOS-
        xms_exist                                            ○
        ------------------------------------------<xmsexist.asm>-

                ● XMSドライバの存在を確認し、 存在する場合は制御
                   関数のアドレスを内部に記憶します。

                → 1  XMSドライバがある
                   0  XMSドライバがない

------------------------------------------------------------------------
□ xms_free - EMBの開放

C:      void xms_free( unsigned handle );

        ------------------------------------------98N 98H AT DOS-
        xms_free                                             ○
        -------------------------------------------<xmsfree.asm>-

                ● xms_allocate()で確保した EMB上のメモリを開放し
                   ます。

------------------------------------------------------------------------
□ xms_maxfree - EMBの最大フリーブロックの大きさを得る

C:      unsigned long xms_maxfree(void);

        ------------------------------------------98N 98H AT DOS-
        xms_maxfree                                          ○
        ------------------------------------------<xmsmaxfr.asm>-

                ● XMSのEMB内の最大未使用ブロックの大きさを得ます。

                → バイト数 (0=エラー)

------------------------------------------------------------------------
□ xms_movememory - EMB−メインメモリ間の転送

C:      int xms_movememory( long destOff, unsigned destHandle,
                           long srcOff, unsigned srcHandle, long Length );

        ------------------------------------------98N 98H AT DOS-
        xms_movememory                                       ○
        -------------------------------------------<xmsmove.asm>-

                ● 確保されたEMBメモリと、 メインメモリの間でブロ
                   ック転送を行います。

                ← destOff      destHandle = 0の場合、 メインメモ
                                リ内の書き込み先へのfarポインタ。
                                0以外の場合、 EMBのメモリブロック
                                内の書き込み先オフセットアドレス。
                   destHandle   0 = 転送先はメインメモリ
                                0以外 = 転送先はEMB
                   srcOff       srcHandle = 0の場合、メインメモリ
                                内の転送元へのfarポインタ。
                                0以外の場合、 EMBのメモリブロック
                                内の転送元オフセットアドレス。
                   srcHandle    0 = 転送元はメインメモリ
                                0以外 = 転送元はEMB
                   Length       転送するバイト数

                → 1  成功
                   0  失敗

------------------------------------------------------------------------
□ xms_reallocate - EMBの再確保

C:      unsigned xms_reallocate( unsigned handle, unsigned long newsize );

        ------------------------------------------98N 98H AT DOS-
        xms_reallocate                                       ○
        ------------------------------------------<xmsrealc.asm>-

                ● XMSのEMBに確保されたメモリブロックの大きさを変
                   更します。

                → 1  成功
                   0  失敗

------------------------------------------------------------------------
□ xms_size - EMBハンドルの大きさを得る

C:      unsigned long xms_size( unsigned handle );

        ------------------------------------------98N 98H AT DOS-
        xms_size                                             ○
        -------------------------------------------<xmssize.asm>-

                ● XMSのEMB領域に確保されたメモリブロックの大きさ
                   を得ます。

                ← handle  XMSのEMBハンドル

                → バイト数 (0=エラー)

------------------------------------------------------------------------
□ xms_space - EMBの残り総バイト数を得る

C:      unsigned long xms_space(void);

        ------------------------------------------98N 98H AT DOS-
        xms_space                                            ○
        ------------------------------------------<xmsspace.asm>-

                ● XMSのEMB内の未使用領域の合計バイト数を得ます。

                → バイト数 (0=エラー)


------------------------------------------------------------------------
■ 常駐データ ■■■■■■■■■■■■■■■■■■■■■■■■■■■■■

        　常駐パレットなどのように、 メインメモリ内にデータを放置
        し、一時的にデータを他のアプリと共有するための処理をDOS汎
        用で用意しました。
        　DOSの普通のメモリブロックとして管理するので、他のメモリ
        ブロックを誤ってアクセスしないように、 検索条件を厳しくし
        てあります。
        ・識別文字列、識別文字列の長さ
          メモリブロックの先頭から、 識別文字列の長さのバイト数だ
          け、完全に識別文字列と一致すること。
        ・パラグラフサイズ
          メモリブロックの大きさが指定したパラグラフサイズと完全
          に一致すること。
        たとえば、簡単な常駐データを作る場合、 構造体を作ると便利
        です。
        static char ID[] = "TestResData";
        #define IDLen (sizeof(ID)-1)
        #define Para  BYTE2PARA(sizeof(struct TestResData))
        struct TestResData {
          char id[TestResDataIDLen];
          int data;
        } ;

        ・データの作成、書き換え
        struct TestResData far * rd;
        unsigned seg = resdata_create(ID, Len, Para);
        if ( seg ) {
            rd = (struct TestResData far *)FP2SEG(seg);
            rd->data = 5 ;      /* 格納したいデータ */
        } else { 失敗 }

        ・データの読み込み
        struct TestResData far * rd;
        unsigned seg = resdata_exist(ID, Len, Para);
        if ( seg ) {
            rd = (struct TestResData far *)FP2SEG(seg);
            return rd->data ; /* などなど */
        } else { 失敗 }

        ・データの開放
        unsigned seg = resdata_exist(ID, Len, Para);
        if ( seg ) {
            resdata_free(seg);
        }

------------------------------------------------------------------------
□ resdata_create - 常駐データの作成

C:      unsigned resdata_create( const char * id, unsigned idlen,
                                unsigned parasize );

        ------------------------------------------98N 98H AT DOS-
        resdata_create                                       ○
        -------------------------------------------<resdata.asm>-

                ● 常駐データを作成します。内容は、識別文字列だけ
                   書き込み、残りは不定です。すでに存在した場合、
                   見つかったアドレスを返します。

                ← id        識別文字列
                   idlen     識別文字列の長さ
                   parasize  メモリブロックのパラグラフサイズ

                → 0      指定のパラグラフサイズのメモリブロック
                          が作成できない
                   0以外  作成した、 あるいは見つかった先頭セグメ
                          ントアドレス。

------------------------------------------------------------------------
□ resdata_exist - 常駐データの検索

C:      unsigned resdata_exist( const char * id, unsigned  idlen,
                               unsigned parasize );

        ------------------------------------------98N 98H AT DOS-
        resdata_exist                                        ○
        -------------------------------------------<resdata.asm>-

                ● 常駐データを検索し、そのセグメント位置を返しま
                   す。

                ← id        識別文字列
                   idlen     識別文字列の長さ
                   parasize  メモリブロックのパラグラフサイズ

                → 0      見つからなかった
                   0以外  見つかった。先頭アドレス。

------------------------------------------------------------------------
□ resdata_free - 常駐データの開放

C:      void resdata_free( unsigned seg );                 マクロ

        ------------------------------------------98N 98H AT DOS-
        resdata_free                                         ○
        -----------------------------------------------------<->-

                ● 常駐データを開放します。

                ← seg  セグメントアドレス

                ○ dos_freeを呼び出しているだけです。


------------------------------------------------------------------------
■ 文字、文字列処理 ■■■■■■■■■■■■■■■■■■■■■■■■■■

        　文字コードや、文字列に関する処理です。ここにある関数は、
        一般的に 8086系CPUであれば動作します。

------------------------------------------------------------------------
□ jis_to_sjis - JISコードをシフトJISに変換

C:      unsigned jis_to_sjis( unsigned jis );

        ------------------------------------------98N 98H AT DOS-
        jis_to_sjis                                          ○
        ------------------------------------------<jis2sjis.asm>-

                ● JIS全角文字コードをシフトJIS全角に変換します。

                ★ JIS全角文字コードでない値で呼ばれた場合、 結果
                   は不定です。

                ○ 参照:  sjis_to_jis

------------------------------------------------------------------------
□ sjis_to_jis - シフトJISコードをJISに変換

C:      unsigned sjis_to_jis( unsigned sjis );

        ------------------------------------------98N 98H AT DOS-
        sjis_to_jis                                          ○
        ------------------------------------------<sjis2jis.asm>-

                ● シフトJIS全角文字コードをJIS全角に変換します。

                ★ シフトJIS全角文字コードでない値で呼ばれた場合、
                   結果は不定です。

                ○ 参照:  jis_to_sjis

------------------------------------------------------------------------
□ str_comma - 整数のカンマ付き文字列化

C:      int str_comma( char * buf, long val, unsigned buflen );

        ------------------------------------------98N 98H AT DOS-
        str_comma
        ------------------------------------------<strcomma.asm>-

                ● 符号付きの整数を、３桁毎にカンマをつけて右詰め
                   で指定文字数の文字列にします。負数ならば最上位
                   の桁の左に'-'が付きます。

                ← buf     文字列の格納先
                   val     文字列にしたい数値
                   buflen  格納文字数+1 (末尾の'\0'を含めたバイト
                           数)

                → 1    成功
                   0    失敗(格納先の桁数が足りない)

------------------------------------------------------------------------
□ str_ctopas - C文字列をパスカル文字列に書き換える

C:      char * str_ctopas( char * PascalString, const char * CString );

        ------------------------------------------98N 98H AT DOS-
        str_ctopas
        -------------------------------------------<ptocstr.asm>-

                ● C言語形式の文字列へのポインタを渡すと、 その文
                   字列をパスカル形式に変換します。
                   返値は PascalString になります。
                   CString と PascalString を一致させることもでき
                   ます。

                ○ 参照:  str_pastoc

------------------------------------------------------------------------
□ str_iskanji2 - 文字列の指定位置の漢字2バイト目判定

C:      int str_iskanji2( const char * str, int n );

        ------------------------------------------98N 98H AT DOS-
        str_iskanji2
        ------------------------------------------<striskj2.asm>-

                ● 文字列の中の nバイト目が、 漢字の2バイト目かど
                   うかを調べます。

                ← str  文字列の先頭
                   n    判定する位置(0=先頭)

                → 1  漢字2バイト目
                   0  以外

                ○ Microsoft C, Borland C++などの  nthctypeに似て
                   いますが、漢字2バイト目かどうかだけ判定します。
                ○ コンパイラ依存を減らすために作成されています。

------------------------------------------------------------------------
□ str_pastoc - パスカル文字列をC文字列に書き換える

C:      char * str_pastoc( char * CString, const char * PascalString );

        ------------------------------------------98N 98H AT DOS-
        str_pastoc
        -------------------------------------------<ptocstr.asm>-

                ● パスカル文字列へのポインタを渡すと、その文字列
                   をC言語形式の文字列に変換します。
                   返値は CString になります。
                   CString と PascalString を一致させることもでき
                   ます。

                ○ 参照:  str_ctopas

------------------------------------------------------------------------
□ str_printf - sprintfの簡易版

C:      void str_printf( char * buf, const char * format, ... );

        ------------------------------------------98N 98H AT DOS-
        str_printf
        ------------------------------------------<strprntf.asm>-

                ● C言語stdio.hの sprintfの簡略・縮小版です。
                   書式(format)には、次のものだけが使えます。
                        %<文字数>s  文字列
                        %<桁>u      符号なし整数
                        %<桁>X      符号なし16進数
                        %<桁>b      符号なし2進数
                        %c          文字
                        %%          %自身
                    　%で始めて、上記以外の文字で終った場合は  %u
                    の扱いになります。
                    　<文字数>は、 左詰めの最小文字数を表します。
                    余った分は空白で埋めます。
                    　%sは masters.lib,masterm.lib は near ポイン
                    タのみ、masterc.lib,masterl.lib   はfarポイン
                    タのみになります。
                    　<桁>は右詰めで、省略するとなにも書きません。
                    0で始めると左に余った桁は0で埋め、0以外で始め
                    ると空白で埋めます。また、数字の最後に 'l'(小
                    文字のL)をつけると long型の値をとります。
                    　%x(小文字のx)を指定すると、%X(大文字)の処理
                    をします。


------------------------------------------------------------------------
■ ディスク・ファイル関連 ■■■■■■■■■■■■■■■■■■■■■■■


------------------------------------------------------------------------
■ MS-DOS 単純ファイル操作 ■■■■■■■■■■■■■■■■■■■■■■

        　同時オープン数を 1 に制限した、バッファリングを行うファ
        イルアクセスルーチン集です。
        　フィルタなどのように、 同時に複数オープンする必要がある
        用途には使えませんが、 単独データファイルの読み書きなどの
        用途のために作成しました。

        　デフォルトでは、 バッファリングは機能しないようになって
        いますので、 DOS を直接よぶのと変わらず、小さな単位でアク
        セスすると低速です。しかし、file_assign_buffer() を利用し
        てバッファを指定すると、 そこを作業バッファにしてディスク
        アクセスの回数を減らし、 高速なファイル処理を狙うことがで
        きます。
        　このメリットを生かすためには、 文字単位でのアクセスをで
        きるだけ避け、 file_skip_until() などのような特殊機能関数
        を呼び出すようにしてください。
        　また、バッファリングを行うと、CON,AUX  などのリアルタイ
        ム性が要求されるデバイスでの出力に問題がでますので、 注意
        してください。

        　さらに、アクセスは「バイナリモード」 に相当するモードし
        かありません。 つまり、改行コードを変換しないので、改行を
        読み込むと、'\r' '\n'と連続して２バイト現れ、書き込む時も
        この順でかかなくてはいけません。

        　と、このような制限がありますが、単純で小さいので、 実行
        形式のサイズを気にする場合に使ってみてください。
        　また、バッファが大きくでき、常にFARメモリを使うので、ス
        モールモデルでFARメモリを扱う場合や、大きなファイルを一気
        に読み書きする場合に高速に処理できます。

------------------------------------------------------------------------
□ 構造体／グローバル変数

void far * file_Buffer;         アクセスバッファ
unsigned file_BufferSize;       アクセスバッファの大きさ
unsigned long file_BufferPos;   バッファ先頭のファイル内位置
int file_sharingmode ;          読み込みオープン時の共有モード

        以下の変数は直接参照・変更しないで下さい。

unsigned file_BufPtr;
unsigned file_InReadBuf;
int file_Eof;
int file_ErrorStat;
int file_Handle;

------------------------------------------------------------------------
□ file_append - ファイルの追加・読み書きオープン

C:      int file_append( const char * filename );

        ------------------------------------------98N 98H AT DOS-
        file_append                                          ５
        ------------------------------------------<filapend.asm>-

                ● 既存ファイルをオープンし、最終バイトの次にseek
                   します。ファイルが存在しない場合は失敗します。
                   読み書きをともに行う場合、読み書きの間の切り替
                   えにはfile_seekを実行する必要があります。(バッ
                   ファリングを行っていない場合はこれは実行しなく
                   ても問題ありません)

                → 1  成功
                   0  失敗

------------------------------------------------------------------------
□ file_assign_buffer - 作業バッファの割り当て

C:      void file_assign_buffer(void far * buf,unsigned siz);  マ
        クロ

        ------------------------------------------98N 98H AT DOS-
        file_assign_buffer                                   ○
        -----------------------------------------------------<->-

                ● ファイルアクセスの作業バッファを割り当てます。
                   file_*を使用する前に実行する必要があります。
                   　使用者が何らかの手段で確保したバッファ用メモ
                   リの先頭アドレスを bufに、バイト数をsiz に指定
                   して下さい。
                   　siz は大きいほど実際のファイルへのアクセスの
                   回数が少なくなります。

                ★ 作業バッファは、file_*系関数が内部ワークとして
                   利用するための領域です。この領域を直接読み書き
                   した場合、結果は予測できません。

                ★ バッファの割り当ての解除について:
                        　割り当てたバッファを解除するには、sizを
                        0にして呼び出して下さい。ただし、これはフ
                        ァイルがオープンされたままの状態で実行す
                        ると誤動作するので注意して下さい。

------------------------------------------------------------------------
□ file_basename - ファイル名部分を見つける

C:      char * file_basename( char * pathname );

        ------------------------------------------98N 98H AT DOS-
        file_basename                                        ５
        ------------------------------------------<filbasnm.asm>-

                ● パス名の中から、最後の要素を見つけ出します。
                   　file_basename( "A:\abc\表" ) は、 渡された文
                   字列の中の"表"のアドレスを返します。
                   　:,\,/のどれも無い場合は文字列をそのまま返し、
                   これらの文字で終っている場合は、末尾のヌル文字
                   を差します。
                   　ファイルアクセスとは独立しているので、すでに
                   file_ropenなどが行われていても動作します。

------------------------------------------------------------------------
□ file_close - ファイルを閉じる

C:      void file_close(void);

        ------------------------------------------98N 98H AT DOS-
        file_close                                           ５
        ------------------------------------------<filclose.asm>-

                ● 開かれたファイルを閉じます。
                   すでに書き込みまたは読み込みオープンされている
                   必要があります。
                   書き込みエラーの判定は、file_error()で行ってく
                   ださい。

------------------------------------------------------------------------
□ file_create - ファイルの作成・書き込みオープン

C:      int file_create( const char * filename );

        ------------------------------------------98N 98H AT DOS-
        file_create                                          ５
        ------------------------------------------<filcreat.asm>-

                ● ファイルを新規に作成し、オープンします。

                → 1  成功
                   0  失敗

------------------------------------------------------------------------
□ file_delete - ファイルの削除

C:      int file_delete( const char * filename );

        ------------------------------------------98N 98H AT DOS-
        file_delete                                          ５
        ------------------------------------------<fildelet.asm>-

                ● ファイルを削除します。
                   ファイルアクセスとは独立しているので、  すでに
                   file_ropenなどが行われていても動作します。

                → 1  成功
                   0  失敗

------------------------------------------------------------------------
□ file_eof - ファイル末尾を読み込んだかどうか

C:      int file_eof(void);                                マクロ

        ------------------------------------------98N 98H AT DOS-
        file_eof                                             ５
        -----------------------------------------------------<->-

                ● すでに読み込みが末尾に達しているかどうかを判定
                   します。

                → 1  読み込みが末尾(EOF)に達している
                   0  まだ読める

------------------------------------------------------------------------
□ file_error - 書き込みエラーの有無

C:      int file_error(void);                              マクロ

        ------------------------------------------98N 98H AT DOS-
        file_error                                           ５
        -----------------------------------------------------<->-

                ● 書き込みによってエラーが発生した後ならば、
                   1(true)を返します。
                   オープンしたあとまだ発生していないなら、 0を返
                   します。
                   　書き込みオープンされたときにのみクリアされま
                   す。つまりクローズしても読むことができます。

------------------------------------------------------------------------
□ file_exist - ファイルの存在検査

C:      int file_exist( const char * filename );

        ------------------------------------------98N 98H AT DOS-
        file_exist                                           ５
        ------------------------------------------<filexist.asm>-

                ● ファイルの存在を検査します。
                   ファイルアクセスとは独立しているので、  すでに
                   file_ropenなどが行われていても動作します。

                → 1  存在
                   0  不在,エラー

------------------------------------------------------------------------
□ file_flush - 作業バッファのフラッシュ

C:      void file_flush(void);

        ------------------------------------------98N 98H AT DOS-
        file_flush                                           ５
        ------------------------------------------<filclose.asm>-

                ● 開かれたファイルの作業バッファをフラッシュしま
                   す。
                   　すなわち、読み込みオープンされていた場合は作
                   業バッファを空にし、書き込みオープンされていた
                   場合は、作業バッファの内容を実際に書き込み、や
                   はり空にします。

                   　書き込みエラーの判定は、file_error()で行って
                   ください。

------------------------------------------------------------------------
□ file_getc - ファイルからの1バイト読み込み

C:      int file_getc(void);

        ------------------------------------------98N 98H AT DOS-
        file_getc                                            ５
        -------------------------------------------<filgetc.asm>-

                ● ファイルから、1 バイト読み込みます。
                   すでに読み込みオープンされている必要があります。

                → 0〜255  読み込んだ値
                   -1      すでにEOFに達している

------------------------------------------------------------------------
□ file_gets - 指定文字またはサイズまで読み込む

C:      unsigned file_gets( void far * buf, unsigned bsize, int endchar );

        ------------------------------------------98N 98H AT DOS-
        file_gets                                            ５
        -------------------------------------------<filgets.asm>-

                ● ファイルから、指定データが見つかるか、指定バイ
                   ト数(bsize - 1)に達するまで bufに読み込みます。
                   buf = 0 ならば、読み込まずに捨てます。

                   すでに読み込みオープンされている必要があります。

                → 読み込んだ文字数

                ★ file_assign_buffer()の実行が前もって必要です。
                   (そうでなければ異常動作します)

------------------------------------------------------------------------
□ file_getw - ファイルからの1ワード読み込み

C:      int file_getw(void);

        ------------------------------------------98N 98H AT DOS-
        file_getw                                            ５
        ----------------------------------------------<filw.asm>-

                ● ファイルから、下位、上位の順に２バイト読み込み、
                   16bit整数に組み上げます。
                   EOF時には値がくずれますので、  EOF確認には必ず
                   file_eofを用いてください。
                   すでに読み込みオープンされている必要があります。

                → 読み込んだ2バイトの値

------------------------------------------------------------------------
□ file_lread - ファイルの読み込み(long版)

C:      unsigned long file_lread( void far * buf, unsigned long wsize );

        ------------------------------------------98N 98H AT DOS-
        file_lread                                           ５
        ------------------------------------------<fillread.asm>-

                ● ファイルから、bufにwsizeバイト読み込みます。
                   すでに読み込みオープンされている必要があります。
                   64Kバイトを超えていても動作します。

                → 読み込んだバイト数(0〜wsize)

------------------------------------------------------------------------
□ file_lsettime - ファイルの最終更新時刻を変更する(long版)

C:      int file_lsettime( unsigned long filetime );

        ------------------------------------------98N 98H AT DOS-
        file_lsettime                                        ５
        ------------------------------------------<filsettm.asm>-

                ● 現在読み込みオープンされているファイルの最終更
                   新時刻を変更します。

                ← filetime  file_time()の戻り値と同じ形式の、 上
                             位16bit=日付、下位16bit=時刻の値

                → 1  成功(実際にはクローズ時に変更されます)
                   0  ファイルが開かれていない

------------------------------------------------------------------------
□ file_lwrite - ファイルの書き込み(long版)

C:      int file_lwrite( const void far * buf, unsigned long wsize );

        ------------------------------------------98N 98H AT DOS-
        file_lwrite                                          ５
        ------------------------------------------<fillwrit.asm>-

                ● ファイルにbufからwsizeバイトの内容を書き込みま
                   す。
                   すでに書き込みオープンされている必要があります。
                   wsizeは64Kバイトを超えていても動作します。

                → 1  成功
                   0  失敗

------------------------------------------------------------------------
□ file_putc - ファイルへの1バイト書き込み

C:      void file_putc( int chr );

        ------------------------------------------98N 98H AT DOS-
        file_putc                                            ５
        -------------------------------------------<filputc.asm>-

                ● ファイルに1バイト書き込みます。
                   すでに書き込みオープンされている必要があります。
                   (要file_assign_buffer())

------------------------------------------------------------------------
□ file_putw - ファイルへの1ワード書き込み

C:      void file_putw( int i );

        ------------------------------------------98N 98H AT DOS-
        file_putw                                            ５
        ----------------------------------------------<filw.asm>-

                ● ファイルに下位バイト、上位バイトの順に書き込み
                   ます。
                   すでに書き込みオープンされている必要があります。

------------------------------------------------------------------------
□ file_read - ファイルの読み込み

C:      int file_read( void far * buf, unsigned wsize );

        ------------------------------------------98N 98H AT DOS-
        file_read                                            ５
        -------------------------------------------<filread.asm>-

                ● ファイルから、bufにwsizeバイト読み込みます。
                   すでに読み込みオープンされている必要があります。

                → 読み込んだバイト数(0〜wsize)

------------------------------------------------------------------------
□ file_ropen - ファイルの読み込みオープン

C:      int file_ropen( const char * filename );

        ------------------------------------------98N 98H AT DOS-
        file_ropen                                           ５
        ------------------------------------------<filropen.asm>-

                ● ファイルを読み込みの為にオープンします。

                → 0以外  成功
                   0      失敗

                ★ CON などのキャラクタデバイスを開いても正常に読
                   み込むことはできません。

------------------------------------------------------------------------
□ file_seek - ファイルポインタの移動

C:      void file_seek( long pos, int dir );

        ------------------------------------------98N 98H AT DOS-
        file_seek                                            ５
        -------------------------------------------<filseek.asm>-

                ● 作業バッファをフラッシュ(file_flush)し、ファイ
                   ルポインタを変更します。

                ← pos 基準点からの移動量
                   dir 0: 基準点=ファイル先頭
                       1: 基準点=現在のファイルポインタ
                       2: 基準点=ファイル末尾

                   　書き込みオープンされていた場合、フラッシュが
                   失敗している可能性もあります。この場合は
                   file_error()で判定してください。

------------------------------------------------------------------------
□ file_settime - ファイルの最終更新時刻を変更する

C:      int file_settime(unsigned date,unsigned time);

        ------------------------------------------98N 98H AT DOS-
        file_settime                                         ５
        ------------------------------------------<filsettm.asm>-

                ● 現在読み込みオープンされているファイルの最終更
                   新時刻を変更します。

                ← date 日付(MS-DOSファイル時刻形式)
                   time 時刻(〃)

                → 1  成功(実際にはクローズ時に変更されます)
                   0  ファイルが開かれていない

------------------------------------------------------------------------
□ file_size - ファイルの大きさを得る

C:      long file_size(void);

        ------------------------------------------98N 98H AT DOS-
        file_size                                            ５
        -------------------------------------------<filsize.asm>-

                ● 現在読み込みオープンされているファイルの大きさ
                   を得ます。

                → -1    ファイルが開かれていない
                   以外  ファイルの大きさ

------------------------------------------------------------------------
□ file_skip_until - 指定文字まで読み捨てる

C:      void file_skip_until( int data );

        ------------------------------------------98N 98H AT DOS-
        file_skip_until                                      ５
        ------------------------------------------<filskipu.asm>-

                ● ファイルの中を、指定データと同じバイトまで読み
                   捨てます。(見つかったバイトは読み捨てられます)
                   すでに読み込みオープンされている必要があります。

------------------------------------------------------------------------
□ file_splitpath, file_splitpath_slash - パス名を構成要素に分解

C:      void file_splitpath(  const  char   *path,   char   *drv,
                            char *dir, char *name, char *ext ) ;
C:      void file_splitpath_slash(   char   *path,   char   *drv,
                                  char *dir, char   *name,   char
                                  *ext ) ;

        ------------------------------------------98N 98H AT DOS-
        file_splitpath
        ------------------------------------------<filsplit.asm>-
        file_splitpath_slash
        ------------------------------------------<filsplsl.asm>-

                ● パス名を分解し、ドライブ名、ディレクトリパス、
                   ファイル名、 拡張子の4つの要素を切り出します。
                   ただの文字列処理ですので、実際にディレクトリ検
                   査などはせず、name,extはその文字列の最後の要素
                   がつかわれます。

                ← path   切り分け元のパス名
                   drv    "A:"の書き込み先(3バイト)
                   dir    "\dir\"の書き込み先(pathの長さ)
                   name   "filename"の書き込み先(9バイト)
                   ext    ".ext"の書き込み先(6バイト)

                ○ drv,dir,name,extは、NULLを指定するとそれぞれ省
                   略できます。
                ○ file_splitpath は、最後の要素が"."で始まってい
                   る場合、nameに格納します。
                ○ file_splitpath_slash は、pathの内容の  '\'  を
                   '/'に置換してから同じ作業を行います。 また、最
                   後の要素が"."で始まっている場合、extに格納しま
                   す。

------------------------------------------------------------------------
□ file_tell - ファイルポインタの読み取り

C:      unsigned long file_tell(void);

        ------------------------------------------98N 98H AT DOS-
        file_tell                                            ５
        -------------------------------------------<filseek.asm>-

                ● ファイルポインタの現在位置を読み取ります。
                   0 はファイル先頭です。

------------------------------------------------------------------------
□ file_time - ファイルの最終更新時刻を得る

C:      unsigned long file_time(void);

        ------------------------------------------98N 98H AT DOS-
        file_time                                            ５
        -------------------------------------------<filtime.asm>-

                ● 現在読み込みオープンされているファイルの最終更
                   新時刻を得ます。

                → 0      ファイルが開かれていない
                   0以外  上位16bit:日付, 下位16bit:時刻(MS-DOSフ
                          ァイル時刻形式)

------------------------------------------------------------------------
□ file_write - ファイルの書き込み

C:      int file_write( const void far * buf, unsigned wsize );

        ------------------------------------------98N 98H AT DOS-
        file_write                                           ５
        ------------------------------------------<filwrite.asm>-

                ● ファイルにbufからwsizeバイトの内容を書き込みま
                   す。
                   すでに書き込みオープンされている必要があります。

                → 1  成功
                   0  失敗


------------------------------------------------------------------------
■ pf.lib バッファされたファイルアクセス ■■■■■■■■■■■■■■■

        　file_openなどと異なり、複数のファイルを同時にオープンで
        きる、バッファされたファイルアクセス関数群です。

        　関数はリード系とライト系に分かれています。 リード系とラ
        イト系の関数は別系統のものなので、 必ず、bopenr()したファ
        イルはリード系の、 bopenw()したファイルはライト系の関数を
        使ってください。チェックはしていません。

    リード系 : bopenr(), bcloser(), bgetc(), bread(), bseek(),
               bseek_()

    ライト系 : bopenw(), bclosew(), bputc(), bputw(), bputs(),
               bwrite(), bflush()

        　アクセスは file_系と同様に、「バイナリモード」 に相当す
        るモードしかありません。 つまり、改行コードを変換しないの
        で、改行を読み込むと、'\r' '\n'と連続して２バイト現れ、書
        き込む時もこの順でかかなくてはいけません。

------------------------------------------------------------------------
□ 構造体／グローバル変数

unsigned bbufsiz;       bopenr(), bopenw()でバッファを
                        hmem_allocbyte()するときのサイズ。 初期値
                        はBBUFSIZ(==512)。 bsetbufsiz()で変更でき
                        る。

------------------------------------------------------------------------
□ bcloser - ファイルの読み込みクローズ

C:      void bcloser(bf_t hbf);

        ------------------------------------------98N 98H AT DOS-
        bcloser                                              ○
        -------------------------------------------<bcloser.asm>-

                ● bopenr()でオープンしたファイルをクローズします。
                   bopenr()で確保した領域を開放するので、必ず呼ん
                   でください。

------------------------------------------------------------------------
□ bclosew - ファイルの書き込みクローズ

C:      void bclosew(bf_t hbf);

        ------------------------------------------98N 98H AT DOS-
        bclosew                                              ○
        -------------------------------------------<bclosew.asm>-

                ● bopenw()でオープンしたファイルをクローズします。
                   バッファに残っているデータをファイルに書き出し、
                   bopenw()で確保した領域を開放しているので、必ず
                   呼んでください。

------------------------------------------------------------------------
□ bdopen - ファイルハンドルからの再オープン

C:      bf_t bdopen(int dos_handle);

        ------------------------------------------98N 98H AT DOS-
        bdopen                                               ○
        --------------------------------------------<bdopen.asm>-

                ● DOSファイルハンドルに、バッファを割り当て、
                   bf_tハンドルを作成します。

                ← dos_handle  MS-DOSのファイルハンドル。
                               dos_ropenなどの値が使えます。
                → 0      エラー。pferrno  にエラー種別が設定され
                          る。

                ○ これ自体はリード形、ライト系のどちらも兼ねます
                   が、dos_handle  のオープン時に指定されたモード
                   に合わせて使ってください。なお、読み書き両用に
                   は対応していません。

------------------------------------------------------------------------
□ bflush - 書き込みファイルバッファのフラッシュ

C:      int bflush(bf_t hbf);

        ------------------------------------------98N 98H AT DOS-
        bflush                                               ○
        --------------------------------------------<bflush.asm>-

                ● バッファにたまっているデータを書き出します。

------------------------------------------------------------------------
□ bgetc - ファイルからの1バイト読み込み

C:      int bgetc(bf_t hbf);

        ------------------------------------------98N 98H AT DOS-
        bgetc                                                ○
        ---------------------------------------------<bgetc.asm>-

                ● ファイルから 1文字読み込んで返します。ファイル
                   の終わりに達しているときは -1 を返します。

------------------------------------------------------------------------
□ bopenr - ファイルの読み込みオープン

C:      bf_t bopenr(const char *file);

        ------------------------------------------98N 98H AT DOS-
        bopenr                                               ○
        --------------------------------------------<bopenr.asm>-

                ● ファイル fileを読込み用にオープンします。
                   hmem_allocbyte()によって確保した管理構造体への
                   セグメントアドレスを返します。何らかの理由でオ
                   ープンできなかったときは 0を返します。

                → 0      エラー。pferrno  にエラー種別が設定され
                          る。

                △MEMORY: (8+bbufsiz)バイトのメモリブロックを確保
                  します。

------------------------------------------------------------------------
□ bopenw - ファイルの書き込みオープン

C:      bf_t bopenw(const char *fname);

        ------------------------------------------98N 98H AT DOS-
        bopenw                                               ○
        --------------------------------------------<bopenw.asm>-

                ● ファイル fileを書込み用にオープンします。
                   hmem_allocbyte()によって確保した管理構造体への
                   セグメントアドレスを返します。何らかの理由でオ
                   ープンできなかったときは 0を返します。

                → 0      エラー。pferrno  にエラー種別が設定され
                          る。

------------------------------------------------------------------------
□ bputc - ファイルへの1バイト書き込み

C:      int bputc(int c, bf_t hbf);

        ------------------------------------------98N 98H AT DOS-
        bputc                                                ○
        ---------------------------------------------<bputc.asm>-

                ● 文字 c を出力します。通常は文字 c を返しますが、
                   エラーがあった場合には -1 を返します。

------------------------------------------------------------------------
□ bputs - ファイルへの文字列書き込み

C:      int bputs(const char *s, bf_t hbf);

        ------------------------------------------98N 98H AT DOS-
        bputs                                                ○
        ---------------------------------------------<bputs.asm>-

                ● 文字列 s を出力します。 成功すると文字列の長さ
                   を、エラーがあると -1 を返します。

------------------------------------------------------------------------
□ bputw - ファイルへの2バイト整数書き込み

C:      int bputw(int w, bf_t hbf);

        ------------------------------------------98N 98H AT DOS-
        bputw                                                ○
        ---------------------------------------------<bputw.asm>-

                ● 整数 c を出力します。通常は整数 w を返します。
                   エラーがあった場合には -1 を返すが、w に  -1を
                   指定した場合はエラーでなくても  -1が返るので注
                   意(区別する手段はありません)。

------------------------------------------------------------------------
□ bread - ファイルからの読み込み

C:      int bread(void *buf, int size, bf_t hbf);

        ------------------------------------------98N 98H AT DOS-
        bread                                                ○
        ---------------------------------------------<bread.asm>-

                ● ファイルから bufで指定された領域に  sizeバイト
                   読み込みます。実際に読み込んだバイト数を返しま
                   す。

------------------------------------------------------------------------
□ bseek - ファイルからの読み込み位置を進める

C:      int bseek(bf_t hbf, long offset);

        ------------------------------------------98N 98H AT DOS-
        bseek                                                ○
        ---------------------------------------------<bseek.asm>-

                ● ファイルの読込み位置を  offsetバイト進めます。
                   通常は 0、エラーがあった場合は -1 を返します。

------------------------------------------------------------------------
□ bseek_ - ファイルからの読み込み位置の移動

C:      int bseek_(bf_t bf,long offset,int whence);

        ------------------------------------------98N 98H AT DOS-
        bseek_                                               ○
        --------------------------------------------<bseek_.asm>-

                ● ファイルの読込み位置を移動します。

                ← offset 基準点からの移動量
                   whence 0:  基準点=ファイル先頭
                          1:  基準点=現在のファイルポインタ
                          2:  基準点=ファイル末尾

                → 通常は 0、エラーがあった場合は -1 を返します。

------------------------------------------------------------------------
□ bsetbufsiz - 次回オープン時のファイルバッファの大きさの指定

C:      unsigned bsetbufsiz(unsigned bufsiz);              マクロ

        ------------------------------------------98N 98H AT DOS-
        bsetbufsiz                                           ○
        -----------------------------------------------------<->-

                ● bopenr(), bopenw()内では、ファイルアクセス用の
                   バッファを  hmem_allocbyte()で確保しています。
                   このバッファのサイズは何も指定しなければ
                   BBUFSIZ(==512バイト)ですが、この関数で事前に変
                   更できます。(参照→グローバル変数 bbufsiz)

------------------------------------------------------------------------
□ bwrite - ファイルへの書き込み

C:      int bwrite(const void *buf, int size, bf_t hbf);

        ------------------------------------------98N 98H AT DOS-
        bwrite                                               ○
        --------------------------------------------<bwrite.asm>-

                ● bufが指す sizeバイトのデータを出力します。実際
                   に出力したバイト数を返します。


------------------------------------------------------------------------
■ pf.lib parファイルアクセス ■■■■■■■■■■■■■■■■■■■■■

        　par.exeで作成した  par形式のパックファイル(parファイル)
        を、その構造を意識せずに読みだすための関数群です。
        　parファイルをアクセスする各関数は、 C標準ライブラリ関数
        に似せてあり、すべての関数名は"pf"で始まります。C標準ライ
        ブラリ関数が FILE構造体へのポインタを受渡しするのと同様に、
        本ライブラリ関数は pf_t ハンドルを用います。

        ●オートマチックモード
        　pfstart() から pfend() の間の処理は、ごく普通にカレント
        ディレクトリのファイルを読むように、parファイル内のファイ
        ルを読み込むことができます。
        　このため、 固定データファイルを沢山必要とするプログラム
        は、プログラムはこの2関数を呼ぶ行を追加するだけで、
        par.exe によってひとつのparファイルにまとめることができま
        す。
        　この機能は、書き込みオープン時には無効です。
        　seekは、offset値が負であるときはかならず失敗します。
        　同時に複数のファイルを開くことはできません。

------------------------------------------------------------------------
□ 構造体／グローバル変数

unsigned char pfkey;    　暗号化されているファイルをアクセスする
                        ときに、この変数が復号化キーとなる。
                        pfopen()をコールする前に利用者が設定して
                        おく。 暗号化されていないファイルをアクセ
                        スするときは設定不要。

enum pferr pferrno;     　pf.lib内で検出したエラーの種類がセット
                        される。 返却値ではエラーの有無しか分から
                        ないが、 この変数を読むことで詳細を知るこ
                        とができる。 エラーを検出していない場合の
                        値は不定。 pfopen(),  bopenr(), bopenw(),
                        bdopen() でセットされる。

------------------------------------------------------------------------
□ 定数

        ● pferrnoに格納される値
        表記            値   意味
        PFENOTOPEN        1  ファイルをオープンできない
        PFENOTFOUND       2  ファイルが parファイル中にない
        PFENOMEM          3  メモリを確保できない
        PFEUNKOWN         5  未知のファイルタイプ
        PFEILPFILE        6  ファイルが par形式でない
        PFEILEXE          7  EXEファイルが不正
        PFEINTERNAL     255  内部エラー

------------------------------------------------------------------------
□ pfcloser - parファイルのクローズ

C:      void pfcloser(pf_t hpf);

        ------------------------------------------98N 98H AT DOS-
        pfcloser                                             ○
        -------------------------------------------<pfclose.asm>-

                ● pfopen()でオープンしたファイルをクローズします。
                   pfopen()で確保された領域を開放しているので、必
                   ず呼んでください。

------------------------------------------------------------------------
□ pfend - pfオートマチックモード終了

C:      void pfend(void);

        ------------------------------------------98N 98H AT DOS-
        pfend                                                ○
        -------------------------------------------<pfint21.asm>-


                ● オートマチックモードを終了します。

                ○ 参照:  pfstart()

------------------------------------------------------------------------
□ pfgetc - parファイルから1文字読み込みます

C:      int pfgetc(pf_t hpf);

        ------------------------------------------98N 98H AT DOS-
        pfgetc                                               ○
        --------------------------------------------<pfgetc.asm>-

                ● ファイルから 1文字読み込んで返します。ファイル
                   の終わりに達しているときは -1を返します。

------------------------------------------------------------------------
□ pfgetw - parファイルから2バイト整数を読み込む

C:      int pfgetw(pf_t hpf);

        ------------------------------------------98N 98H AT DOS-
        pfgetw                                               ○
        --------------------------------------------<pfgetw.asm>-

                ● ファイルから 2バイト整数を読み込んで返します。
                   エラーは判別できません。

------------------------------------------------------------------------
□ pfopen - parファイルのオープン

C:      pf_t pfopen(const char *parfile, const char *file);

        ------------------------------------------98N 98H AT DOS-
        pfopen                                               ○
        --------------------------------------------<pfopen.asm>-

                ● parファイル中にパックされているファイルを読込
                   み用にオープンします。
                   　管理構造体を hmem_allocbyteで確保し、 そのセ
                   グメントアドレスを返します。

                ← parfile   parファイル名
                   file      parファイル内の読みたいファイル名

                → 0      エラー。pferrno  にエラー種別が設定され
                          る。
                   0以外  成功。この値は以後の  pf*()で使用するこ
                          と。

                ○ 暗号化されているファイルをオープンするときは、
                   この関数を使う前に、グローバル変数 pfkeyに暗号
                   キーを設定しておいてください。

                △MEMORY: 32バイトの管理構造体を確保します。また、
                  内部で bopenr を呼び出しているので、 そこでさら
                  にメモリが確保されます。

------------------------------------------------------------------------
□ pfread - parファイルからの読み込み

C:      unsigned pfread(void far *buf, unsigned size, pf_t hpf);

        ------------------------------------------98N 98H AT DOS-
        pfread                                               ○
        --------------------------------------------<pfread.asm>-

                ● ファイルから bufで指定された領域に  sizeバイト
                   読み込みます。実際に読み込んだバイト数を返しま
                   す。

------------------------------------------------------------------------
□ pfrewind - parファイルの読み込み位置を先頭に戻す

C:      void pfrewind(pf_t pf);

        ------------------------------------------98N 98H AT DOS-
        pfrewind                                             ○
        ------------------------------------------<pfrewind.asm>-

                ● ファイルの読込み位置を先頭に戻します。

------------------------------------------------------------------------
□ pfseek - parファイルの読み込み位置を進める

C:      unsigned long pfseek(pf_t hpf, unsigned offset);

        ------------------------------------------98N 98H AT DOS-
        pfseek                                               ○
        --------------------------------------------<pfseek.asm>-

                ● ファイルの読み込み位置を offsetバイト進めます。

                → 実行後の読み込み位置

                ★ この関数は、ファイル先頭に向かって戻ることはで
                   きません。戻るためには、pfrewind()を併用してく
                   ださい。

------------------------------------------------------------------------
□ pfstart - pfオートマチックモード開始

C:      void pfstart(const char *parfile);

        ------------------------------------------98N 98H AT DOS-
        pfstart                                              ○
        -------------------------------------------<pfint21.asm>-

                ● parファイル  parfileを対象としてオートマチック
                   モードを開始します。

                ★ プログラム終了までに必ず pfend()  を実行してく
                   ださい。実行しないと暴走します。
                ○ オートマチックモードについては pf_auto.txt  を
                   参照してください。

                ○ 参照:  pfend()

------------------------------------------------------------------------
□ pftell - parファイルの読み込み位置を得る

C:      unsigned long pftell(pf_t pf);                     マクロ

        ------------------------------------------98N 98H AT DOS-
        pftell                                               ○
        -----------------------------------------------------<->-

                ● ファイルの現在の読込み位置を得ます。


------------------------------------------------------------------------
■ MS-DOS一般 ■■■■■■■■■■■■■■■■■■■■■■■■■■■■■

        MS-DOS のファンクションコールを呼び出す関数群です。
        MS-DOSの知識があると便利です。

------------------------------------------------------------------------
□ 構造体／グローバル変数


struct find_many_t {            dos_findmanyで格納されるレコード
    unsigned long time;         ファイルのタイムスタンプ(DOS形式)
    unsigned long size;         ファイルの大きさ
    char name[13];              ファイル名
    char attribute;             ファイル属性
};

------------------------------------------------------------------------
□ dos_absread - セクタ指定によるディスク読み込み

C:      void dos_absread( int drive, void far *buf, int pow, long sector );

        ------------------------------------------98N 98H AT DOS-
        dos_absread                                          ５
        ------------------------------------------<dosabsre.asm>-

                ● INT 25Hを呼び出します。

------------------------------------------------------------------------
□ dos_abswrite - セクタ指定によるディスク書き込み

C:      void dos_abswrite( int drive, void far *buf, int pow, long sector );

        ------------------------------------------98N 98H AT DOS-
        dos_abswrite                                         ５
        ------------------------------------------<dosabswr.asm>-

                ● INT 26Hを呼び出します。

------------------------------------------------------------------------
□ dos_allocate - メモリブロックの確保

C:      unsigned dos_allocate( unsigned para );

        ------------------------------------------98N 98H AT DOS-
        dos_allocate                                         ５
        ------------------------------------------<dosalloc.asm>-

                ● MS-DOSからメインメモリを確保します。

                ← para  確保するパラグラフサイズ(1=16バイト)

                → 0      メモリ不足
                   0以外  確保したセグメントアドレス

------------------------------------------------------------------------
□ dos_axdx - 文字列を渡してMS-DOSを呼ぶ

C:      long dos_axdx( int axval, const char * strval );

        ------------------------------------------98N 98H AT DOS-
        dos_axdx                                             ○
        -----------------------------------------<dosc/dosp.asm>-

                ● 文字列を渡して MS-DOS ファンクションコールを実
                   行します。

                ← axval   AXに入れる値
                   strval  DS:DXに入れる文字列

                → 0以上  下位16bit=実行後のAXの値
                   負数   エラー( super.libエラーコード )

------------------------------------------------------------------------
□ dos_chdir - カレントディレクトリの設定

C:      int dos_chdir( const char * path );

        ------------------------------------------98N 98H AT DOS-
        dos_chdir                                            ５
        ------------------------------------------<doschdir.asm>-

                ● カレントディレクトリを変更します。

                → 1  成功
                   0  失敗

------------------------------------------------------------------------
□ dos_close - ファイルを閉じる

C:      int dos_close( int fh );

        ------------------------------------------98N 98H AT DOS-
        dos_close                                            ５
        ------------------------------------------<fntclose.asm>-

                ● ファイルを閉じます。

                ← fh    ファイルハンドル

                → NoError      成功
                   InvalidData  ハンドルが無効

                ★ Symantec C++  6.1Jにある同名関数を呼ぶときは、
                   (dos_close)(fh);などのように、関数名を括弧で括
                   ってください。

------------------------------------------------------------------------
□ dos_copy - ファイルのコピー

C:      int dos_copy( int src_fd, int dest_fd, unsigned long copy_len );

        ------------------------------------------98N 98H AT DOS-
        dos_copy                                             ５
        -------------------------------------------<doscopy.asm>-

                ● ファイルの一部分または残り全てをコピーします。

                ← src_fd    コピー元ハンドル
                   dest_fd   コピー先ハンドル
                   copy_len  コピーしたい長さ。
                             COPY_ALL(0xffffffffL) ならば EOFまで。

                → NoError         成功
                   GeneralFailure  src_fd の長さが copy_len  に満
                                   たない
                   GeneralFailure  dest_fd が完全に書き込めなかっ
                                   た(ディスク不足?)
                   InsufficientMemory  メモリ不足
                   AccessDenied    どちらかの fd がアクセス拒否
                   InvalidHandle   どちらかの fd が無効

------------------------------------------------------------------------
□ dos_cputp - 高速なコンソールパスカル文字列出力

C:      void dos_cputp( const char * passtr );

        ------------------------------------------98N 98H AT DOS-
        dos_cputp                                            ５
        ------------------------------------------<doscputp.asm>-

                ● int 29hを用いて文字列を表示します。
                   MS-DOSのバージョン変更によって使えなくなる可能
                   性があります。(DOS5ではOK)

                ★ リダイレクトは効きません。

------------------------------------------------------------------------
□ dos_cputs - 高速なコンソール文字列出力

C:      void dos_cputs( const char * string );

        ------------------------------------------98N 98H AT DOS-
        dos_cputs                                            ５
        ------------------------------------------<doscputs.asm>-

                ● int 29hを用いて文字列を表示します。
                   MS-DOSのバージョン変更によって使えなくなる可能
                   性があります。(DOS5ではOK)

                ★ リダイレクトは効きません。

------------------------------------------------------------------------
□ dos_cputs2 - 改行文字変換付きコンソール文字列出力

C:      void dos_cputs2( const char * str );

        ------------------------------------------98N 98H AT DOS-
        dos_cputs2                                           ５
        ------------------------------------------<doscpts2.asm>-

                ● int 29hを用いて文字列を表示します。
                   MS-DOSのバージョン変更によって使えなくなる可能
                   性があります。(DOS5ではOK)
                   "\n"を、"\r\n"に変換して出力します。 (MSC/TCな
                   どのテキストと同じ)

                ★ リダイレクトは効きません。

------------------------------------------------------------------------
□ dos_create - ファイルの作成

C:      int dos_create( const char * filename, int attribute );

        ------------------------------------------98N 98H AT DOS-
        dos_create                                           ５
        ------------------------------------------<doscreat.asm>-

                ● ファイルを作成し、オープンします。

                ← filename   作成するパス名
                   attribute  属性。通常は 0x20

                → 0以上             成功,ファイルハンドル
                   PathNotFound      失敗,パスが無効
                   TooManyOpenFiles  失敗,オープンファイルが多す
                                     ぎる
                   AccessDenied      失敗,属性が無効

------------------------------------------------------------------------
□ dos_filesize - ファイルサイズの取得

C:      long dos_filesize( int fh );

        ------------------------------------------98N 98H AT DOS-
        dos_filesize                                         ５
        ------------------------------------------<dosfsize.asm>-

                ● ファイルハンドルの表すファイルの大きさを得ます。

                ← fh  ファイルハンドル

                → InvalidHandle  ハンドルが無効
                   以外           ファイルの大きさ

------------------------------------------------------------------------
□ dos_findfirst - 最初に一致するファイルの検索

C:      int dos_findfirst( const char far * path, int attribute );

        ------------------------------------------98N 98H AT DOS-
        dos_findfirst                                        ５
        -------------------------------------------<dosfind.asm>-

                ● ファイルを検索し、dos_setdta()で設定したアドレ
                   スに検索結果を書き込みます。

                ← path       検索するパス(ワイルドカードを含む)
                   attribute  許可属性

                → 1  存在
                   0  不在またはエラー

------------------------------------------------------------------------
□ dos_findmany - 一度に複数のファイル検索

C:      unsigned dos_findmany( const char far * path,
                              int attribute, struct   find_many_t
                              far * buffer, unsigned max_dir );

        ------------------------------------------98N 98H AT DOS-
        dos_findmany                                         ○
        ------------------------------------------<dosfindm.asm>-

                ● 最大数を指定してファイル名を検索し、配列に格納
                   します。

                ← path       検索パス名
                   attribute  検索属性
                   buffer     格納先(配列)
                   max_dir    最大個数, 1以上。  0は1に補正して実
                              行されます。

                → 1以上  bufferに書き込んだ個数
                   0      存在しないか、エラー

------------------------------------------------------------------------
□ dos_findnext - 次に一致するファイルの検索

C:      int dos_findnext(void);

        ------------------------------------------98N 98H AT DOS-
        dos_findnext                                         ５
        -------------------------------------------<dosfind.asm>-

                ● dos_findfirst()の続きを一つ検索します。

                → 1  存在
                   0  もう無い

------------------------------------------------------------------------
□ dos_free - メモリブロックの開放

C:      void dos_free( unsigned seg );

        ------------------------------------------98N 98H AT DOS-
        dos_free                                             ５
        -------------------------------------------<dosfree.asm>-

                ● DOSによって確保されているメモリブロックを開放
                   します。

                ← seg  DOSメモリブロックのセグメントアドレス

                ○ mem_free関数の別名です。

                ★ Symantec C++  6.1Jにある同名関数を呼ぶときは、
                   (dos_free)(seg);などのように、関数名を括弧で括
                   ってください。

------------------------------------------------------------------------
□ dos_get_argv0 - 起動パス名を得る

C:      void dos_get_argv0( char * argv0 );

        ------------------------------------------98N 98H AT DOS-
        dos_get_argv0                                        ○
        ------------------------------------------<dosargv0.asm>-

                ● プログラムの起動パス名を得ます。main()が呼ばれ
                   るときの引数、argv[0]に得られるものと同じです。

                ← argv0  格納先。長さは256バイト程度確保されてい
                          ること。

                ★ DOS 3.X以降でなければ argv[0] = '\0'  となりま
                   す。

------------------------------------------------------------------------
□ dos_getch - ^Cで止まらない文字入力

C:      int dos_getch(void);

        ------------------------------------------98N 98H AT DOS-
        dos_getch                                            ５
        ------------------------------------------<dosgetch.asm>-

                ● 標準入力から文字を読みます。
                   MS-DOSの BREAK OFFが行われていれば、^Cチェック
                   がされません。
                   入力がなければ、入力があるまで待ちます。

------------------------------------------------------------------------
□ dos_getcwd - カレントディレクトリの読み出し

C:      int dos_getcwd( int drive, char * buf );

        ------------------------------------------98N 98H AT DOS-
        dos_getcwd                                           ５
        ------------------------------------------<dosgetcw.asm>-

                ● 指定ドライブのカレントディレクトリ文字列を得ま
                   す。
                   ドライブは、0 = カレントディレクトリ、
                   1 = A: ... という対応になっています。
                   'a'や'A'でもA:を指定できます。
                   bufに、"A:\ABC\DEF"の形で書き込まれます。
                   bufのサイズは、DOS3.xの場合 68バイト, DOS5.xの
                   場合 132バイト必要です。

                → 1  成功
                   0  失敗

------------------------------------------------------------------------
□ dos_getdiskfree - ディスクの残り容量の読み出し

C:      long dos_getdiskfree( int drive );

        ------------------------------------------98N 98H AT DOS-
        dos_getdiskfree                                      ５
        ------------------------------------------<dosgdfre.asm>-

                ● ディスクの残り容量をバイト数で得ます。
                   ドライブは、
                   0 = カレントディレクトリ
                   1 = A: ... という対応になっています。
                   'a'や'A'でもA:を指定できます。

                → -1   失敗
                   0〜  残りバイト数

                ★ この関数のみ、目的のドライブが存在しない場合も
                   直接失敗します。画面にDOSのメッセージ(中止
                   (A)...のような)が出ません。このため、 メディア
                   存在検査にも使えるようになっています。

------------------------------------------------------------------------
□ dos_getdrive - カレントドライブを得る

C:      int dos_getdrive(void);

        ------------------------------------------98N 98H AT DOS-
        dos_getdrive                                         ５
        ------------------------------------------<dosgetdr.asm>-

                ● カレントドライブ番号を得ます。

                → 0 = A:
                   1 = B:
                   ...

                ★ Symantec C++  6.1Jにある同名関数を呼ぶときは、
                   (dos_getdrive)(&d);などのように、 関数名を括弧
                   で括ってください。

------------------------------------------------------------------------
□ dos_get_driveinfo - ディスク容量を得る

C:      int dos_get_driveinfo(  int  drive,  unsigned   *cluster,
                              unsigned *sector, unsigned *bytes );

        ------------------------------------------98N 98H AT DOS-
        dos_get_driveinfo                                    ５
        ------------------------------------------<dosdrive.asm>-

                ● ディスクの容量に関するデータを得ます。

                ← drive    (0=カレント, 1=A: ...  'a'や'A'でもA:
                            として指定できます)
                   cluster  ドライブのクラスタ数
                   sector   1クラスタあたりのセクタ数
                   bytes    1セクタあたりのバイト数

                → 0    成功
                   -1   ドライブの指定が無効

------------------------------------------------------------------------
□ dos_getenv - 環境変数を得る

C:      const char far * dos_getenv( unsigned envseg, char * envname );

        ------------------------------------------98N 98H AT DOS-
        dos_getenv                                           ５
        ------------------------------------------<dosgetev.asm>-

                ● 環境変数の値を直接得ます。

                ← envseg   環境変数領域の先頭セグメントアドレス
                            (0ならば現在のプロセスの環境変数)
                   envname  環境変数名

                → 環境変数の内容の先頭アドレス(C言語文字列)
                   または 0 (見つからない)

                ★ これで得られるのは実際の環境変数の値の先頭アド
                   レスであり、書き換えると危険です。

------------------------------------------------------------------------
□ dos_getkey - 入力を待たない文字入力

C:      int dos_getkey(void);

        ------------------------------------------98N 98H AT DOS-
        dos_getkey                                           ５
        ------------------------------------------<dosgetky.asm>-

                ● 標準入力から文字を読みます。
                   MS-DOSの BREAK OFFが行われていれば、^Cチェック
                   がされません。
                   CTRL+@と入力なしの区別ができません。

                → 1〜255  入力された文字
                   0       入力なし

------------------------------------------------------------------------
□ dos_getkey2 - 入力を待たない文字入力(2)

C:      int dos_getkey2(void);

        ------------------------------------------98N 98H AT DOS-
        dos_getkey2                                          ５
        ------------------------------------------<dosgetk2.asm>-

                ● 標準入力から文字を読みます。
                   MS-DOSの BREAK OFFが行われていれば、^Cチェック
                   がされません。
                   CTRL+@と入力なしの区別ができます。

                → 0〜255  入力された文字
                   -1      入力なし

------------------------------------------------------------------------
□ dos_gets - 文字列の入力(編集なし)

C:      int dos_gets( char *buffer, int max );

        ------------------------------------------98N 98H AT DOS-
        dos_gets                                             ５
        -------------------------------------------<dosgets.asm>-

                ● DOSのバッファドキーボード入力を実行します。

                ← buffer  バッファの先頭アドレス。バッファは次の
                           構造です。
                     buffer[0] ダミー
                     buffer[1] 入力結果の文字数が入る。呼び出し時
                               点ではダミー。
                     buffer[2〜2+max-1]  入力結果が入る。  末尾は
                               '\r'である点に注意。 ('\0'ではない
                               ので、読む時には注意が必要です)

                   max     最大文字数('\r'も含みます)。bufferは、
                           max+2バイト確保してください。

                → 入力された文字数

------------------------------------------------------------------------
□ dos_get_verify - ベリファイフラグの読み取り

C:      int dos_get_verify(void);

        ------------------------------------------98N 98H AT DOS-
        dos_get_verify                                       ５
        ------------------------------------------<dosgetve.asm>-

                ● DOSのディスクアクセスのベリファイフラグの値を
                   得ます。

                → 0      ベリファイなし
                   0以外  ベリファイあり

                ★ Symantec C++  6.1Jにある同名関数を呼ぶときは、
                   (dos_get_verify)();などのように、 関数名を括弧
                   で括ってください。

------------------------------------------------------------------------
□ dos_ignore_break - ^Cを無視する設定をする

C:      void dos_ignore_break(void);

        ------------------------------------------98N 98H AT DOS-
        dos_ignore_break                                     ５
        ------------------------------------------<dosnobrk.asm>-

                ● MS-DOS が ^Cを検出し、^C表示をした後に、プログ
                   ラム中断がされないようにします。

                ★ プログラムが終了すると、 DOSは自動的にこの設定
                   を呼び出し前の状態に戻します。

------------------------------------------------------------------------
□ dos_keyclear - キーバッファの消去

C:      void dos_keyclear(void);

        ------------------------------------------98N 98H AT DOS-
        dos_keyclear                                         ５
        ------------------------------------------<doskeycl.asm>-

                ● 標準入力に溜っているデータを消去します。

------------------------------------------------------------------------
□ dos_makedir - 深いサブディレクトリの作成

C:      int dos_makedir( const char * path );

        ------------------------------------------98N 98H AT DOS-
        dos_makedir                                          ５
        ------------------------------------------<dosmaked.asm>-

                ● 一度に多層のサブディレクトリを作成します。

                → 1  成功(すでに存在する場合も成功)
                   0  失敗(ディスクに空きがない/パスが無効)
                      途中で失敗した場合、 途中までのディレクトリ
                      が作成されている場合があります。

                ★ 現状では、ルートディレクトリが満杯のときに、ル
                   ートディレクトリの直下に一層だけ作成しようとす
                   ると、失敗しているのに成功として返します。

------------------------------------------------------------------------
□ dos_maxfree - 最大空きメモリブロックサイズの取得

C:      unsigned dos_maxfree(void);

        ------------------------------------------98N 98H AT DOS-
        dos_maxfree                                          ５
        ------------------------------------------<dosmaxfr.asm>-

                ● DOSの空きメモリブロックのうち、 最大のものの大
                   きさをパラグラフ単位で得ます。

------------------------------------------------------------------------
□ dos_mkdir - サブディレクトリの作成

C:      int dos_mkdir( const char * path );

        ------------------------------------------98N 98H AT DOS-
        dos_mkdir                                            ５
        ------------------------------------------<dosmkdir.asm>-

                ● サブディレクトリを作成します。

                → 1  成功
                   0  失敗(ディスクに空きがない/パスが無効)

------------------------------------------------------------------------
□ dos_move - ディレクトリエントリの移動

C:      int dos_move( const char far * source, const char far * dest );

        ------------------------------------------98N 98H AT DOS-
        dos_move                                             ５
        -------------------------------------------<dosmove.asm>-

                ● ディレクトリエントリ(ファイル,ディレクトリなど)
                   の所在を移動します。移動が成功すると、移動元は
                   なくなります。

                ← source 移動元の存在するパス名
                   dest   移動先のパス名

                → 1  成功
                   0  失敗

                ★ source,destが共に同じ物理ドライブに無いと移動
                   できません。また、移動先にすでにファイルなどが
                   存在しても移動できません。

------------------------------------------------------------------------
□ dos_putc - ^Cで止まらない文字出力

C:      void dos_putc( int c );

        ------------------------------------------98N 98H AT DOS-
        dos_putc                                             ５
        -------------------------------------------<dosputc.asm>-

                ● 標準出力へ1文字出力します。
                   MS-DOSの BREAK OFFが行われていれば、^Cチェック
                   がされません。

------------------------------------------------------------------------
□ dos_putch - 高速なコンソール文字出力

C:      void dos_putch( int chr );

        ------------------------------------------98N 98H AT DOS-
        dos_putch                                            ５
        ------------------------------------------<dosputch.asm>-

                ● int 29hを用いて文字を表示します。
                   MS-DOSのバージョン変更によって使えなくなる可能
                   性があります。(DOS5ではOK)

                ★ リダイレクトは効きません。

------------------------------------------------------------------------
□ dos_putp - パスカル文字列出力

C:      void dos_putp( const char * passtr );

        ------------------------------------------98N 98H AT DOS-
        dos_putp                                             ５
        -------------------------------------------<dosputp.asm>-

                ● 標準出力へ文字列を出力します。

------------------------------------------------------------------------
□ dos_puts - 文字列出力

C:      void dos_puts( const char * str );

        ------------------------------------------98N 98H AT DOS-
        dos_puts                                             ５
        -------------------------------------------<dosputs.asm>-

                ● 標準出力へ文字列を出力します。

------------------------------------------------------------------------
□ dos_puts2 - 改行文字変換付き文字列出力

C:      void dos_puts2( const char * str );

        ------------------------------------------98N 98H AT DOS-
        dos_puts2                                            ５
        ------------------------------------------<dosputs2.asm>-

                ● 標準出力へ文字列を出力します。
                   "\n"を、"\r\n"に変換して出力します。 (MSC/TCな
                   どのテキストと同じ)

------------------------------------------------------------------------
□ dos_read - ファイルの読み込み

C:      int dos_read( int fh, void far * buffer, unsigned len );

        ------------------------------------------98N 98H AT DOS-
        dos_read                                             ５
        -------------------------------------------<dosread.asm>-

                ● ファイルから読み込みます。

                ← fh      ファイルハンドル
                   buffer  読み込み先の先頭アドレス
                   len     転送するバイト数

                → 0〜            実際に読み込んだバイト数
                   AccessDenied   読み込み許可されていない
                   InvalidHandle  ハンドルがオープンされていない

------------------------------------------------------------------------
□ dos_rmdir - サブディレクトリの削除

C:      int dos_rmdir( const char * path );

        ------------------------------------------98N 98H AT DOS-
        dos_rmdir                                            ５
        ------------------------------------------<dosrmdir.asm>-

                ● サブディレクトリを削除します。

                → 1  成功
                   0  失敗(存在しない/中に何かある/カレントディレ
                      クトリ)

------------------------------------------------------------------------
□ dos_ropen - ファイルの読み込みオープン

C:      int dos_ropen( const char * filename );

        ------------------------------------------98N 98H AT DOS-
        dos_ropen                                            ５
        ---------------------------------<fontopen/fontopnp.asm>-

                ● 読み込み用にファイルを開きます。

                → FileNotFound  開けない
                   0以上         ファイルハンドル

------------------------------------------------------------------------
□ dos_seek - ファイルポインタの移動

C:      long dos_seek( int fh, long offs, int mode );

        ------------------------------------------98N 98H AT DOS-
        dos_seek                                             ５
        -------------------------------------------<dosseek.asm>-

                ● ファイルポインタを移動します。

                ← fh    ファイルハンドル
                   offs  移動量
                   mode  移動の起点 (  0:ファイル先頭, 1:現在位置,
                                       2:ファイル末尾 )

                → 移動後のファイル先頭からの位置

------------------------------------------------------------------------
□ dos_setbreak - ブレーク検査フラグの読み取りと設定

C:      int dos_setbreak( int breakon );

        ------------------------------------------98N 98H AT DOS-
        dos_setbreak                                         ５
        -------------------------------------------<dosvect.asm>-

                ● DOSファンクションコール呼び出し時点で   CTRL+C
                   (STOP, Ctrl+Break)が押されていたらプログラムを
                   強制終了させる機能の制御をします。

                ← breakon   1  ブレーク検査をする
                             0  ブレーク検査をしない

                → 以前に設定されていたフラグ

------------------------------------------------------------------------
□ dos_setdrive - カレントドライブの設定

C:      int dos_setdrive( int drive );

        ------------------------------------------98N 98H AT DOS-
        dos_setdrive                                         ５
        ------------------------------------------<dossetdr.asm>-

                ● カレントドライブ番号を設定します。
                   0 = A:
                   1 = B:
                   ... という対応になっています。
                   'a'や'A'でもA:を指定できます。

                → 接続されているドライブの数 ( config.sysの
                   LASTDRIVE による)

                ★ Symantec C++  6.1Jにある同名関数を呼ぶときは、
                   (dos_setdrive)(d,&a);などのように、 関数名を括
                   弧で括ってください。

------------------------------------------------------------------------
□ dos_setdta - ディスク転送アドレスの設定

C:      void dos_setdta( void far * dta );

        ------------------------------------------98N 98H AT DOS-
        dos_setdta                                           ５
        ------------------------------------------<dossetdt.asm>-

                ● dos_findfirst/dos_findnextの検索結果を格納する
                   アドレスを設定します。

                ← dta   ディスク転送アドレス。struct find_t a;と
                         して検索結果領域を用意した場合、ここには
                         &a を入れます。

------------------------------------------------------------------------
□ dos_setvect - 割り込みベクタの読み取りとフック

C:      void (interrupt far * dos_setvect( int vect,
                                          void (interrupt far
                                          *address)()))();

        ------------------------------------------98N 98H AT DOS-
        dos_setvect                                          ５
        -------------------------------------------<dosvect.asm>-

                ● 割り込みベクタの以前の値を取得し、代わりに新し
                   い値を設定します。

                ← vect     0〜255, 割り込みベクタ番号
                   address  新しいルーチンの先頭アドレス

                → 以前に設定されていたアドレス

                ★ Cの宣言がややこしいですが、int型と割り込み関数
                   へのポインタを引数に取り、割り込み関数へのポイ
                   ンタを返す関数です。

                例:
                  void interrupt far new_func(void) {
                    /* 新しい割り込みベクタでの処理 */
                  }
                  /* 保存用関数ポインタ変数 */
                  void (interrupt far *old_func)();

                  ・割り込みベクタ VECTOR に new_funcをフックし、
                    以前のアドレスを保存
                  old_func = dos_setvect( VECTOR, new_func );

                  ・保存された、以前のアドレスに復元する
                  dos_setvect( VECTOR, old_func );

------------------------------------------------------------------------
□ dos_set_verify_off - ベリファイOFF

C:      void dos_set_verify_off(void);

        ------------------------------------------98N 98H AT DOS-
        dos_set_verify_off                                   ５
        ------------------------------------------<dosgetvf.asm>-

                ● DOSのディスクアクセスのベリファイを行わないよ
                   うに設定します。

------------------------------------------------------------------------
□ dos_set_verify_on - ベリファイON

C:      void dos_set_verify_on(void);

        ------------------------------------------98N 98H AT DOS-
        dos_set_verify_on                                    ５
        ------------------------------------------<dossetvn.asm>-

                ● DOSのディスクアクセスのベリファイを行うように
                   設定します。

------------------------------------------------------------------------
□ dos_write - ファイルの書き込み

C:      int dos_write( int fh, const void far * buffer, unsigned len );

        ------------------------------------------98N 98H AT DOS-
        dos_write                                            ５
        ------------------------------------------<doswrite.asm>-

                ● ファイルへ書き込みます。

                ← fh      ファイルハンドル
                   buffer  書き込むデータの先頭アドレス
                   len     転送するバイト数

                → 0〜            実際に書き込んだバイト数
                   AccessDenied   書き込み許可されていない
                   InvalidHandle  ハンドルがオープンされていない


------------------------------------------------------------------------
■ RSL(常駐symbolic link)制御 ■■■■■■■■■■■■■■■■■■■■■

        恋塚氏(って俺か)の "RSL" を利用する関数群です。
        詳しくは RSL のドキュメント rsl.doc を参照のこと〜
        ちなみにすべてのAPIを実装しているわけではありません。
        なお、RSLのバージョンは 007以降を対象としています。

------------------------------------------------------------------------
□ 定数

        ● rsl_linkmode()の引数
        表記            値      意味
        RSL_NOCONVERT   1       ファイル検索結果をすりかえない
        RSL_CONVERT     0       ファイル検索結果をすりかえる(デフ
                                ォルト)

------------------------------------------------------------------------
□ rsl_exist - RSLの常駐検査

C:      int rsl_exist(void);

        ------------------------------------------98N 98H AT DOS-
        rsl_exist                                            ○
        -----------------------------------------------<rsl.asm>-

                ● RSLの常駐検査をします。rsl_*関数を使うまえに、
                   最初に実行する必要があります。
                   これによって存在を検出できなかった場合と、この
                   関数を実行しなかった場合、 rsl_*()関数はまった
                   くの無動作となります。

                → 1  rslが常駐している
                   0  rslは常駐していない

------------------------------------------------------------------------
□ rsl_linkmode - シンボリックリンク変換モードの設定

C:      int rsl_linkmode( unsigned mode );

        ------------------------------------------98N 98H AT DOS-
        rsl_linkmode                                         ○
        -----------------------------------------------<rsl.asm>-

                ● ファイル検索時に、シンボリックリンクが検索され
                   た場合に自動的にリンク先にすりかえるかどうかを
                   指定します。

                ← mode  RSL_CONVERT    すりかえる(デフォルト)
                         RSL_NOCONVERT  すりかえない

                → 0  RSLが存在しない
                   1  成功


------------------------------------------------------------------------
□ rsl_readlink - シンボリックリンクの読み取り

C:      int rsl_readlink( char * buf, const char * path );

        ------------------------------------------98N 98H AT DOS-
        rsl_readlink                                         ○
        -----------------------------------------------<rsl.asm>-

                ● 指定のパスがシンボリックリンクだった場合、 buf
                   にその差す先のパス名を返します。

                ← buf   取得するパス名の格納先
                   path  シンボリックリンクのパス名

                → 0  RSLが存在しないか、pathがシンボリックリンク
                      ではない
                   1  リンク先のパス名文字列が得られた


------------------------------------------------------------------------
■ 入力・操作関係 ■■■■■■■■■■■■■■■■■■■■■■■■■■■


------------------------------------------------------------------------
■ キーボード関係 ■■■■■■■■■■■■■■■■■■■■■■■■■■■

        キー入力などを簡便に管理するための関数群です。

------------------------------------------------------------------------
□ 構造体／グローバル変数

        ● キー割り当て構造体です。このグローバル変数を変更すると、
           その時点から key_wait, key_scan などが新しい値にしたが
           った値を返すようになります。
typedef struct KEYTABLE KEYTABLE;
struct KEYTABLE {
        unsigned rollup, rolldown, ins, del, up, left, right, down;
        unsigned homeclr, help, s_homeclr;
};
extern KEYTABLE key_table_normal, key_table_alt;
extern KEYTABLE key_table_shift,  key_table_ctrl;

        ● キー書き戻しバッファ。key_back()参照
unsigned key_back_buffer;

------------------------------------------------------------------------
□ 定数

        ● シフトキー押し下げ状態ビット ( key_shift )
        表記    値      キー
        K_SHIFT 1       [Shift]が押されている
        K_CAPS  2       Capsロック
        K_KANA  4       カナロック
        K_GRPH  8       [GRPH]または[Alt]が押されている
        K_CTRL  16      [CTRL]が押されている

        ● デフォルトでkey_scanが返す値 ( key_table... )
        表記            値              操作
        ---------------------------------------------
        CTRL(c)         (c-'@')         [CTRL]+c
        K_HELP          0x100           [HELP]
        K_UP            CTRL('E')       [↑]
        K_LEFT          CTRL('S')       [←]
        K_RIGHT         CTRL('D')       [→]
        K_DOWN          CTRL('X')       [↓]
        K_S_UP          CTRL('R')       [SHIFT]+[↑]
        K_S_LEFT        CTRL('A')       [SHIFT]+[←]
        K_S_RIGHT       CTRL('F')       [SHIFT]+[→]
        K_S_DOWN        CTRL('C')       [SHIFT]+[↓]
        K_ROLLUP        CTRL('C')       [ROLL UP]
        K_ROLLDOWN      CTRL('R')       [ROLL DOWN]
        K_DEL           CTRL('G')       [DEL]
        K_HOMECLR       CTRL('Y')       [HOME/CLR]
        K_CLR           CTRL('@')       [SHIFT]+[HOME/CLR]
        K_BS            CTRL('H')       [BS]
        K_TAB           CTRL('I')       [TAB]
        K_INS           CTRL('V')       [INS]
        K_ESC           CTRL('[')       [ESC]
        K_CR            CTRL('M')       リターンキー
        K_F1            0x101           [f･1]
        K_F2            0x102           [f･2]
        K_F3            0x103           [f･3]
        K_F4            0x104           [f･4]
        K_F5            0x105           [f･5]
        K_F6            0x106           [f･6]
        K_F7            0x107           [f･7]
        K_F8            0x108           [f･8]
        K_F9            0x109           [f･9]
        K_F10           0x10a           [f･10]
        K_S_F1          0x10b           [SHIFT]+[f･1]
        K_S_F2          0x10c           [SHIFT]+[f･2]
        K_S_F3          0x10d           [SHIFT]+[f･3]
        K_S_F4          0x10e           [SHIFT]+[f･4]
        K_S_F5          0x10f           [SHIFT]+[f･5]
        K_S_F6          0x110           [SHIFT]+[f･6]
        K_S_F7          0x111           [SHIFT]+[f･7]
        K_S_F8          0x112           [SHIFT]+[f･8]
        K_S_F9          0x113           [SHIFT]+[f･9]
        K_S_F10         0x114           [SHIFT]+[f･10]
        K_VF1           0x120           [vf･1]
        K_VF2           0x121           [vf･2]
        K_VF3           0x122           [vf･3]
        K_VF4           0x123           [vf･4]
        K_VF5           0x124           [vf･5]
        K_S_VF1         0x125           [SHIFT]+[vf･1]
        K_S_VF2         0x126           [SHIFT]+[vf･2]
        K_S_VF3         0x127           [SHIFT]+[vf･3]
        K_S_VF4         0x128           [SHIFT]+[vf･4]
        K_S_VF5         0x129           [SHIFT]+[vf･5]
        K_C_F1          0x12a           [CTRL]+[f･1]
        K_C_F2          0x12b           [CTRL]+[f･2]
        K_C_F3          0x12c           [CTRL]+[f･3]
        K_C_F4          0x12d           [CTRL]+[f･4]
        K_C_F5          0x12e           [CTRL]+[f･5]
        K_C_F6          0x12f           [CTRL]+[f･6]
        K_C_F7          0x130           [CTRL]+[f･7]
        K_C_F8          0x131           [CTRL]+[f･8]
        K_C_F9          0x132           [CTRL]+[f･9]
        K_C_F10         0x133           [CTRL]+[f･10]
        K_C_VF1         0x134           [CTRL]+[vf･1]
        K_C_VF2         0x135           [CTRL]+[vf･2]
        K_C_VF3         0x136           [CTRL]+[vf･3]
        K_C_VF4         0x137           [CTRL]+[vf･4]
        K_C_VF5         0x138           [CTRL]+[vf･5]
        K_S_DEL         CTRL('T')       [SHIFT]+[DEL]
        K_C_UP          (CTRL('E')+0x200) [CTRL]+[↑]
        K_C_LEFT        (CTRL('S')+0x200) [CTRL]+[←]
        K_C_RIGHT       (CTRL('D')+0x200) [CTRL]+[→]
        K_C_DOWN        (CTRL('X')+0x200) [CTRL]+[↓]
        K_C_ROLLUP      (CTRL('C')+0x200) [CTRL]+[ROLL UP]
        K_C_ROLLDOWN    (CTRL('R')+0x200) [CTRL]+[ROLL DOWN]
        K_C_DEL         (CTRL('G')+0x200) [CTRL]+[DEL]
        K_C_INS         (CTRL('V')+0x200) [CTRL]+[INS]
        K_A_UP          (CTRL('E')+0x300) [GRPH]+[↑]
        K_A_LEFT        (CTRL('S')+0x300) [GRPH]+[←]
        K_A_RIGHT       (CTRL('D')+0x300) [GRPH]+[→]
        K_A_DOWN        (CTRL('X')+0x300) [GRPH]+[↓]
        K_A_ROLLUP      (CTRL('C')+0x300) [GRPH]+[ROLL UP]
        K_A_ROLLDOWN    (CTRL('R')+0x300) [GRPH]+[ROLL DOWN]
        K_A_DEL         (CTRL('G')+0x300) [GRPH]+[DEL]
        K_A_INS         (CTRL('V')+0x300) [GRPH]+[INS]

        ● シフトキー定数(vkey_shift)
        VK_RSHIFT       0x01    右シフト
        VK_LSHIFT       0x02    左シフト
        VK_SHIFT        (VK_RSHIFT|VK_LSHIFT)
        VK_CTRL         0x04    コントロールキー
        VK_ALT          0x08    全面キー
        VK_KANA         0x10    /* J3100 */
        VK_NUMLOCK      0x20    NumLockされている
        VK_CAPS         0x40    CapsLockされている

------------------------------------------------------------------------
□ key_back - キーバッファへの書き戻し

C:      void key_back(unsigned back_key);                  マクロ

        ------------------------------------------98N 98H AT DOS-
        key_back
        -----------------------------------------------------<->-

                ● 　キーバッファ(key_back_buffer)に、1文字だけ書
                   き戻します。
                   　次回の key_wait, key_scan, vkey_wait,
                   vkey_scan は、実際のキーバッファよりも先にここ
                   に書き込んだ値を返し、key_back_bufferを0にしま
                   す。

                ← back_key  0以外  書き戻す値
                             0      書き戻しをキャンセル

------------------------------------------------------------------------
□ key_beep_off - キーバッファフル音の禁止

C:      void key_beep_off(void);

        ------------------------------------------98N 98H AT DOS-
        key_beep_off                               ○  × ×
        -------------------------------------------<keybeep.asm>-

                ● BIOSでキーバッファが満杯の時にさらにキーが押さ
                   れた時に鳴らす音を禁止(鳴らなく)します。
                   通常は、鳴ります。

------------------------------------------------------------------------
□ key_beep_on - キーバッファフル音の許可

C:      void key_beep_on(void);

        ------------------------------------------98N 98H AT DOS-
        key_beep_on                                ○  × ×
        -------------------------------------------<keybeep.asm>-

                ● BIOSでキーバッファが満杯の時にさらにキーが押さ
                   れた時に鳴らす音を許可します。
                   通常は、鳴ります。

------------------------------------------------------------------------
□ key_end - 特殊キー読み取り設定の破棄

C:      void key_end(void);

        ------------------------------------------98N 98H AT DOS-
        key_end                                    ○  ○ × ５
        ------------------------------------------<keystart.asm>-

                ● key_start の設定を実行前の値に戻します。

                ★ key_start を実行したら、終了時には必ずこの関数
                   を実行してください。

                ○ key_startが実行されていない状態で呼び出すと何
                   もしません。

------------------------------------------------------------------------
□ key_pressed - 先行入力の検査

C:      int key_pressed(void);

        ------------------------------------------98N 98H AT DOS-
        key_pressed                                          ○
        ------------------------------------------<keypresd.asm>-

                ● まだ取得していない有効なキー入力がなされている
                   かを判定します。

                → 1  キーバッファになにかある
                   0  キーバッファは空

                ○ kbhit() と同等の関数です。

------------------------------------------------------------------------
□ key_reset - キーボードインターフェイスのリセット

C:      void key_reset(void);

        ------------------------------------------98N 98H AT DOS-
        key_reset                                  ○     ×
        ------------------------------------------<keyreset.asm>-

                ● キーボードインターフェイスにリセットコマンドを
                   実行します。

                ○ この処理を実行することによって、キーボードリピ
                   ートのカウンタをリセットすることができます。が、
                   あまり意味がないかもしれません :-)

------------------------------------------------------------------------
□ key_scan - 特殊キーの読み取り

C:      unsigned key_scan(void);

        ------------------------------------------98N 98H AT DOS-
        key_scan                                   ○  ○ ＊ ５
        ------------------------------------------<keystart.asm>-

                ● キーバッファになにかあればそのコードを、なけれ
                   ば 0xffffを返します。
                   キーバッファからそのコードは抜き取られます。

                → 0xffff  なにも入力されていない
                   以外    入力されたキーの値 ( K_UP などの定数、
                           または文字コード )
                           特殊キーでなければ MS-DOS から入力する
                           のと同じです。

                ○ 特殊キーの値は、グローバル変数 key_table... に
                   書かれた値から返されます。この値を変更した途端
                   にキーアサインを変更することができます。

------------------------------------------------------------------------
□ key_sense - キーの押し下げ状態の取得

C:      int key_sense( int keygroup );

        ------------------------------------------98N 98H AT DOS-
        key_sense                                  ○     ×
        ------------------------------------------<keysense.asm>-

                ● キーグループの現在のキー押下状態を取得します。
                   　キーバッファとは無関係に動作するので、バッフ
                   ァフル音を key_beep_off によって消しておくべき
                   です。
                   　キーリピートによって取り逃す恐れがあるので、
                   一回実行したあと2ms程度の間を置いて二回目を実
                   行して、両方の結果のorをとってください。

                ← keygroup  キーグループ
                             98の int 18h, ah = 04hに関する資料を
                             参照してください。

                → key押下状態

                ○ AH = 4, INT 18h を呼び出しています。

------------------------------------------------------------------------
□ key_sense_bios - BIOSによるキー入力のセンス

C:      unsigned key_sense_bios(void);

        ------------------------------------------98N 98H AT DOS-
        key_sense_bios                             ○  ○ ＊
        -------------------------------------------<keybios.asm>-

                ● キーBIOS を用いて、 キー入力がすでにあればキー
                   コードを返し、押されていなければ0を返します。

                → 0           キー入力が為されていない
                   0以外
                     上位8bit  キーコード
                     下位8bit  キーデータ(キャラクタコード)

                ○ AH = 1, INT 18h を呼び出しています。

                ★ これを使うと、大抵の FEP は全く効きません。 ま
                   た、キー配列を換えている常駐ソフトが効かなかっ
                   たりします。押されたキーに対応する文字ではなく、
                   キーの位置に依存する場合にしか使わないほうが無
                   難でしょう。

------------------------------------------------------------------------
□ key_set_label - ファンクションキー表示内容の設定

C:      void key_set_label( int num, const char * lab );

        ------------------------------------------98N 98H AT DOS-
        key_set_label                              ○  ○ × ５
        ------------------------------------------<keysetla.asm>-

                ● ファンクションキーのラベルを設定します。

                ← num  1〜10: F･1〜F･10
                        11〜20: SHIFT+F･1〜SHIFT+F･10
                   lab  5文字の文字列

------------------------------------------------------------------------
□ key_shift - シフトキー状態の取得

C:      int key_shift(void);

        ------------------------------------------98N 98H AT DOS-
        key_shift                                  ○     ＊
        ------------------------------------------<keyshift.asm>-

                ● 現在押されているシフトキーの状態を、以下の定数
                   を足し合わせて返します。
                   　判定するには、目的の定数との  AND(&)の結果が
                   0 でなければ押されている、としてください。

                        K_SHIFT 1
                        K_CAPS  2
                        K_KANA  4
                        K_GRPH  8
                        K_CTRL  16

------------------------------------------------------------------------
□ key_start - 特殊キー読み取りのための準備

C:      void key_start(void);

        ------------------------------------------98N 98H AT DOS-
        key_start                                  ○  ○ × ５
        ------------------------------------------<keystart.asm>-

                ● key_scan,key_waitなどの準備(特殊キーの設定)を
                   します。また、ファンクションキーの表示文字列を
                   すべて空にします。

                ★ この関数を実行したら、 終了時には必ず  key_end
                   を実行してください。

                ○ この関数は、実行に時間が少しかかるので、キーを
                   取る度に  key_start(),key_scan(),key_end()のシ
                   ーケンスを実行するようなことは避けて、起動時に
                   key_start(),   処理中は  key_scan(),  終了時に
                   key_end()、 というふうに切り分けて使うようにし
                   てください。
                ○ すでに key_start が実行される場合は、 ファンク
                   ションキーおよび特殊キーの定義をやりなおします。

                ○ 以下の順に呼び出したときの動作:
                   key_start()   (1)ファンクションキーの待避、 キ
                                 ー割り当ての設定、 CTRL+ファンク
                                 ションキーのソフトキー化
                   key_start()   キー割当の再設定、 CTRL+ファンク
                                 ションキーのソフトキー化
                   key_end()     ファンクションキーの(1)の時点へ
                                 の復元、 CTRL+ファンクションキー
                                 のソフトキー化の解除
                   key_start()   (2)ファンクションキーの待避、 キ
                                 ー割り当ての設定、 CTRL+ファンク
                                 ションキーのソフトキー化
                   key_end()     ファンクションキーの(2)の時点へ
                                 の復元、 CTRL+ファンクションキー
                                 のソフトキー化の解除
                   key_end()     ファンクションキーの(2)の時点へ
                                 の復元、 CTRL+ファンクションキー
                                 のソフトキー化の解除

------------------------------------------------------------------------
□ key_wait - 特殊キーの入力待ち

C:      unsigned key_wait(void);

        ------------------------------------------98N 98H AT DOS-
        key_wait                                   ○  ○ ＊ ５
        ------------------------------------------<keystart.asm>-

                ● キーバッファが空ならば何か押されるまで待って、
                   そのコードを返します。

                → 入力されたキーの値 ( K_UP などの定数、または文
                   字コード )
                   特殊キーでなければ MS-DOS から入力するのと同じ
                   です。

                ○ 特殊キーの値は、グローバル変数 key_table... に
                   書かれた値から返されます。この値を変更した途端
                   にキーアサインを変更することができます。

------------------------------------------------------------------------
□ key_wait_bios - BIOSによるキー入力待ち

C:      unsigned key_wait_bios(void);

        ------------------------------------------98N 98H AT DOS-
        key_wait_bios                              ○  ○ ＊
        -------------------------------------------<keybios.asm>-

                ● キーBIOS を用いて、キー入力があるまで待ち、 押
                   されたキーコードを返します。

                → 上位8bit  キーコード
                   下位8bit  キーデータ(キャラクタコード)

                ○ AH = 0, INT 18h を呼び出しています。

                ★ これを使うと、大抵の FEP は全く効きません。 ま
                   た、キー配列を換えている常駐ソフトが効かなかっ
                   たりします。押されたキーに対応する文字ではなく、
                   キーの位置に依存する場合にしか使わないほうが無
                   難でしょう。

------------------------------------------------------------------------
□ vkey_scan - <AT>待たないキー入力

C:      unsigned long vkey_scan(void);

        ------------------------------------------98N 98H AT DOS-
        vkey_scan                                  ×  × ○ ○
        ------------------------------------------<vkeywait.asm>-

                ● 現在のキーバッファを読み取り、 空(何も入力され
                   ていない)なら 0を返します。
                   何か入力されていれば、一番古いものを抜き出して
                   返します。

                → ビット割り付けは以下の通り。上位16bitは、1なら
                   押されている。
                    bit 31: SysReq
                    bit 30: CapsLock
                    bit 29: NumLock
                    bit 28: ScrollLock
                    bit 27: right Alt
                    bit 26: right Ctrl
                    bit 25: left Alt
                    bit 24: left Ctrl
                    bit 23: Ins mode
                    bit 22: CapsLock
                    bit 21: NumLock
                    bit 20: ScrollLock
                    bit 19: Alt
                    bit 18: Ctrl
                    bit 17: left shift
                    bit 16: right shift

                    bit 15-8: scan key code
                    bit  7-0: key code

                ○ キーバッファは更新されます。

                ○ 参照:  vkey_to_98(), vkey_wait()

------------------------------------------------------------------------
□ vkey_shift - <AT>シフトキー読み取り

C:      int vkey_shift(void);                              マクロ

        ------------------------------------------98N 98H AT DOS-
        vkey_shift                                 ×  × ○ ○
        -----------------------------------------------------<->-

                ● 現在のシフトキー押し下げ状態を得ます。
                   以下の値とandを取った結果が非0なら押されてるか、
                   ロックされています。

                   VK_RSHIFT VK_LSHIFT VK_SHIFT
                   VK_CTRL   VK_ALT    VK_NUMLOCK
                   VK_CAPS

------------------------------------------------------------------------
□ vkey_to_98 - 98用キーコードを得る

C:      unsigned vkey_to_98( unsigned long atkey );

        ------------------------------------------98N 98H AT DOS-
        vkey_to_98                                 ○  ○ ○ ○
        ------------------------------------------<vkeyto98.asm>-

                ● vkey_wait, vkey_scan で得た値を渡すことにより、
                   98のkey_wait, key_scan 相当の結果に変換します。

                ○ 98で実行した場合、 渡された値の下位16bitをその
                   まま返します。

                ★ 事前に get_machine()の実行が必要です。

                ○ 参照:  vkey_scan(), vkey_wait()

------------------------------------------------------------------------
□ vkey_wait - <AT>キー入力待ち

C:      unsigned long vkey_wait(void);

        ------------------------------------------98N 98H AT DOS-
        vkey_wait                                  ×  × ○ ○
        ------------------------------------------<vkeywait.asm>-

                ● 現在のキーバッファを読み取り、 空(何も入力され
                   ていない)なら入力されるまで待ちます。
                   何か入力されれば、一番古いものを抜き出して返し
                   ます。

                → vkey_scan 参照

                ○ キーバッファは更新されます。

                ○ 参照:  vkey_scan(), vkey_to_98()


------------------------------------------------------------------------
■ 日本語FEPの制御 ■■■■■■■■■■■■■■■■■■■■■■■■■■

        　日本語入力FEPのON/OFFを制御します。
        　MS-KANJI APIおよび、IBM DOS/Vにおける$IAS形式に対応した
        日本語入力FEPのみが制御できます。
        　最近はどの日本語入力FEPも、MS-KANJIぐらいは対応している
        ようです。

        　制御する場合、あらかじめ、fep_exist を実行してください。

------------------------------------------------------------------------
□ 定数

        ● fep_existの戻り値
        表記            値      意味
        FEP_IAS         1       $IAS仕様の日本語FEPが存在
        FEP_MSKANJI     2       MS KANJI仕様の日本語FEPが存在

------------------------------------------------------------------------
□ fep_exist - 日本語FEPの存在判定

C:      int fep_exist(void);

        ------------------------------------------98N 98H AT DOS-
        fep_exist                                            ○
        ------------------------------------------<fepexist.asm>-

                ● FEPの存在判定を行います。

                → 0            以下のどれも存在しない
                   FEP_IAS      IBM $IAS.SYS を発見(事前に
                                get_machine()の実行が必要)
                   FEP_MSKANJI  MS KANJI APIを発見

                ★ この関数は、 他のfep_*()を呼び出す前に必ず実行
                   する必要があります。実行しないとどれも動作しま
                   せん。

------------------------------------------------------------------------
□ fep_hide - 日本語FEPの非表示

C:      void fep_hide(void);

        ------------------------------------------98N 98H AT DOS-
        fep_hide                                             ○
        ------------------------------------------<fepexist.asm>-

                ● 日本語FEPの日本語入力モードを解除します。

------------------------------------------------------------------------
□ fep_show - 日本語FEPの表示

C:      void fep_show(void);

        ------------------------------------------98N 98H AT DOS-
        fep_show                                             ○
        ------------------------------------------<fepexist.asm>-

                ● 日本語FEPを、日本語入力モードにします。

------------------------------------------------------------------------
□ fep_shown - 日本語FEPの表示状態取得

C:      int fep_shown(void);

        ------------------------------------------98N 98H AT DOS-
        fep_shown                                            ○
        ------------------------------------------<fepexist.asm>-

                ● FEPを検出してある場合、FEPの表示状態を得ます。

                → 1  日本語入力モード
                   0  英数入力モード(日本語FEPがOFF)


------------------------------------------------------------------------
■ マウス制御 ■■■■■■■■■■■■■■■■■■■■■■■■■■■■■

        　実行形式にリンクする内蔵マウスドライバ(98専用)や、 外部
        マウスドライバを呼び出す関数などです。

        　内蔵マウスドライバは、 別途マウスドライバを常駐させる必
        要なく、マウスを読めるようにするものです。

        使い方の骨格を示しますと、こんな感じです。

        ・マウスカーソルあり・vsync割り込み使用時:
            初期設定
                mouse_vstart(0,7);
                mouse_cmoveto(x,y); /* 必要に応じて */
                cursor_pattern(cx,cy,bc,wc,pattern);    /* 必要に
                                                        応じて */

            カーソル表示
                cursor_show();

            読み取り
                struct mouse_info ms;
                mouse_get(&ms);
            終了
                mouse_vend();

        ・マウスカーソルあり・マウス割り込み使用時:
            「マウスカーソルあり・vsync割り込み使用時」の
            mouse_vstartを mouse_istartに、
            mouse_vendを mouse_iendにかえるだけです。

        ★ グラフィック画面を操作するときは、グラフィックカーソル
           は消さないとカーソル付近のグラフィックがおかしくなりま
           す。

        ・マウスカーソルなし・マウス割り込み使用時:
            初期設定
                mouse_proc_init();
                mouse_int_start( mouse_proc, MOUSE_120Hz );
                mouse_setmickey(8,8);   /* 必要に応じて */
                mouse_setrect(0,0,639,399); /* これも必要に応じて
                */
            読み取り
                struct mouse_info ms;
                mouse_get(&ms);
            終了
                mouse_int_end();

        ・マウスカーソルなし・割り込みを使わないとき:
            初期設定
                mouse_proc_init();
                mouse_int_start( 0, MOUSE_120Hz );
                mouse_setmickey(8,8);   /* 必要に応じて */
                mouse_setrect(0,0,639,399); /* これも必要に応じて
                */
            読み取り
                int event = mouse_proc();
                int x = mouse_X;
                int y = mouse_Y;
                int bt = mouse_Button;
                /* mouse_get()でもOK */
            終了
                mouse_int_end();

------------------------------------------------------------------------
□ 構造体／グローバル変数

struct mouse_info {
    unsigned button;                    マウスのボタンの状態
                                        (MOUSE_BL, MOUSE_BRの組み
                                        合せ)
    int x, y;                           マウスの座標
};

int mouse_X, mouse_Y                    マウスの座標
unsigned mouse_Button                   マウスのボタンの状態
unsigned mouse_ScaleX, mouse_ScaleY     感度
unsigned mouse_EventMask                イベント関数を起動するマ
                                        スク
void (far *mouse_EventRoutine)()        イベント関数のアドレス
unsigned mouse_Type                     使用している外部マウスド
                                        ライバの種類

------------------------------------------------------------------------
□ 定数

        ● mouse_int_start() の freq に指定する値
        表記            値      マウス割り込み周期
        MOUSE_120Hz     0       毎秒120回
        MOUSE_60Hz      1       毎秒60回
        MOUSE_30Hz      2       毎秒30回
        MOUSE_15Hz      3       毎秒15回

        ● mouse_proc()のイベントコード
        表記            値    イベント
        MOUSE_BL        0x01  左ボタンが押されている
        MOUSE_BR        0x02  右ボタンが押されている
        MOUSE_MOVE      0x04  マウスが動いた
        MOUSE_NOEVENT   0x08  何も起こらない
        MOUSE_BLDOWN    0x10  左ボタンが押された
        MOUSE_BLUP      0x20  左ボタンが離された
        MOUSE_BRDOWN    0x40  右ボタンが押された
        MOUSE_BRUP      0x80  右ボタンが離された
        MOUSE_EVENT     0xf4  何か起こった

        ● mousex_start()の戻り値, mouse_Type の値
        表記            値 意味
        MOUSEX_NONE     0  外部マウスドライバが存在しない
        MOUSEX_NEC      1  NEC MOUSE.SYS形式のドライバを検出
        MOUSEX_MS       2  MS MOUSE.COM形式のドライバを検出

------------------------------------------------------------------------
□ mouse_cmoveto - マウスとカーソルの移動

C:      void mouse_cmoveto( int x, int y );

        ------------------------------------------98N 98H AT DOS-
        mouse_cmoveto                              ○  × ×
        ------------------------------------------<mousmove.asm>-

                ● mouse_istart や mouse_vstart  を使ってグラフィ
                   ックカーソルとマウスが連動するようにしてあると
                   きに、マウスカーソルを移動します。

                ← x,y  新しい座標

------------------------------------------------------------------------
□ mouse_get - マウスの位置とボタンの読み取り

C:      void mouse_get( struct mouse_info * ms );          マクロ

        ------------------------------------------98N 98H AT DOS-
        mouse_get                                  ○  × ×
        -----------------------------------------------------<->-

                ● マウスの現在の座標とボタンの状態を得ます。

                → ms->x       x座標
                   ms->y       y座標
                   ms->button  ボタンの状態(MOUSE_BL,MOUSE_BRの組
                               み合せ)

------------------------------------------------------------------------
□ mouse_int_disable - マウス割り込みの禁止

C:      void mouse_int_disable(void);

        ------------------------------------------98N 98H AT DOS-
        mouse_int_disable                          ○  × ×
        --------------------------------------------<mouse1.asm>-

                ● マウス割り込みを禁止します。
                   mouse_int_start()で、 マウス割り込みを無効にし
                   ていないときだけ効果があります。

------------------------------------------------------------------------
□ mouse_int_enable - マウス割り込みの許可

C:      void mouse_int_enable(void);

        ------------------------------------------98N 98H AT DOS-
        mouse_int_enable                           ○  × ×
        --------------------------------------------<mouse1.asm>-

                ● マウス割り込みを許可します。
                   mouse_int_start()で、 マウス割り込みを無効にし
                   ていないときだけ効果があります。

------------------------------------------------------------------------
□ mouse_int_end - マウス割り込みの復帰

C:      void mouse_int_end(void);

        ------------------------------------------98N 98H AT DOS-
        mouse_int_end                              ○  × × ○
        --------------------------------------------<mouse1.asm>-

                ● mouse_int_start()で設定した割り込み情報を以前
                   の値に復元します。

------------------------------------------------------------------------
□ mouse_int_start - マウス割り込みの開始

C:      void mouse_int_start( int (far pascal * mousefunc)(void), int freq );

        ------------------------------------------98N 98H AT DOS-
        mouse_int_start                            ○  × × ○
        --------------------------------------------<mouse1.asm>-

                ● マウス割り込みの初期設定をします。
                   マウスを操作する場合、割り込みを使わなくても、
                   すでに常駐しているマウスドライバを眠らせるため
                   にこの初期設定が必要です。

                ← mousefunc    　0 ならばマウス割り込み無効。
                                　0以外なら、マウス割り込み処理の
                                アドレスを指定します。
                                通常は、 mouse_procを指定してくだ
                                さい。
                   freq         以下の定数から指定します。
                                MOUSE_120Hz
                                MOUSE_60Hz
                                MOUSE_30Hz
                                MOUSE_15Hz

                ★ mouse_int_start()を実行したら、 終了前には必ず
                   mouse_int_end()を実行する必要があります。 実行
                   しなければ、プログラム終了後暴走するでしょう。

------------------------------------------------------------------------
□ mouse_proc - マウス管理ルーチン

C:      int mouse_proc(void);

        ------------------------------------------98N 98H AT DOS-
        mouse_proc                                 ○  × ×
        --------------------------------------------<mouse2.asm>-

                ● マウスのハードウェアから、位置とボタン情報を読
                   み取りイベントを判定し、必要に応じて
                   mouse_EventRoutineに書かれたアドレスのイベント
                   処理ルーチンをFAR CALLします。
                   　イベント処理ルーチンを呼び出す要因は、
                   mouse_EventMaskグローバル変数と、 以下のイベン
                   トの論理積(AND)を取った結果が 0 でなければ、と
                   いうことになります。
                   　イベント処理ルーチンを呼び出す際、AXレジスタ
                   にイベント値、DXレジスタにx座標、BXレジスタにy
                   座標が入ります。SIレジスタ以外は自由に破壊して
                   かまいません。SIにはこの関数(mouse_proc)の戻り
                   値が入っています。イベント処理ルーチンから帰っ
                   てきたら mouse_proc は  SIに入っている値を戻り
                   値として終了します。
                   　mouse_proc の戻り値は、 デフォルトでイベント
                   値が格納されています。

                → 発生したイベント
                        以下のビットの組み合せになります。
                        MOUSE_BLDOWN    左ボタンが押された
                        MOUSE_BLUP      左ボタンが離された
                        MOUSE_BRDOWN    右ボタンが押された
                        MOUSE_BRUP      右ボタンが離された
                        MOUSE_MOVE      マウスが動いた
                        MOUSE_NOEVENT   上記のどれも発生しなかっ
                                        た
                        MOUSE_BL        左ボタンの状態(0=離されて
                                        いる)
                        MOUSE_BR        右ボタンの状態(0=離されて
                                        いる)

------------------------------------------------------------------------
□ mouse_proc_init - マウス管理の初期化

C:      void mouse_proc_init(void);

        ------------------------------------------98N 98H AT DOS-
        mouse_proc_init                            ○  × ×
        --------------------------------------------<mouse2.asm>-

                ● マウス座標管理データを初期化します。
                   移動範囲は画面全体、カーソル位置は画面中心、ミ
                   ッキー／ドット比は、  横方向は   8、  縦方向は
                   400line時は8,  200line時は16が設定されます。こ
                   のため、 200lineで用いるときは、  画面の設定は
                   graph_200line()を用いてください。

------------------------------------------------------------------------
□ mouse_resetrect - マウス管理矩形の初期化

C:      void mouse_resetrect(void);

        ------------------------------------------98N 98H AT DOS-
        mouse_resetrect                            ○  × ×
        --------------------------------------------<mouse2.asm>-

                ● マウスの移動範囲を画面全体にします。

------------------------------------------------------------------------
□ mouse_setmickey - マウスの移動速度を指定する

C:      void mouse_setmickey( unsigned mx, unsigned my );

        ------------------------------------------98N 98H AT DOS-
        mouse_setmickey                            ○  × ×
        ------------------------------------------<mousmicy.asm>-

                ● マウスの移動速度を指定します。
                   x,y それぞれについて、マウス論理座標が  ８進む
                   のに必要なカウント数を指定します。値が大きいほ
                   ど遅くなります。

                ★ mxまたは myに  0を指定するとゼロ除算エラーが発
                   生します。

------------------------------------------------------------------------
□ mouse_setrect - マウス管理矩形の設定

C:      void mouse_setrect( int x1, int y1, int x2, int y2 );

        ------------------------------------------98N 98H AT DOS-
        mouse_setrect                              ○  × ×
        --------------------------------------------<mouse2.asm>-

                ● マウスの移動範囲を指定します。
                   それぞれ x1 ≦ x2, y1 ≦  y2でなければなりませ
                   ん。
                   すでにマウスが範囲外なら、一番近い境界線上に移
                   動します。

------------------------------------------------------------------------
□ mouse_vend - VSYNC割り込みマウス終了

C:      void mouse_vend(void);

        ------------------------------------------98N 98H AT DOS-
        mouse_vend                                 ○  × × ○
        --------------------------------------------<mousev.asm>-

                ● mouse_vstart で開始したマウス処理を終了します。

                ★ 内部で cursor_hide,  vsync_end,  mouse_int_end
                   を呼んでいます。

------------------------------------------------------------------------
□ mouse_vstart - VSYNC割り込みマウス設定

C:      void mouse_vstart( int blc, int whc );

        ------------------------------------------98N 98H AT DOS-
        mouse_vstart                               ○  × × ○
        --------------------------------------------<mousev.asm>-

                ● VSYNC割り込みを使用して、 グラフィックカーソル
                   をマウスに連動させるように設定します。グラフィ
                   ックカーソルは cursor_Arrow を使用し、表示状態
                   は cursor_show()一回で表示開始するように設定し
                   ます。

                ← blc   黒い部分の色(0〜15)
                   whc   白い部分の色(0〜15)

                ○ 各種制御には以下の関数を使用してください。
                  カーソル形状:
                cursor_pattern/cursor_pattern2/cursor_setpattern
                  移動範囲:     mouse_setrect
                  感度:         mouse_setmickey
                  カーソル表示: cursor_show/cursor_hide
                  カーソル位置: mouse_cmoveto

                ★ 事前に mouse_int_start 等を呼んではいけません。
                ★ この関数を実行したら、終了時に必ず  mouse_vend
                   を実行してください。
                ★ 内部で vsync_start, vsync_proc_set  を使用して
                   います。  従って動作中に   vsync_proc_set   や
                   vsync_endを呼び出すと動作が止まってしまいます。

------------------------------------------------------------------------
□ mouse_iend - マウス割り込みマウス終了

C:      void mouse_iend(void);

        ------------------------------------------98N 98H AT DOS-
        mouse_iend                                 ○  × × ○
        --------------------------------------------<mousei.asm>-

                ● mouse_istart で開始したマウス処理を終了します。

                ★ 内部で cursor_hide, mouse_int_end を呼んでいま
                   す。

------------------------------------------------------------------------
□ mouse_istart - マウス割り込みマウス設定

C:      void mouse_istart( int blc, int whc );

        ------------------------------------------98N 98H AT DOS-
        mouse_istart                               ○  × × ○
        --------------------------------------------<mousei.asm>-

                ● マウス割り込み(120Hz)を使用して、 グラフィック
                   カーソルをマウスに連動させるように設定します。
                   グラフィックカーソルは cursor_Arrow を使用し、
                   表示状態は cursor_show()一回で表示開始するよう
                   に設定します。

                ← blc   黒い部分の色(0〜15)
                   whc   白い部分の色(0〜15)

                ○ 各種制御には以下の関数を使用してください。
                  カーソル形状:
                cursor_pattern/cursor_pattern2/cursor_setpattern
                  移動範囲:     mouse_setrect
                  感度:         mouse_setmickey
                  カーソル表示: cursor_show/cursor_hide
                  カーソル位置: mouse_cmoveto

                ★ 事前に mouse_int_start 等を呼んではいけません。
                ★ この関数を実行したら、終了時に必ず  mouse_iend
                   を実行してください。

------------------------------------------------------------------------
□ mousex_end - 外部マウスドライバ使用終了

C:      void mousex_end(void);

        ------------------------------------------98N 98H AT DOS-
        mousex_end                                           ○
        --------------------------------------------<mousex.asm>-

                ● mousex_startで認識した外部マウスドライバを初期
                   化することで、使用を終了します。

------------------------------------------------------------------------
□ mousex_iend - 外部優先マウスの使用終了(簡単)

C:      void mousex_iend(void);

        ------------------------------------------98N 98H AT DOS-
        mousex_iend                                ○  × × ○
        -------------------------------------------<mousexi.asm>-

                ● mousex_istart で開始したマウス処理を終了します。

                ★ 内部で cursor_hide, mouse_int_end,  mousex_end
                   を呼んでいます。

------------------------------------------------------------------------
□ mousex_istart - 外部優先マウスの使用開始(簡単)

C:      void mousex_istart( int blc, int whc );

        ------------------------------------------98N 98H AT DOS-
        mousex_istart                              ○  × × ○
        -------------------------------------------<mousexi.asm>-

                ● 外部マウスドライバがあればそれを使用し、なけれ
                   ばマウス割り込み(120Hz)を使用して、 グラフィッ
                   クカーソルをマウスに連動させるように設定します。
                   　グラフィックカーソルは cursor_Arrow を使用し、
                   表示状態は cursor_show()一回で表示開始するよう
                   に設定します。

                ← blc   黒い部分の色(0〜15)
                   whc   白い部分の色(0〜15)

                △ 各種制御には以下の関数を使用してください。
                  カーソル形状:
                cursor_pattern/cursor_pattern2/cursor_setpattern
                  移動範囲:     mousex_setrect
                  感度:         mouse_setmickey
                  カーソル表示: cursor_show/cursor_hide
                  カーソル位置: mouse_cmoveto

                ★ 事前に mouse_int_start 等を呼んではいけません。
                ★ この関数を実行したら、終了時に必ず mousex_iend
                   を実行してください。
                ★ <AT>マウスドライバが存在しなければ、
                   cursor_initとcursor_setpattern(cursor_Arrow)が
                   実行されるだけでドライバは組み込まれません。判
                   別は、mouse_Type 変数をみて、MOUSEX_NONEでかつ
                   機種がAT系ならば組込み失敗として処理してくださ
                   い。

------------------------------------------------------------------------
□ mousex_moveto - 外部マウスドライバカーソル位置設定

C:      void mousex_moveto( int x, int y );

        ------------------------------------------98N 98H AT DOS-
        mousex_moveto                                        ○
        --------------------------------------------<mousex.asm>-

                ● mousex_startで認識したマウス座標を変更します。

                ← x,y 新しいマウス座標

------------------------------------------------------------------------
□ mousex_setrect - 外部マウスドライバ移動範囲設定

C:      void mousex_setrect( int x1, int y1, int x2, int y2 );

        ------------------------------------------98N 98H AT DOS-
        mousex_setrect                                       ○
        --------------------------------------------<mousex.asm>-

                ● mousex_startで認識したマウスの座標範囲を指定し
                   ます。

                ← x1,y1  左上座標
                   x2,y2  右下座標

------------------------------------------------------------------------
□ mousex_start - 外部マウスドライバ使用開始

C:      int mousex_start(void);

        ------------------------------------------98N 98H AT DOS-
        mousex_start                                         ○
        --------------------------------------------<mousex.asm>-

                ● 外部マウスドライバの存在を検査し、使用を開始し
                   ます。
                   この初期化をすると、マウス割り込みによってグロ
                   ーバル変数 mouse_X,mouse_Y,mouse_Button に現在
                   のマウスカーソルの位置とボタンの状態が常に設定
                   されます。
                   また、マウスイベント割り込み (mouse_EventMask,
                   mouse_EventRoutine)も使用できます。(ただし
                   MOUSE_NOEVENT, MOUSE_BL, MOUSE_BR は使えません)

                → MOUSEX_NONE  外部マウスドライバが存在しないの
                                で、失敗
                   MOUSEX_NEC   NEC MOUSE.SYS形式のドライバを検出
                   MOUSEX_MS    MS MOUSE.COM形式のドライバを検出

                   この結果は、mouse_Type にも格納されます。

                ★ 事前に mouse_int_start 等を呼んではいけません。
                ★ この関数を実行したら、終了時にかならず
                   mousex_end を実行してください。
                ★ この関数は低レベルなぶん繁雑なので、これを呼び
                   出す簡単な mousex_istart 系もあります。


------------------------------------------------------------------------
■ ジョイスティック読み取り ■■■■■■■■■■■■■■■■■■■■■■

        ジョイスティックまたはキーボードによってリアルタイムに操
        作するための処理です。

        ●98の場合:
          以下の端子に接続されたジョイスティックに対応しています。
          ・サウンドボード(PC-9801-26/K)やこの互換ジョイスティッ
            クボード
               ポートアドレスは既定値のみ
          ・システムサコム製ジョイスティックボードSAJ-98
               ポートアドレスは 0e3e0h,0e5e0h,0e7e0h に対応
               複数存在した場合、最も小さいアドレスを使用します。
               サウンドボードと両方存在した場合、アナログモードで
               は SAJ-98 しかチェックしません。
          ・キーボードコネクタに接続し、 テンキーをエミュレーショ
            ンするもの

        ●PC/ATの場合:
          ・game portに接続されたジョイスティックに対応します。

          ・キャリブレーションは、付属の calib.exeを使うか、 その
            ソース calib.cを元にプログラムに組み込んでください。

        ●使用方法
        ・開始
        js_start(JS_NORMAL);

        ・メインループ
        esc = js_sense();       /* 読み取り */
        if ( esc ) {
            /* escキー処理 */
        }
        /* 時間のかかる処理 ( 描画や vsync_waitなど ) */
        /* ( js_analog()も時間かかります(^^; ) */
        ...
        js_sense2();            /* キーボード読み取り */
        if ( js_stat[0] & JS_UP ) {
            /* 上へ… */
        }

        ・キーアサイン
        キーボードで操作する場合、 キーの割り当ては次のようになっ
        ています。
        []で囲ってあるキーは、js_keyassignなどで変更可能です。

          player1
            スティック
               カーソルキー   テンキー   フルキー
                   ↑         7  8  9       K
                 ←  →       4     6    H     L
                   ↓         1  2  3       J

            ボタン1  ボタン2  ボタン3  ボタン4
             space    return   [shift]    [Q]

            (js_key2player(0) 実行時,デフォルト)
            ボタン1  ボタン2
              [Z]      [X]

            (js_key2player(1) 実行時)
            ボタン1  ボタン2
              [0]      [5]     (テンキー)

          player2
            スティック
                 [E]
              [S]   [F]
                 [C]

            ボタン1  ボタン2  ボタン3  ボタン4
             [GRPH]    [D]      なし     なし

------------------------------------------------------------------------
□ 構造体／グローバル変数

int js_bexist;          1=サウンドボード認識 0=無視(不在)
int js_shift;           1=全ジョイスティックはplayer2専用
int js_2player;         1=キーボードもplayer2処理を行う
unsigned js_stat[2];    ジョイスティックの状態(1P,2P)
unsigned js_saj_port;   <98> SAJ-98のポートアドレス。0なら不在

struct AT_JS_CALIBDATA {        <AT>キャリブレート情報
        char id[AT_JS_RESIDLEN];
        char filler[16-(AT_JS_RESIDLEN&15)];
        Point dmin, dmax, dcenter;      at_js_fast=1の時の値
        Point amin, amax, acenter;      at_js_fast=0の時の値
} ;

at_js_mintime           <AT>ジョイスティックの値の下限(設定)  (初
                        期値30)
at_js_maxtime           <AT>ジョイスティックの値の上限(設定)  (初
                        期値1700)
at_js_count             <AT>ジョイスティックの一定時間分のループ
                        回数(計測)
at_js_x1,at_js_y1       <AT>ジョイスティック1のx,yカウント値(計測)
at_js_x2,at_js_y2       <AT>ジョイスティック2のx,yカウント値(計測)
                        上記は、 at_js_min〜at_js_maxの間を全体と
                        して計算してください。
at_js_min               <AT>ジョイスティックの値の下限カウント(算
                        出)
at_js_max               <AT>ジョイスティックの値の上限カウント(算
                        出)

        上記、設定可能なのは、(設定)とかかれたもののみです。 しか
        も設定しても at_js_startを実行するまで反映されません。

at_js_fast              <AT>1=RTC割り込みによるバックグラウンド読
                        み取り
                            0=直接読み取り(at_js_start)
at_js_resseg            <AT>キャリブレーション常駐データのセグメ
                        ントアドレス。
                            master.h参照(^^;

------------------------------------------------------------------------
□ 定数

        ● js_start()の初期化用定数
        表記            値      意味
        JS_NORMAL       0       通常
        JS_FORCE_USE    1       サウンドボードがあることにする
        JS_IGNORE       2       サウンドボードを無視する

        ● デジタルジョイスティックおよびキーボードの状態
        表記            値      意味
        JS_UP           0x01    上が押されている
        JS_DOWN         0x02    下が押されている
        JS_LEFT         0x04    左が押されている
        JS_RIGHT        0x08    右が押されている
        JS_TRIG1        0x10    ボタン1が押されている
        JS_TRIG2        0x20    ボタン2が押されている
        JS_TRIG3        0x40    ボタン3が押されている
        JS_TRIG4        0x80    ボタン4が押されている

        ● <98>アナログジョイスティック(js_analog()の  astat[3]に
           格納)
        表記            値      意味
        JSA_A           0x80    Aボタンが押されている
        JSA_B           0x40    Bボタンが押されている
        JSA_C           0x20    Cボタンが押されている
        JSA_D           0x10    Dボタンが押されている
        JSA_E1          0x08    E1ボタンが押されている
        JSA_E2          0x04    E2ボタンが押されている
        JSA_START       0x02    STARTボタンが押されている
        JSA_SELECT      0x01    SELECTボタンが押されている

        ● キー割り当て指示対象(js_keyassign())
        表記            意味
        JS_1P1          <98>player1 ボタン1
        JS_1P2          <98>player1 ボタン2
        JS_1P3          <98>player1 ボタン3
        JS_1P4          <98>player1 ボタン4

        JS_2P1          <98>player2 ボタン1
        JS_2P2          <98>player2 ボタン2
        JS_2PRIGHT      <98>player2 →
        JS_2PLEFT       <98>player2 ←
        JS_2PDOWN       <98>player2 ↓
        JS_2PUP         <98>player2 ↑

        AT_JS_1P1       <AT>player1 ボタン1
        AT_JS_1P2       <AT>player1 ボタン2
        AT_JS_1P3       <AT>player1 ボタン3
        AT_JS_1P4       <AT>player1 ボタン4

        AT_JS_2P1       <AT>player2 ボタン1
        AT_JS_2P2       <AT>player2 ボタン2
        AT_JS_2PRIGHT   <AT>player2 →
        AT_JS_2PLEFT    <AT>player2 ←
        AT_JS_2PDOWN    <AT>player2 ↓
        AT_JS_2PUP      <AT>player2 ↑

        ● キャリブレート関係定数
        表記               意味
        AT_JS_RESID[]      <AT>キャリブレート情報のメモリブロック
                           名
        AT_JS_RESIDLEN     <AT>AT_JS_RESIDの長さ
        AT_JS_RESPARASIZE  <AT>キャリブレート情報メモリブロックの
                           パラグラフサイズ

------------------------------------------------------------------------
□ at_js_calibrate - ジョイスティックのキャリブレート

C:      void at_js_calibrate( const Point far * min, const  Point
                             far * max, const Point far * center);

        ------------------------------------------98N 98H AT DOS-
        at_js_calibrate                            ×  × ○
        -------------------------------------------<ajstart.asm>-

                ● スティックを左上に倒した時、右下に倒したとき、
                   真ん中に戻したときのそれぞれのstickのx,y値を指
                   定することで、 at_js_senseにおいてデジタル判定
                   できるようにします。
------------------------------------------------------------------------
□ at_js_get_calibrate - 常駐キャリブレート情報取得

C:      unsigned at_js_get_calibrate(void);                マクロ

        ------------------------------------------98N 98H AT DOS-
        at_js_get_calibrate                        ×  × ○
        -----------------------------------------------------<->-

                ● calib.exe を使って常駐させたキャリブレート情報
                   を検索します。

                → 0      　見つからない
                   0以外  　見つかったセグメントアドレス。
                          at_js_ressegにも同じ値が格納される。

                例: at_js_resptr参照

------------------------------------------------------------------------
□ at_js_resptr - 常駐キャリブレート構造体を得る

C:      struct AT_JS_CALIBDATA far * at_js_resptr;         マクロ

        ------------------------------------------98N 98H AT DOS-
        at_js_resptr                               ×  × ○
        -----------------------------------------------------<->-

                ● at_js_get_calibrate()によって検索されたセグメ
                   ント(at_js_resseg変数)の、offset 0から
                   AT_JS_CALIBDATA構造体があるとみなして、 ポイン
                   タを作成します。

                ★ 必ず  at_js_get_calibrate()の結果が非0である状
                   態でのみ使ってください。

                例:  キャリブレート結果を反映させたジョイスティッ
                クの初期化例

････････････････････････････････････････････････････････････････････････
  at_js_start(JS_NORMAL);
  if ( at_js_get_calibrate() ) {
    at_js_calibrate(&at_js_resptr->dmin,
                    &at_js_resptr->dmax,
                    &at_js_resptr->dcenter);
  }
････････････････････････････････････････････････････････････････････････

------------------------------------------------------------------------
□ at_js_wait - ジョイスティックのボタン待ち

C:      int at_js_wait(Point *p);

        ------------------------------------------98N 98H AT DOS-
        at_js_wait                                 ×  × ○
        -------------------------------------------<ajstart.asm>-

                ● ジョイスティックのボタンを押すまで待ち、 stick
                   のx,y値をpに格納します。これはキャリブレートさ
                   れていなくても読み取られます。

                ○ この関数は、キャリブレート画面の作成のために用
                   意しました。

------------------------------------------------------------------------
□ js_analog - アナログジョイスティック読み取り

C:      int js_analog( int player, unsigned char astat[4] );

        ------------------------------------------98N 98H AT DOS-
        js_analog                                  ○     ×
        ------------------------------------------<jsanalog.asm>-

                ● アナログジョイスティックの状態を読み取り、
                   astat[]に格納します。
                   SAJ-98とサウンドボードが両方存在する場合、
                   SAJ-98側しか検査しません。

                ← player   1 = 1P  2 = 2P
                   astat[]  格納先。
                       astat[0]  ch0の値。 0=上, 0ffh=下
                       astat[1]  ch1の値。 0=左, 0ffh=右
                       astat[2]  ch2の値。 0=上, 0ffh=下
                       astat[3]  ボタンの値。押されているとそれぞ
                                 れのビットが立つ。
                                JSA_A JSA_B  JSA_C  JSA_D  JSA_E1
                                JSA_E2 JSA_START JSA_SELECT

                → 1  読み取り成功。astatに格納した。
                   0  読み取り失敗(アナログモードジョイスティック
                      が接続されていないなど) astatは変化しません。

                ★ 前もって js_startの実行が必要です。

                ★ この関数が 1 を返したときは、 接続されているジ
                   ョイスティックがアナログモードになっているので、
                   js_senseによってジョイスティックの状態を得るこ
                   とはできなくなります。

                ★ 念のため、存在確認は数回行い、存在が確認できた
                   ら実行時はエラーを無視するようにすると無難です。

                ★ 80hがセンター(中央)ですが、 前後にある程度遊び
                   をつくっておかないと、手を離していても動いてし
                   まったりします。78h〜88hならどれも中央とするぐ
                   らいにはすべきです。
------------------------------------------------------------------------
□ js_end, at_js_end - ジョイスティック読み取り終了

C:      void js_end(void);
C:      void at_js_end(void);

        ------------------------------------------98N 98H AT DOS-
        js_end                                     ○     ＊
        ---------------------------------------------<jsend.asm>-
        at_js_end                                  ×  × ○
        -------------------------------------------<ajstart.asm>-

                ● js_start,  at_js_startで行ったリアルタイムキー
                   読み取り処理を解除します。また、キーバッファを
                   クリアします。
                ★ <AT>この関数で割り込みを解除するため、必ず実行
                   してください。

------------------------------------------------------------------------
□ js_key - (キー割り当て変更・内部関数)

C:      void js_key( unsigned func, int group, int maskbit );

        ------------------------------------------98N 98H AT DOS-
        js_key
        ---------------------------------------------<jskey.asm>-

                ● キー判定を行うコードを書き換えます。

                ← func     master.libコードセグメント内の書き換
                            えコードのオフセットアドレス
                   group    検査を行うバイトのオフセットアドレス
                   maskbit  ビットテストする値

                ・書き換え対象のコードは、 以下のようになっている
                  必要があります。

                  LABEL:  mov  AL,ES:[アドレス]
                          test AL,ビットテストする値

                ★ この関数は直接使わないでください。将来変更され
                   る可能性があります。

------------------------------------------------------------------------
□ js_key2player, at_js_key2player - キーボードでの二人操作設定

C:      void js_key2player( int flag );                    マクロ
C:      void at_js_key2player( int flag );                 マクロ

        ------------------------------------------98N 98H AT DOS-
        js_key2player                              ○  × ＊
        at_js_key2player                           ×  × ○
        ------------------------------------------------------<>-

                ● キーボードでの二人操作の有無を指定します。

                ← flag   1  キーボードで2人操作を行う
                          0  キーボードは1人専用

                ○ なお、この処理を実行すると、 player1のボタン1,
                   ボタン2のキーアサインを以下のように強制設定し
                   ます。

                    flag  ボタン1  ボタン2   備考
                     0       Z        X      デフォルト
                     1       0        5      テンキーのみ

                ○ js_2player 変数に、 flagの値をそのまま設定しま
                   す。

------------------------------------------------------------------------
□ js_keyassign - キー割当変更

C:      void js_keyassign( unsigned func, int group, int  maskbit
                          );                               マクロ

        ------------------------------------------98N 98H AT DOS-
        js_keyassign                               ○  × ○
        -----------------------------------------------------<->-

                ● キー割り当てを変更します。

                ← func     変更対象の操作
                      <98>        <AT>
                      JS_1P1      AT_JS_1P1     player1 ボタン1
                      JS_1P2      AT_JS_1P2     player1 ボタン2
                      JS_1P3      AT_JS_1P3     player1 ボタン3
                      JS_1P4      AT_JS_1P4     player1 ボタン4

                      JS_2P1      AT_JS_2P1     player2 ボタン1
                      JS_2P2      AT_JS_2P2     player2 ボタン2
                      JS_2PRIGHT  AT_JS_2PRIGHT player2 →
                      JS_2PLEFT   AT_JS_2PLEFT  player2 ←
                      JS_2PDOWN   AT_JS_2PDOWN  player2 ↓
                      JS_2PUP     AT_JS_2PUP    player2 ↑

                   group    検査するキーグループ
                   maskbit  検査するビット 0x01〜0x80

                ○ キーグループなどは、…調べてください(ぐえ)
                ★ 98とATでは、group, maskbitの値が異なります。注
                   意してください。場合によっては、以下のように場
                   合分けしてください。
                #if MASTER98
                 js_keyassign(JS_1P1,9,0x40);
                #endif
                #if MASTERV
                 js_keyassign(AT_JS_1P1,10,0x04);
                #endif

------------------------------------------------------------------------
□ js_sense, at_js_sense - 現在のジョイスティック状態の取得

C:      int js_sense(void);

        ------------------------------------------98N 98H AT DOS-
        js_sense                                   ○     ＊
        ------------------------------------------<jsssense.asm>-
        at_js_sense                                ×  × ○
        -------------------------------------------<ajstart.asm>-

                ● デジタルジョイスティックおよびキーボードの状態
                   を js_stat[]に格納します。

                → ESCキーの状態
                     0以外 押されている
                     0     押されていない

                ○ また、js_stat[0]に以下のビットの組み合わせが設
                   定されます。
                   JS_UP        上が押されている
                   JS_DOWN      下が押されている
                   JS_LEFT      左が押されている
                   JS_RIGHT     右が押されている
                   JS_TRIG1     Aボタンが押されている
                   JS_TRIG2     Bボタンが押されている
                   JS_IRST1     (SHIFTキー)が押されている
                   JS_IRST2     (Qキー)が押されている

                ★ <AT>at_js_calibrate によりキャリブレートされて
                   いなければジョイスティックは読み取りません。

------------------------------------------------------------------------
□ js_sense2 - ジョイスティック読み取り補助

C:      int js_sense2(void);

        ------------------------------------------98N 98H AT DOS-
        js_sense2                                  ○     ＊
        ------------------------------------------<jsssense.asm>-

                ● キーボードの状態によって js_stat[]を修正します。
                   js_sense()から 1〜数十ms遅らせてこの関数を実行
                   することによってキーボードリピートを無視するこ
                   とができます。

                → ESCキーの状態
                     0以外 押されている
                     0     押されていない

------------------------------------------------------------------------
□ js_start, at_js_start - ジョイスティック読み取り開始

C:      int js_start( int force );
C:      int at_js_start( int force );

        ------------------------------------------98N 98H AT DOS-
        js_start                                   ○     ＊
        -------------------------------------------<jsstart.asm>-
        at_js_start                                ×  × ○
        -------------------------------------------<ajstart.asm>-

                ● <98>ジョイスティック関連の変数を初期設定します。
                ● <AT>キーボードハードウェア割り込みをフックして、
                   リアルタイムスキャンを可能にします。at_js_fast
                   変数が1であれば、 joystickを高速に読み取るため
                   にRTC割り込みもフックします。

                ← force
                     JS_NORMAL     通常(Joy Stick 存在検査する)
                     JS_FORCE_USE  <98>サウンドボードがあることに
                                   する(ないのに使うと暴走するか
                                   も)
                                   <AT>Joy  Stickの存在を検査しな
                                   い
                     JS_IGNORE     <98>サウンドボードを無視する
                                   (SAJ-98だけ使いたいとか)
                                   <AT>Joy  Stickの存在を検査しな
                                   い

                → 0  キーボードのみ
                   1  <98>サウンドボードを認識した
                      <AT>ジョイスティックを認識した
                   2  <98>SAJ-98を認識した

                ★ <98>SAJ-98が存在する場合、常にSAJ-98だけを認識
                   します。

                ○ <AT>動作環境の速度にもとづいて at_js_count  を
                   設定します。
                ○ <AT>at_js_mintime,at_js_maxtimeにもとづいて
                   at_js_min,at_js_maxを設定します。
                ○ <AT>キーボード割り込み(INT  09h),  RTC割り込み
                   (INT 70h)を使用しています。

                ★ <AT>終了時は必ず at_js_end を実行してください。
                   そうしないと暴走します。
                ★ <AT>at_js_fast変数が1 だと、DOS  BOX内では動作
                   しません。


------------------------------------------------------------------------
■ テキスト画面 ■■■■■■■■■■■■■■■■■■■■■■■■■■■■


------------------------------------------------------------------------
■ PC/AT 画面モード制御 ■■■■■■■■■■■■■■■■■■■■■■■■

        PC/AT には、ビデオモードが多数存在します。 目的に応じて切
        り替える必要があるため、基本的な制御関数を用意しました。

------------------------------------------------------------------------
□ 構造体／グローバル変数

        ● VIDEO_STATE構造体
           (backup_video_state,restore_video_state)
typedef struct VIDEO_STATE VIDEO_STATE ;
struct VIDEO_STATE {
        unsigned mode;          現在のビデオ・モード
        unsigned rows;          現在の１画面の行数
        unsigned cols;          現在の１行あたりの桁数
        unsigned total_rows;    現在の画面全体の行数
};

------------------------------------------------------------------------
□ backup_video_state - 復元を前提としたビデオモード取得

C:      void backup_video_state( VIDEO_STATE * vmode );

        ------------------------------------------98N 98H AT DOS-
        backup_video_state                         ×  × ○
        ------------------------------------------<getvstat.asm>-

                ● 現在のビデオモード、画面桁数、行数、フォントの
                   大きさを VIDEO_STATE構造体に格納します。

                ★ get_machineを事前に実行する必要があります。

------------------------------------------------------------------------
□ get_video_mode - ビデオモードの取得

C:      unsigned get_video_mode(void);

        ------------------------------------------98N 98H AT DOS-
        get_video_mode                             ×  × ○
        ------------------------------------------<getvideo.asm>-

                ● 現在のビデオモードを取得します

                → 現在のビデオモード値

                ○ 現在DOSが英語モードである場合は、最初にVESA
                   video   biosによって取得し、  失敗したら通常の
                   video biosで取得します。
                ○ 日本語モードである場合は、通常の video  biosで
                   のみ取得します。

                ★ get_machineを事前に実行する必要があります。

------------------------------------------------------------------------
□ restore_video_state - ビデオモードの復元

C:      int restore_video_state( const VIDEO_STATE * vmode );

        ------------------------------------------98N 98H AT DOS-
        restore_video_state                        ×  × ○
        ------------------------------------------<setvstat.asm>-

                ● ビデオモード、 VIDEO_STATE構造体の内容で再設定
                   します。

                ★ get_machineを事前に実行する必要があります。

------------------------------------------------------------------------
□ set_video_mode - ビデオモードの設定

C:      int set_video_mode( unsigned video );

        ------------------------------------------98N 98H AT DOS-
        set_video_mode                             ×  × ○
        ------------------------------------------<setvideo.asm>-

                ● ビデオモードを設定します。現在は各種グローバル
                   変数には手を付けません。

                ← video  ビデオモード値

                → 1   成功
                   0   失敗

                ○ ビデオモード値が 100h以上である場合、VESA
                   video bios function を用いて設定します。

                ★ get_machineを事前に実行する必要があります。


------------------------------------------------------------------------
■ テキスト画面操作 ■■■■■■■■■■■■■■■■■■■■■■■■■■

        テキスト画面関連の操作をします。
        <98>ハイレゾモードでも動作するプログラムを作成する場合は、
        必ず text_start() を最初に呼び出してください。

        <AT>あらかじめテキストモードにするか、 16色グラフィックモ
        ードで  vtextx_start を実行する必要が有ります。そうしない
        と表示されません。
        <AT>DOS/Vでは、 3バイト属性モードには対応していないので、
        注意してください。 また、文字属性は、98での文字属性と異な
        ります。98での属性のイメージで処理したい場合は、 変換関数
        vtext_color_98()を利用してください。

        <AT>ここで説明する関数は、事前に get_machine()と
        vtext_start()が実行されてなければ正常に動作しないものが数
        多くあります。

------------------------------------------------------------------------
□ 構造体／グローバル変数

unsigned TextVramSeg;   　テキスト画面の先頭セグメントアドレス。
                        初期値は0xA000 になっています。
                        <98>この値を変更することによりハイレゾや、
                        ２ページ目をアクセスすることができます。
                        また、仮想VRAMを使うこともできます。(属性
                        の開始アドレスはoffset  2000hからに固定な
                        ので注意してください)

void far * TextVramAdr; 　テキスト画面の VRAM の先頭アドレス。 セ
                        グメント部分は  TextVramSeg の別名(エイリ
                        アス)になっていますので、変更すると両方が
                        変更されることになります。 オフセット部分
                        は、初期値 0 になっています。ただし text_
                        で始まる関数はこのオフセット値を見ていま
                        せんので、変更するのではなく、far  ポイン
                        タとして参照するときに利用することになり
                        ます。

int TextShown ;         　テキスト画面の表示状態を保持します。 初
                        期値は 1 で、「表示」です。非表示にすると
                        0を格納します。

unsigned VTextState;    bit15:  1=グラフィックモード
                                0=テキストモード
                        bit14:  1=テキストグラフィックモード
                                (vtextx_startが実行された状態)
                        bit0:   1=書き込み時更新しない
                                0=書き込み時更新する
unsigned TextVramWidth; 現在のテキスト画面の桁数(vtext_start())
                        初期値=80
unsigned TextVramSize;  テキスト画面全体の文字数(vtext_start())
                        初期値=4000

char vtext_colortable[16];      vtextx:  16色のカラーコードからグ
                                         ラフィックの色に変換する
                                         テーブル。vtextx_start参
                                         照


------------------------------------------------------------------------
□ 定数

        ● 98テキスト属性定数
        表記            値      意味
        TX_BLACK        0x01    黒
        TX_BLUE         0x21    青
        TX_RED          0x41    赤
        TX_MAGENTA      0x61    マゼンタ
        TX_GREEN        0x81    緑
        TX_CYAN         0xa1    シアン
        TX_YELLOW       0xc1    黄色
        TX_WHITE        0xe1    白

        TX_BLINK        2       点滅
        TX_REVERSE      4       反転
        TX_UNDERLINE    8       下線

        ● <98>テキスト画面セグメント定数
        表記            値      意味
        TX_PAGE0        0xa000  ノーマルモード先頭頁
        TX_PAGE1        0xa100  ノーマルモード第2頁

------------------------------------------------------------------------
□ text_20line - 20行モードにする

C:      void text_20line(void);

        ------------------------------------------98N 98H AT DOS-
        text_20line                                ○  × ×
        ---------------------------------------------<txesc.asm>-

                ● テキスト画面を 20行表示モードにします。(通常時)
                   30行BIOS 常駐時は、行間あきモードになります。
                   ハイレゾモードでは使えません。

                ★ int 29h(高速コンソール出力)を使用しています。

------------------------------------------------------------------------
□ text_25line - 25行モードにする

C:      void text_25line(void);

        ------------------------------------------98N 98H AT DOS-
        text_25line                                ○  ○ ×
        ---------------------------------------------<txesc.asm>-

                ● テキスト画面を 25行表示モードにします。(通常時)
                   30行BIOS 常駐時は、行間なしモードになります。

                ★ int 29h(高速コンソール出力)に、ESCシーケンスを
                   出力することで実現しています。

------------------------------------------------------------------------
□ text_accesspage - テキスト画面のアクセスページを設定する

C:      void text_accesspage( int page);                   マクロ

        ------------------------------------------98N 98H AT DOS-
        text_accesspage                            ○  × ×
        -----------------------------------------------------<->-

                ● TextVramSegの値を変更することにより、 アクセス
                   ページを設定します。

                ← page  0(通常)または1(裏)

                ★ master.libの text_* および gaiji_*  関数にのみ
                   効果があります。

------------------------------------------------------------------------
□ text_backup, vtext_backup - テキスト画面の保存

C:      int text_backup( int use_main );
C:      int vtext_backup( int use_main );

        ------------------------------------------98N 98H AT DOS-
        text_backup                                ○     ＊ ５
        ------------------------------------------<txbackup.asm>-
        vtext_backup                               ×  × ○
        ------------------------------------------<vtbackup.asm>-

                ● <98>テキスト画面の内容、カーソルの位置、ファン
                   クションキー表示行の表示状態をEMSまたはメイン
                   メモリの上位に退避先を確保して保存します。
                   <AT>ビデオモード、テキスト画面の内容、カーソル
                   の位置、 カーソルの形状をEMSまたはメインメモリ
                   の上位に退避先を確保して保存します。

                   　一度保存されている場合、text_restore  を実行
                   せずに再び  text_backup を実行しようとすると必
                   ず失敗になります。
                   　ems_exist()は、 内部で呼んでいるのであらかじ
                   め呼んでおく必要はありません。

                ← use_main = 0  EMSへの保存が失敗したら、失敗
                              1  〃、メインメモリ(hmem_alloc())で
                                 再挑戦

                → 1 成功
                   0 失敗

                △MEMORY: メインメモリ使用時、 次のような大きさの
                  ブロックを確保します。
                          <98>1024パラグラフ(=16KB)のブロックを確
                          保します。
                          <AT>テキスト画面の文字数に応じた大きさ
                          (80x25文字表示の時は256パラグラフ=4KB)
                          のブロックを確保します。

                ○ <AT>事前に vtext_start()が実行されている必要が
                   あります
                ○ <AT>内部で get_machine()を呼び出しています。

------------------------------------------------------------------------
□ text_boxfilla, vtext_boxfilla - 指定範囲の文字属性変更

C:      void text_boxfilla( unsigned x1, unsigned y1,
                           unsigned x2, unsigned y2, unsigned atrb );
C:      void vtext_boxfilla( unsigned x1, unsigned y1,
                            unsigned x2, unsigned y2, unsigned atrb );

        ------------------------------------------98N 98H AT DOS-
        text_boxfilla                              ○  ○ ＊
        ------------------------------------------<txboxfla.asm>-
        vtext_boxfilla                             ×  × ○
        ------------------------------------------<vtboxfla.asm>-

                ● (x1,y1)を左上隅、(x2,y2)を右下隅とする長方形の
                   領域を、指定属性に変更します。

                ← x1,y1  左上角の座標 (x1 + 2 ≦ x2 かつ y1 +  2
                          ≦ y2 であること)
                   x2,y2  右下角の座標
                   atrb   <98>文字属性
                   atrb   <AT>上位8bit:  現在の画面の属性に対する
                                         ANDマスク
                              下位8bit:  現在の画面の属性に対する
                                         XORマスク
                          ・00h〜0ffhの属性を書くだけなら通常の属
                            性として処理します。
                          ・0ff00hだと何も起こりません。
                          ・0ffffhだと全ビット反転になります。
                          ・0f007hだと、文字色のみ白にします。

                ○ <AT>事前に vtext_start()が実行されている必要が
                   あります
                ○ <AT>vtext_refresh_on()/vtext_refresh_off()に影
                   響を受けます

------------------------------------------------------------------------
□ text_cemigraph - セミグラフィックを有効にする

C:      void text_cemigraph(void);                         マクロ

        ------------------------------------------98N 98H AT DOS-
        text_cemigraph                             ○  × ＊
        -----------------------------------------------------<->-

                ● テキスト画面のセミグラフィック表示機能を有効に
                   します。
                ★ ハイレゾモードではセミグラフィック表示にはなら
                   ず、常に縦線になります。

------------------------------------------------------------------------
□ text_clear, vtext_clear - テキスト画面の消去

C:      void text_clear(void);
C:      void vtext_clear(void);

        ------------------------------------------98N 98H AT DOS-
        text_clear                                        ＊ ○
        -------------------------------------------<txclear.asm>-
        vtext_clear                                ×  × ○
        -------------------------------------------<vtclear.asm>-

                ● <98>高速コンソール出力(INT 29h)に、ANSI  ESCシ
                   ーケンスの  ESC [2J を出力することによりテキス
                   ト画面を消去します。
                   <AT>テキスト画面を消去します。グラフィックモー
                   ドになっていると何も行いません。

                ○ <AT>事前に vtext_start(),  get_machine()が実行
                   されている必要があります
                ○ <AT>vtext_refresh_on()/vtext_refresh_off()に影
                   響を受けます

------------------------------------------------------------------------
□ text_cursor_hide, vtext_cursor_hide - カーソルを消す

C:      void text_cursor_hide(void);
C:      void vtext_cursor_hide(void);                      マクロ

        ------------------------------------------98N 98H AT DOS-
        text_cursor_hide                                  ＊ ○
        ---------------------------------------------<txesc.asm>-
        vtext_cursor_hide                          ×  × ○
        -----------------------------------------------------<->-

                ● テキストカーソルを消します。

                ○ <98> int  29h(高速コンソール出力)にESCシーケン
                   スを出力します。
                ○ <AT> BIOSを使います。

                ○ 参照:  text_cursor_show(), text_cursor_shown(),
                          vtext_cursor_show(),
                          vtext_cursor_shown()

------------------------------------------------------------------------
□ _text_cursor_off - BIOSを使用してカーソルを消す

C:      void _text_cursor_off(void);

        ------------------------------------------98N 98H AT DOS-
        _text_cursor_off                           ○     ＊
        ------------------------------------------<txcursor.asm>-

                ● BIOS ( int 18h)  を利用してカーソル表示を  off
                   にします。

                ★ text_cursor_hide()などはint  29hを使用している
                   ので  MEGDOSでは使えない、という場合にも使えま
                   す。

------------------------------------------------------------------------
□ _text_cursor_on - BIOSを使用してカーソルを表示

C:      void _text_cursor_on(void);

        ------------------------------------------98N 98H AT DOS-
        _text_cursor_on                            ○     ＊
        ------------------------------------------<txcursor.asm>-

                ● BIOS ( int 18h) を利用してカーソル表示を on に
                   します。

------------------------------------------------------------------------
□ text_cursor_show, vtext_cursor_show - カーソルを表示する

C:      void text_cursor_show(void);
C:      void vtext_cursor_show(void);                      マクロ

        ------------------------------------------98N 98H AT DOS-
        text_cursor_show                                  ＊ ○
        ---------------------------------------------<txesc.asm>-
        vtext_cursor_show                          ×  × ○
        -----------------------------------------------------<->-

                ● テキストカーソルを表示します。

                ○ <98> int  29h(高速コンソール出力)にESCシーケン
                   スを出力します。
                ○ <AT> BIOSを使います。

                ○ 参照:  text_cursor_hide(), text_cursor_shown(),
                          vtext_cursor_hide(),
                          vtext_cursor_shown()

------------------------------------------------------------------------
□ text_cursor_shown, vtext_cursor_shown - カーソルの表示状態を得る

C:      int text_cursor_shown(void);                       マクロ
C:      int vtext_cursor_shown(void);                      マクロ

        ------------------------------------------98N 98H AT DOS-
        text_cursor_shown                          ○     ＊
        vtext_cursor_shown                         ×  × ○
        -----------------------------------------------------<->-

                ● カーソルの表示状態を得ます。

                → 1  表示
                   0  非表示

                ○ <98> MS-DOSのワークエリアを参照します。
                ○ <AT> BIOSを使います。

                ○ 参照:  text_cursor_hide(), text_cursor_show(),
                          vtext_cursor_hide(), vtext_cursor_show()

------------------------------------------------------------------------
□ text_end - テキスト画面処理の終了

C:      void text_end(void);

        ------------------------------------------98N 98H AT DOS-
        text_end
        -------------------------------------------<txstart.asm>-

                ● 中身は空です(笑)

------------------------------------------------------------------------
□ text_fillca - テキスト画面の塗りつぶし

C:      void text_fillca( unsigned ch, unsigned atrb );

        ------------------------------------------98N 98H AT DOS-
        text_fillca                                ○  ○ ×
        ------------------------------------------<txfillca.asm>-

                ● テキスト画面の全体を指定文字・指定属性で塗りつ
                   ぶします。30行計画に対応しています。

------------------------------------------------------------------------
□ text_frame, vtext_frame - テキストウィンドウの描画

C:      void text_frame( int x1, int y1, int x2, int y2,
                        unsigned wattr, unsigned iattr, int round );
C:      void vtext_frame( int x1, int y1, int x2, int y2,
                         unsigned wattr, unsigned iattr, int dummy );

        ------------------------------------------98N 98H AT DOS-
        text_frame                                 ○  ○ ＊
        -------------------------------------------<txframe.asm>-
        vtext_frame                                ×  × ○
        -------------------------------------------<vtframe.asm>-

                ● テキスト画面に窓枠を書き、中を空白で塗り潰しま
                   す。

                ← x1,y1  左上角の座標 (x1 + 2 ≦ x2 かつ y1 +  2
                          ≦ y2 であること)
                   x2,y2  右下角の座標
                   wattr  窓枠の属性
                   iattr  中を塗り潰す属性
                   round  1 = 角を丸くする,  0 = 角は直角
                   dummy  意味なし(text_frameの引き数との数あわせ)

                ○ 枠の両側の縦線が、外側に漢字に半分かかっている
                   時は、(窓や右がずれないように)その漢字を空白に
                   置換えます。このため、テキストウィンドウの表示
                   の前に表示領域を待避するときには左右に一桁ずつ
                   多く待避してください。

                ★ 値範囲の検査はしていません。画面外や、x1 ≧ x2
                   や y1 ≧ y2 などの座標が設定されたときの動作は
                   異常になります。

                ★ <98>縦線/セミグラフは縦線モードに自動設定しま
                   す。

                ○ <AT>事前に vtext_start(),  get_machine()が実行
                   されている必要があります

------------------------------------------------------------------------
□ text_get, vtext_get - テキスト画面の領域保存

C:      void text_get( int x1,int y1, int x2,int y2, void far *buf );
C:      void vtext_get( int x1,int y1, int x2,int y2, void far *buf );

        ------------------------------------------98N 98H AT DOS-
        text_get                                   ○     ＊
        ------------------------------------------<txgetput.asm>-
        vtext_get                                  ×  × ○
        ------------------------------------------<vtgetput.asm>-

                ● 領域退避します。クリッピングしません。 bufには
                   あらかじめ、マクロ TX_GETSIZE(x1,y1,x2,y2)で得
                   られるバイト数の領域が必要です。

------------------------------------------------------------------------
□ text_getcurpos, vtext_getcurpos - カーソル位置を得る

C:      long text_getcurpos(void);
C:      long vtext_getcurpos(void);

        ------------------------------------------98N 98H AT DOS-
        text_getcurpos                             ○     ＊ ５
        ------------------------------------------<txgetcps.asm>-
        vtext_getcurpos                            ×  × ○
        ------------------------------------------<vtgetcps.asm>-

                ● カーソル位置を得ます。

                → 下位16bit  x座標( 0 = 左端 )
                   上位16bit  y座標( 0 = 上端 )

------------------------------------------------------------------------
□ text_height, vtext_height - テキスト画面の行数を得る

C:      int text_height(void);
C:      int vtext_height(void);

        ------------------------------------------98N 98H AT DOS-
        text_height                                ○     ＊
        ---------------------------------------------<txesc.asm>-
        vtext_height                               ×  × ○
        ---------------------------------------------<vtesc.asm>-

                ● <98>テキスト画面の、ファンクションキー表示によ
                   って隠されていない部分の行数を得ます。
                   　25行表示モードならば、 25または24(ファンクシ
                   ョンキー表示があるとき)が得られます。

                   <AT>BIOSのワークエリアを参照して、テキスト画面
                   の行数を得ます。

                ○ 参照:  text_width(), vtext_width()

------------------------------------------------------------------------
□ text_hide - テキスト画面の表示を隠す

C:      void text_hide(void);

        ------------------------------------------98N 98H AT DOS-
        text_hide                                  ○     ×
        --------------------------------------------<txhide.asm>-

                ● CRT BIOSを用いてテキスト画面の表示を隠します。

                ○ 同時に TextShown変数に 0を格納します。

------------------------------------------------------------------------
□ text_locate, vtext_locate - カーソル位置の変更

C:      void text_locate( unsigned x, unsigned y );
C:      void vtext_locate( unsigned x, unsigned y );

        ------------------------------------------98N 98H AT DOS-
        text_locate                                ○     ＊
        ------------------------------------------<txlocate.asm>-
        vtext_locate                               ×  × ○
        ------------------------------------------<vtlocate.asm>-

                ● <98>NEC MS-DOS拡張ファンクション(INT  DCh)を使
                   ってカーソル位置を変更します。
                   MS-DOSが管理するカーソル位置を、y行目(0 が上端)
                   の x桁目(0が左端)の位置に移動します。
                   <AT>BIOSを使ってカーソル位置を設定します。

                ← x,y  カーソル位置(x=0,y=0が左上)

                ○ <AT>事前に get_machine()が実行されている必要が
                   あります

------------------------------------------------------------------------
□ text_preset - セミグラフィック点消去

C:      void text_preset( int x, int y );

        ------------------------------------------98N 98H AT DOS-
        text_preset                                ○  × ×
        ------------------------------------------<txpreset.asm>-

                ● テキスト画面の指定した地点に打たれた点を消しま
                   す。点が無くなった場合、またはそこに文字が書か
                   れている場合、 その地点は文字の空白(コード0)に
                   置き換えます。

                ← x    0〜159 点を消す横位置
                   y    0〜99(25行の時) 点を消す縦位置

                ★ これを実行する前に必ず一度は  text_cemigraph()
                   を実行してください。
                ★ xが範囲外のとき、および  yが負数の時は実行しま
                   せん。 ただしyが画面を下にはみ出た指定をすると
                   誤動作します。

------------------------------------------------------------------------
□ text_pset - セミグラフィック点描画(属性なし)

C:      void text_pset( int x, int y );

        ------------------------------------------98N 98H AT DOS-
        text_pset                                  ○  × ×
        --------------------------------------------<txpset.asm>-

                ● テキスト画面の指定した地点に点を打ちます。文字
                   が書かれた地点を指定すると、その文字を消して新
                   たに点を打ちます。テキスト属性は変化しません。

                ← x    0〜159 点を打つ横位置
                   y    0〜99(25行の時) 点を打つ縦位置

                ★ これを実行する前に必ず一度は  text_cemigraph()
                   を実行してください。
                ★ xが範囲外のとき、および  yが負数の時は実行しま
                   せん。 ただしyが画面を下にはみ出た指定をすると
                   誤動作します。

------------------------------------------------------------------------
□ text_pseta - セミグラフィック点描画(属性つき)

C:      void text_pseta( int x, int y, unsigned atr );

        ------------------------------------------98N 98H AT DOS-
        text_pseta                                 ○  × ×
        -------------------------------------------<txpseta.asm>-

                ● テキスト画面の指定した地点に指定した属性で点を
                   打ちます。文字が書かれた地点を指定すると、その
                   文字を消して新たに点を打ちます。

                ← x    0〜159 点を打つ横位置
                   y    0〜99(25行の時) 点を打つ縦位置
                   atr  打つ点のテキスト属性

                ★ これを実行する前に必ず一度は  text_cemigraph()
                   を実行してください。
                ★ xが範囲外のとき、および  yが負数の時は実行しま
                   せん。 ただしyが画面を下にはみ出た指定をすると
                   誤動作します。

------------------------------------------------------------------------
□ text_put, vtext_put - テキスト画面の領域復元

C:      void text_put( int x1,int y1, int x2,int y2, const void far *buf );
C:      void vtext_put( int x1,int y1, int x2,int y2, const void far *buf );

        ------------------------------------------98N 98H AT DOS-
        text_put                                   ○     ＊
        ------------------------------------------<txgetput.asm>-
        vtext_put                                  ×     ○
        ------------------------------------------<vtgetput.asm>-

                ● text_get()で退避された内容を画面に書き込みます。
                   bufの開放は行いません（何度でも同じ内容で
                   text_putできます）。

------------------------------------------------------------------------
□ text_putc, vtext_putc - 文字の書き込み(属性無し)

C:      void text_putc( unsigned x, unsigned y, unsigned ch );
C:      void vtext_putc( unsigned x, unsigned y, unsigned ch );

        ------------------------------------------98N 98H AT DOS-
        text_putc                                  ○  ○ ＊
        --------------------------------------------<txputc.asm>-
        vtext_putc                                 ×  × ○
        --------------------------------------------<vtputc.asm>-

                ● テキスト画面の y行目(0 が一番上)の x桁目(0  が
                   一番左)の地点に、文字を直接書き込みます。
                   　chには、ANKの他にJISコードまたはSHIFT  JISコ
                   ードで全角文字が指定できます。
                   　漢字半角には対応していません。
                   　書き込む地点の色、属性は変化しません。

                ★ 画面外を指定すると、関係ないメモリ内容を破壊す
                   ることになるかもしれません。

                ○ <AT>事前に vtext_start()が実行されている必要が
                   あります
                ○ <AT>vtext_refresh_on()/vtext_refresh_off()に影
                   響を受けます

------------------------------------------------------------------------
□ text_putca, vtext_putca - 文字の書き込み(属性あり)

C:      void text_putca( unsigned x, unsigned y, unsigned ch, unsigned atrb );
C:      void vtext_putca( unsigned x, unsigned y, unsigned ch, unsigned atrb );

        ------------------------------------------98N 98H AT DOS-
        text_putca                                 ○  ○ ＊
        -------------------------------------------<txputca.asm>-
        vtext_putca                                ×  × ○
        -------------------------------------------<vtputca.asm>-

                ● テキスト画面の y行目(0 が一番上)の x桁目(0  が
                   一番左)の地点に、 属性atrbで文字を直接書き込み
                   ます。
                   　chには、ANKの他にJISコードまたはSHIFT  JISコ
                   ードで全角文字が指定できます。
                   　漢字半角には対応していません。

                ★ 画面外を指定すると、関係ないメモリ内容を破壊す
                   ることになるかもしれません。

                ○ <AT>事前に vtext_start(),  get_machine()が実行
                   されている必要があります
                ○ <AT>vtext_refresh_on()/vtext_refresh_off()に影
                   響を受けます

------------------------------------------------------------------------
□ text_putnp - 文字数指定のパスカル文字列の書き込み(属性無し)

C:      void text_putnp( unsigned x, unsigned y,
                        const char *passtr, unsigned wid );

        ------------------------------------------98N 98H AT DOS-
        text_putnp                                 ○  ○ ×
        -------------------------------------------<txputnp.asm>-

                ● text_putnsの、パスカル文字列版です。

------------------------------------------------------------------------
□ text_putnpa - 文字数指定のパスカル文字列の書き込み(属性あり)

C:      void text_putnpa( unsigned x, unsigned y,
                         const char *passtr, unsigned wid, unsigned atrb );

        ------------------------------------------98N 98H AT DOS-
        text_putnpa                                ○  ○ ×
        ------------------------------------------<txputnpa.asm>-

                ● text_putnsa のパスカル文字列版です。

------------------------------------------------------------------------
□ text_putns, vtext_putns - 文字数指定の文字列の書き込み(属性無し)

C:      void text_putns( unsigned x, unsigned y,
                        const char * str, unsigned wid );
C:      void vtext_putns( unsigned x, unsigned y,
                         const char * str, unsigned wid );

        ------------------------------------------98N 98H AT DOS-
        text_putns                                 ○  ○ ＊
        -------------------------------------------<txputns.asm>-
        vtext_putns                                ×  × ○
        -------------------------------------------<vtputns.asm>-

                ● テキスト画面の y行目(0 が一番上)の x桁目(0  が
                   一番左)から、 wid 桁(1で半角1文字分)の領域に文
                   字列を直接書き込みます。
                   文字列が wid桁を超える場合、 wid桁以内に収まる
                   最終文字まで書き込み、余った桁は空白で埋めます。
                   書き込む地点の色、属性は変化しません。

                ★ 画面外を指定すると、関係ないメモリ内容を破壊す
                   ることになるかもしれません。

                ○ <AT>事前に vtext_start()が実行されている必要が
                   あります
                ○ <AT>vtext_refresh_on()/vtext_refresh_off()に影
                   響を受けます

------------------------------------------------------------------------
□ text_putnsa, vtext_putnsa - 文字数指定の文字列の書き込み(属性あり)

C:      void text_putnsa( unsigned x, unsigned y,
                         const char * str, unsigned wid, unsigned atrb );
C:      void vtext_putnsa( unsigned x, unsigned y,
                          const char * str, unsigned wid, unsigned atrb );

        ------------------------------------------98N 98H AT DOS-
        text_putnsa                                ○  ○ ＊
        ------------------------------------------<txputnsa.asm>-
        vtext_putnsa                               ×  × ○
        ------------------------------------------<vtputnsa.asm>-

                ● テキスト画面の y行目(0 が一番上)の x桁目(0  が
                   一番左)から、wid桁(1で半角1文字分)の領域に文字
                   列を属性atrbで直接書き込みます。
                   　文字列が wid 桁を超える場合、wid桁以内に収ま
                   る最終文字まで書き込み、余った桁は空白で埋めま
                   す。

                ★ 画面外を指定すると、関係ないメモリ内容を破壊す
                   ることになるかもしれません。

                ○ <AT>事前に vtext_start()が実行されている必要が
                   あります
                ○ <AT>vtext_refresh_on()/vtext_refresh_off()に影
                   響を受けます

------------------------------------------------------------------------
□ text_putp - パスカル文字列の書き込み(属性無し)

C:      void text_putp( unsigned x, unsigned y, const char *passtr );

        ------------------------------------------98N 98H AT DOS-
        text_putp                                  ○  ○ ×
        --------------------------------------------<txputp.asm>-

                ● text_puts のパスカル文字列版です。ただし、最後
                   の文字が漢字１バイト目だったときには、そのコー
                   ドを１バイト文字として書き込みます。

------------------------------------------------------------------------
□ text_putpa - パスカル文字列の書き込み(属性あり)

C:      void text_putpa( unsigned x, unsigned y,
                        const char * str, unsigned atrb );

        ------------------------------------------98N 98H AT DOS-
        text_putpa                                 ○  ○ ×
        -------------------------------------------<txputpa.asm>-

                ● text_putsaのパスカル文字列版です。ただし、最後
                   の文字が漢字１バイト目だったときには、そのコー
                   ドを１バイト文字として書き込みます。

------------------------------------------------------------------------
□ text_puts, vtext_puts - 文字列の書き込み(属性無し)

C:      void text_puts( unsigned x, unsigned y, const char * str );
C:      void vtext_puts( unsigned x, unsigned y, const char * str );

        ------------------------------------------98N 98H AT DOS-
        text_puts                                  ○  ○ ＊
        --------------------------------------------<txputs.asm>-
        vtext_puts                                 ×  × ○
        --------------------------------------------<vtputs.asm>-

                ● テキスト画面の y行目(0 が一番上)の x桁目(0  が
                   一番左)からの領域に文字列を直接書き込みます。
                   　書き込む地点の色、属性は変化しません。

                ★ 画面外を指定すると、関係ないメモリ内容を破壊す
                   ることになるかもしれません。
                ★ <98>最後の文字が漢字１バイト目で終っている場合、
                   00hをみつけるまで走りつづけます。

                ○ <AT>事前に vtext_start(),  get_machine()が実行
                   されている必要があります
                ○ <AT>vtext_refresh_on()/vtext_refresh_off()に影
                   響を受けます

------------------------------------------------------------------------
□ text_putsa, vtext_putsa - 文字列の書き込み(属性あり)

C:      void text_putsa( unsigned x, unsigned y,
                        const char * str, unsigned atrb );
C:      void vtext_putsa( unsigned x, unsigned y,
                         const char * str, unsigned atrb );

        ------------------------------------------98N 98H AT DOS-
        text_putsa                                 ○  ○ ＊
        -------------------------------------------<txputsa.asm>-
        vtext_putsa                                ×  × ○
        -------------------------------------------<vtputsa.asm>-

                ● テキスト画面の y行目(0 が一番上)の x桁目(0  が
                   一番左)からの領域に文字列を属性atrbで直接書き
                   込みます。

                ★ 画面外を指定すると、関係ないメモリ内容を破壊す
                   ることになるかもしれません。
                ★ <98>最後の文字が漢字１バイト目で終っている場合、
                   00hをみつけるまで走りつづけます。

                ○ <AT>事前に vtext_start(),  get_machine()が実行
                   されている必要があります
                ○ <AT>vtext_refresh_on()/vtext_refresh_off()に影
                   響を受けます

------------------------------------------------------------------------
□ text_restore, vtext_restore - テキスト画面の復元

C:      int text_restore(void);
C:      int vtext_restore(void);

        ------------------------------------------98N 98H AT DOS-
        text_restore                               ○     ＊ ５
        ------------------------------------------<txbackup.asm>-
        vtext_restore                              ×  × ○
        ------------------------------------------<vtbackup.asm>-

                ● text_backup, vtext_backup で退避したテキスト画
                   面情報を復元し、保存に使っていたメモリを開放し
                   ます。

                → 1 成功
                   0 失敗(まだ保存されていないなど)

------------------------------------------------------------------------
□ text_roll_area - スクロール範囲の指定

C:      void text_roll_area( int x1, int y1, int x2, int y2 );

        ------------------------------------------98N 98H AT DOS-
        text_roll_area                             ○     ○
        ------------------------------------------<txrlarea.asm>-

                ● text_roll_*系関数でスクロールする範囲を指定し
                   ます。
                ★ クリッピングは行っていません。

------------------------------------------------------------------------
□ text_roll_down_c, vtext_roll_down_c - 下スクロール(属性なし)

C:      void text_roll_down_c( unsigned fillchar );
C:      void vtext_roll_down_c( unsigned fillchar );

        ------------------------------------------98N 98H AT DOS-
        text_roll_down_c                           ○     ＊
        -------------------------------------------<txrldwc.asm>-
        vtext_roll_down_c                          ×  × ○
        -------------------------------------------<vtrldwc.asm>-

                ● text_roll_area()によって設定された範囲を下にス
                   クロールします。
                   属性領域はスクロールしません。
                ← fillchar  新しく現れた部分を埋める文字

                ★ fillchar に全角文字は指定できません。

                ○ <AT>事前に vtext_start()が実行されている必要が
                   あります
                ○ <AT>vtext_refresh_on()/vtext_refresh_off()に影
                   響を受けます

------------------------------------------------------------------------
□ text_roll_down_ca, vtext_roll_down_ca - 下スクロール(属性つき)

C:      void text_roll_down_ca( unsigned fillchar, unsigned filatr );
C:      void vtext_roll_down_ca( unsigned fillchar, unsigned filatr );

        ------------------------------------------98N 98H AT DOS-
        text_roll_down_ca                          ○     ＊
        ------------------------------------------<txrldwca.asm>-
        vtext_roll_down_ca                         ×  × ○
        ------------------------------------------<vtrldwca.asm>-

                ● text_roll_area()によって設定された範囲を下にス
                   クロールします。
                   属性領域もスクロールします。

                ← fillchar  新しく現れた部分を埋める文字
                   fillatr   〃 属性

                ★ fillchar に全角文字は指定できません。

                ○ <AT>事前に vtext_start()が実行されている必要が
                   あります
                ○ <AT>vtext_refresh_on()/vtext_refresh_off()に影
                   響を受けます

------------------------------------------------------------------------
□ text_roll_left_c - 左スクロール(属性なし)

C:      void text_roll_left_c( unsigned fillchar );

        ------------------------------------------98N 98H AT DOS-
        text_roll_left_c                           ○     ×
        -------------------------------------------<txrllec.asm>-

                ● text_roll_area()によって設定された範囲を左にス
                   クロールします。
                   属性領域はスクロールしません。

                ← fillchar  新しく現れた部分を埋める文字

                ★ fillchar に全角文字は指定できません。

------------------------------------------------------------------------
□ text_roll_left_ca - 左スクロール(属性つき)

C:      void text_roll_left_ca( unsigned fillchar, unsigned filatr );

        ------------------------------------------98N 98H AT DOS-
        text_roll_left_ca                          ○     ×
        ------------------------------------------<txrlleca.asm>-

                ● text_roll_area()によって設定された範囲を左にス
                   クロールします。
                   属性領域もスクロールします。

                ← fillchar  新しく現れた部分を埋める文字
                   fillatr   〃 属性

                ★ fillchar に全角文字は指定できません。

------------------------------------------------------------------------
□ text_roll_right_c - 右スクロール(属性なし)

C:      void text_roll_right_c( unsigned fillchar );

        ------------------------------------------98N 98H AT DOS-
        text_roll_right_c                          ○     ×
        -------------------------------------------<txrlric.asm>-

                ● text_roll_area()によって設定された範囲を右にス
                   クロールします。
                   属性領域はスクロールしません。
                ← fillchar  新しく現れた部分を埋める文字

                ★ fillchar に全角文字は指定できません。

------------------------------------------------------------------------
□ text_roll_right_ca - 右スクロール(属性つき)

C:      void text_roll_right_ca( unsigned fillchar, unsigned filatr );

        ------------------------------------------98N 98H AT DOS-
        text_roll_right_ca                         ○     ×
        ------------------------------------------<txrlrica.asm>-

                ● text_roll_area()によって設定された範囲を右にス
                   クロールします。
                   属性領域もスクロールします。
                ← fillchar  新しく現れた部分を埋める文字
                   fillatr   〃 属性

                ★ fillchar に全角文字は指定できません。

------------------------------------------------------------------------
□ text_roll_up_c, vtext_roll_up_c - 上スクロール(属性なし)

C:      void text_roll_up_c( unsigned fillchar );
C:      void vtext_roll_up_c( unsigned fillchar );

        ------------------------------------------98N 98H AT DOS-
        text_roll_up_c                             ○     ＊
        -------------------------------------------<txrlupc.asm>-
        vtext_roll_up_c                            ×  × ○
        -------------------------------------------<vtrlupc.asm>-

                ● text_roll_area()によって設定された範囲を上にス
                   クロールします。
                   属性領域はスクロールしません。

                ← fillchar  新しく現れた部分を埋める文字

                ★ fillchar に全角文字は指定できません。

                ○ <AT>事前に vtext_start()が実行されている必要が
                   あります
                ○ <AT>vtext_refresh_on()/vtext_refresh_off()に影
                   響を受けます

------------------------------------------------------------------------
□ text_roll_up_ca, vtext_roll_up_ca - 上スクロール(属性つき)

C:      void text_roll_up_ca( unsigned fillchar, unsigned filatr );
C:      void vtext_roll_up_ca( unsigned fillchar, unsigned filatr );

        ------------------------------------------98N 98H AT DOS-
        text_roll_up_ca                            ○     ＊
        ------------------------------------------<txrlupca.asm>-
        vtext_roll_up_ca                           ×  × ○
        ------------------------------------------<vtrlupca.asm>-

                ● text_roll_area()によって設定された範囲を上にス
                   クロールします。
                   属性領域もスクロールします。

                ← fillchar  新しく現れた部分を埋める文字
                   fillatr   〃 属性

                ★ fillchar に全角文字は指定できません。

                ○ <AT>事前に vtext_start()が実行されている必要が
                   あります
                ○ <AT>vtext_refresh_on()/vtext_refresh_off()に影
                   響を受けます

------------------------------------------------------------------------
□ text_setcursor, vtext_setcursor - カーソル形状の変更

C:      void text_setcursor( int normal );
C:      void vtext_setcursor( unsigned cursor );

        ------------------------------------------98N 98H AT DOS-
        text_setcursor                             ○  ○ ＊
        ------------------------------------------<txsetcsr.asm>-
        vtext_setcursor                            ×  × ○
        ------------------------------------------<vtsetcur.asm>-

                ● カーソルの形状を変更します。
                   <98>GDCに直接設定します。(ハイレゾではBIOSを使
                   用)カーソル位置は変化しません。
                   <AT>BIOSで変更します。

                ← normal = 0  ブロック(通常の)カーソル
                            1  下４分の１の大きさのカーソル

                   cursor = 上位8bit: カーソル開始ラスタ(0〜7)
                            下位8bit: カーソル終了ラスタ(0〜7)
                            開始ラスタ > 終了ラスタの場合は非表示

                ○ 参照:  vtext_getcursor()

------------------------------------------------------------------------
□ text_show - テキスト画面の表示

C:      void text_show(void);

        ------------------------------------------98N 98H AT DOS-
        text_show                                  ○     ×
        --------------------------------------------<txshow.asm>-

                ● CRT BIOSを用いてテキスト画面を表示させます。

                ○ 同時に TextShown変数に 1を格納します。

------------------------------------------------------------------------
□ text_shown - テキスト画面の表示状態を得る

C:      int text_shown(void);                              マクロ

        ------------------------------------------98N 98H AT DOS-
        text_shown                                 ○     ×
        -----------------------------------------------------<->-

                ● TextShown変数の内容を返します。

------------------------------------------------------------------------
□ text_showpage - テキスト画面の表示ページを設定する

C:      void text_showpage( int page );

        ------------------------------------------98N 98H AT DOS-
        text_showpage                              ○  × ×
        ------------------------------------------<txshowpg.asm>-

                ● CRT BIOSの表示領域設定を使用して、表示ページを
                   切り換えます。

                ← page  0(通常)または1(裏)

                ★ DOSを呼ぶときや、 プログラム終了前には必ず表示
                   ページを 0 に設定してください。
                ★ 30行BIOSの拡張モードになっている時は正常に動作
                   しません。 (VRAMが2頁を収納できないし)この場合
                   は、一旦 bios30_push(), bios30_setmode()を利用
                   して25行モードに設定してからこの関数を実行する
                   と良いでしょう。

------------------------------------------------------------------------
□ text_smooth - テキストスムーススクロールのシフト値を指定

C:      void text_smooth( int shiftdot );                  マクロ

        ------------------------------------------98N 98H AT DOS-
        text_smooth                                ○  × ＊
        -----------------------------------------------------<->-

                ● テキストスムーススクロール範囲にある文字を、上
                   にshiftdotドットもちあげます。 25行画面なら0〜
                   15の値を使ってください。

------------------------------------------------------------------------
□ text_smooth_end - テキストスムーススクロールの終了

C:      void text_smooth_end(void);

        ------------------------------------------98N 98H AT DOS-
        text_smooth_end                            ○  × ×
        ------------------------------------------<txsmooth.asm>-

                ● テキストスムーススクロール範囲を画面全体にし、
                   シフト値を 0にします。

------------------------------------------------------------------------
□ text_smooth_start - テキストスムーススクロール範囲の指定

C:      void text_smooth_start( unsigned y1, unsigned y2 );

        ------------------------------------------98N 98H AT DOS-
        text_smooth_start                          ○  × ×
        ------------------------------------------<txsmooth.asm>-

                ● スムーススクロールを実行する範囲を設定します。

                → y1  範囲の上の行位置(0〜y2)
                   y2  範囲の下の行位置(25行画面ならy1〜24)

------------------------------------------------------------------------
□ text_start, vtext_start - テキスト画面処理の開始

C:      void text_start(void);
C:      void vtext_start(void);

        ------------------------------------------98N 98H AT DOS-
        text_start                                 ○  ○ ＊
        -------------------------------------------<txstart.asm>-
        vtext_start                                ×  × ○ ○
        -------------------------------------------<vtstart.asm>-

                ● <98>ノーマルモードかハイレゾモードか判定して、
                   TextVramSeg に適正値を設定します。
                   <AT>テキスト処理の準備として、以下のことをしま
                   す。
                   ・TextVramWidthに現在の画面桁数を設定
                   ・TextVramSizeに桁数*行数を設定
                   ・TextVramAdrに(仮想)VRAMのアドレスを設定
                   ・仮想VRAMが存在するなら  vtext_refresh_on()、
                     存在しないなら vtext_refresh_off()を実行

                ★ <AT>事前に get_machine()  を実行する必要があり
                   ます。

------------------------------------------------------------------------
□ text_systemline_hide, vtext_systemline_hide -  画面最下行のシステムラ
   インの消去

C:      void text_systemline_hide(void);
C:      void vtext_systemline_hide(void);

        ------------------------------------------98N 98H AT DOS-
        text_systemline_hide                              ＊ ○
        ---------------------------------------------<txesc.asm>-
        vtext_systemline_hide                      ×  × ○
        ------------------------------------------<vtsyslin.asm>-

                ● <98>ESCシーケンスを利用してファンクションキー
                   表示を消します。
                   <AT>日本語入力ドライバのために最下行を予約して
                   ある場合、それを消して全画面が使えるようにしま
                   す。

                ★ <98>int  29h(高速コンソール出力)を使用していま
                   す。

------------------------------------------------------------------------
□ text_systemline_show, vtext_systemline_show -  画面最下行のシステムラ
   インの表示

C:      void text_systemline_show(void);
C:      void vtext_systemline_show(void);

        ------------------------------------------98N 98H AT DOS-
        text_systemline_show                              ＊ ○
        ---------------------------------------------<txesc.asm>-
        vtext_systemline_show                      ×  × ○
        ------------------------------------------<vtsyslin.asm>-

                ● <98>ESCシーケンスを利用してファンクションキー
                   表示を行います。
                   <AT>日本語入力ドライバのために最下行を予約でき
                   る場合、割り当てます。

                ★ <98>int  29h(高速コンソール出力)を使用していま
                   す。

------------------------------------------------------------------------
□ text_systemline_shown, vtext_systemline_shown -  画面最下行のシステム
   ラインの表示状態を得る

C:      int text_systemline_shown(void);
C:      int vtext_systemline_shown(void);

        ------------------------------------------98N 98H AT DOS-
        text_systemline_shown                      ○     ＊
        ---------------------------------------------<txesc.asm>-
        vtext_systemline_shown                     ×  × ○
        ------------------------------------------<vtsyslin.asm>-

                ● <98>ファンクションキー表示がされていると、 0以
                   外を返します。
                   <AT>日本語入力ドライバによって画面最下行が予約
                   されている場合、0以外を返します。

------------------------------------------------------------------------
□ text_vertical - セミグラフィックを無効にする

C:      void text_vertical(void);                          マクロ

        ------------------------------------------98N 98H AT DOS-
        text_vertical                              ○     ＊
        -----------------------------------------------------<->-

                ● テキスト画面のセミグラフィック表示機能を無効に
                   します。現在セミグラフィックが表示されている部
                   分は文字に化け、縦線が上書きされた表示になりま
                   す。

------------------------------------------------------------------------
□ text_vputs - 文字列の縦書き(属性なし)

C:      void text_vputs(unsigned x, unsigned y, const char *str);

        ------------------------------------------98N 98H AT DOS-
        text_vputs                                 ○  ○ ×
        -------------------------------------------<txvputs.asm>-

                ● 文字列を縦書きで表示します。

                ○ 半角も一行消費するので、文字列のバイト数ではな
                   く、文字数のぶんだけ進む点に注意してください。
                ○ 画面下にはみ出た部分もかまわず書き込みます。画
                   面は横幅に比べて縦が短いので、特に注意して下さ
                   い。

------------------------------------------------------------------------
□ text_vputsa - 文字列の縦書き(属性あり)

C:      void text_vputsa( unsigned x, unsigned y,
                         const char * str, unsigned atrb );

        ------------------------------------------98N 98H AT DOS-
        text_vputsa                                ○  ○ ×
        ------------------------------------------<txvputsa.asm>-

                ● 文字列を属性付きで縦書きで表示します。

                ○ 半角も一行消費するので、文字列のバイト数ではな
                   く、文字数のぶんだけ進む点に注意してください。
                ○ 画面下にはみ出た部分もかまわず書き込みます。画
                   面は横幅に比べて縦が短いので、特に注意して下さ
                   い。

------------------------------------------------------------------------
□ text_width, vtext_width - テキスト画面の桁数を得る

C:      int text_width(void);                              マクロ
C:      int vtext_width(void);

        ------------------------------------------98N 98H AT DOS-
        text_width                                 ○     ＊
        -----------------------------------------------------<->-
        vtext_width                                ×  × ○
        ---------------------------------------------<vtesc.asm>-

                ● 現在の画面の桁数を得ます。 VTextつかってなけれ
                   ば 80 が得られます。

                ○ 参照:  text_height(), vtext_height()

------------------------------------------------------------------------
□ text_worddota - セミグラフィックの水平16ドットイメージ描画(属性つき)

C:      void text_worddota( int x, int y, unsigned image,
                           unsigned dotlen, unsigned atr );

        ------------------------------------------98N 98H AT DOS-
        text_worddota                              ○  × ×
        -------------------------------------------<txwdota.asm>-

                ● テキスト画面に水平にドットパターン(16dot以内)
                   を描画します。

                ← x,y     左端の開始座標( x=  -15〜159,  y=0〜99
                           (25行の時) )
                   image   16bitイメージ(最上位ビットが左端)
                           立っているビットはセットし、落ちている
                           ビットはリセットします。
                   dotlen  描画するドット長 (16を超えると、 image
                           を繰り返します)
                   atr     テキスト属性

                ★ クリッピングは横方向(-15〜159)と、 上(0〜)だけ
                   行っています。
                ★ この関数では、全てのビットが落ちたワードの、セ
                   ミグラフ属性を落としていません。

------------------------------------------------------------------------
□ TX_GETSIZE - テキスト領域保存に必要なメモリの大きさを得る

C:      TX_GETSIZE(x1,y1,x2,y2);                           マクロ

        ------------------------------------------98N 98H AT DOS-
        TX_GETSIZE
        -----------------------------------------------------<->-

                ● text_get, vtext_get に渡すための保存先メモリ領
                   域に必要な大きさを計算します。

                ← x1,y1,x2,y2   text_getに渡すものと同じ値

                → 必要なバイト数

                ○ ただの計算式ですので、 戻り値の型はx1,y1,x2,y2
                   の中で最大のものになります。(intとlongが混在し
                   ていたらlongで返る)

------------------------------------------------------------------------
□ vtext_color_98 - PC-9801文字属性を PC/AT 用に変換

C:      int vtext_color_98( int color98 );

        ------------------------------------------98N 98H AT DOS-
        vtext_color_98                             ○  ○ ○
        ------------------------------------------<vtcolr98.asm>-

                ● PC-9801 の Text 画面の文字属性を、PC/AT 用に変
                   換します。
                   98で実行した場合は引き数をそのまま返します。こ
                   のため、両用プログラム作成を助けます。

                ← color98  98用のテキスト属性

                → 動作環境用の属性
                   　98ならば引き数そのまま
                   　AT互換機ならば98属性のうち、色と反転ビットの
                   みを変換して返します。

                ○ 事前に get_machine()が実行されている必要があり
                   ます

------------------------------------------------------------------------
□ vtext_getcursor - カーソル形状を得る

C:      unsigned vtext_getcursor(void);

        ------------------------------------------98N 98H AT DOS-
        vtext_getcursor                            ×  × ○
        ------------------------------------------<vtgetcur.asm>-

                ● BIOSを用いてカーソル形状を得ます。

                → 上位8bit: カーソル開始ラスタ(0〜7)
                   下位8bit: カーソル終了ラスタ(0〜7)
                   開始ラスタ > 終了ラスタの場合は非表示

                ○ 参照:  vtext_setcursor()

------------------------------------------------------------------------
□ vtext_font_height - テキストフォントの縦ドット数を得る

C:      int vtext_font_height(void);

        ------------------------------------------98N 98H AT DOS-
        vtext_font_height                          ×  × ○
        ---------------------------------------------<vtesc.asm>-

                ● 1文字の縦のドット数を得ます。

------------------------------------------------------------------------
□ vtext_refresh - 仮想テキスト画面の一部の再描画

C:      void vtext_refresh( unsigned x, unsigned y, unsigned len);

        ------------------------------------------98N 98H AT DOS-
        vtext_refresh                              ×  × ○
        -------------------------------------------<vtrefrs.asm>-

                ● DOS/Vのファンクションを用いて、 テキスト画面の
                   一部を仮想VRAMの内容に更新します。

                ← x,y   開始テキスト座標
                   len   文字数

                ○ 事前に vtext_start()が実行されている必要があり
                   ます

------------------------------------------------------------------------
□ vtext_refresh_all - 仮想テキスト画面全体を再描画

C:      void vtext_refresh_all(void);

        ------------------------------------------98N 98H AT DOS-
        vtext_refresh_all                          ×  × ○ Ｖ
        ------------------------------------------<vtrefrsa.asm>-

                ● DOS/Vのファンクションを用いて、 テキスト画面全
                   体を仮想VRAMの内容に更新します。
                ○ 事前に vtext_start()が実行されている必要があり
                   ます

------------------------------------------------------------------------
□ vtext_refresh_off - 描画非リフレッシュ指定

C:      void vtext_refresh_off(void);

        ------------------------------------------98N 98H AT DOS-
        vtext_refresh_off                          ×  × ○
        ------------------------------------------<vtrefrsa.asm>-

                ● テキスト描画(vtext_put*()など)の度にDOS/Vの描
                   画更新ファンクションは呼ばないようにします。
                   　vtext_start()実行時、非DOS/V環境と判定した場
                   合に設定されます。
                   　DOS/V環境でも、 同じ場所を頻繁に書き換える場
                   合は、うまく使うと高速化が期待できます。

------------------------------------------------------------------------
□ vtext_refresh_on - 描画即リフレッシュ指定

C:      void vtext_refresh_on(void);

        ------------------------------------------98N 98H AT DOS-
        vtext_refresh_on                           ×  × ○
        ------------------------------------------<vtrefrsa.asm>-

                ● テキスト描画(vtext_put*()など)の度に画面に反映
                   するようにします。
                   　vtext_start()実行時、DOS/V環境と判定した場合
                   に設定されます。

------------------------------------------------------------------------
□ vtextx_end - グラフィック画面テキスト処理の終了

C:      void vtextx_end(void);

        ------------------------------------------98N 98H AT DOS-
        vtextx_end                                 ×  × ○ ○
        ------------------------------------------<vtxstart.asm>-

                ● vtextx_startで確保したメモリを開放します。

------------------------------------------------------------------------
□ vtextx_start - グラフィック画面テキスト処理の開始

C:      void vtextx_start(void);

        ------------------------------------------98N 98H AT DOS-
        vtextx_start                               ×  × ○ ○
        ------------------------------------------<vtxstart.asm>-

                ● ビデオモードが16色グラフィックモードであるとき
                   にこれを呼ぶと、 DOS/Vエミュレーションテキスト
                   の同等機能をビデオBIOSに付加します。これにより、
                   98用ソフトのような、グラフィックを描き、テキス
                   ト表示も行う処理の移植の負担を軽減します。

                ★ vtextx_start実行後、 videomodeを変更するとこの
                   機能は無効になりますが、メモリは開放されません。
                   vtextx_end()ではじめて開放されます。
                ★ テキスト属性はCGAのものなので、 文字の裏は透明
                   ではなく、背景色で塗り潰します。
                ○ カラーパレットを操作している場合、
                   vtext_colortable[]変数に  16色のテキストカラー
                   コードから、グラフィック画面のパレットコードへ
                   の変換表を書き込んでください。
                配列添え字がテキスト属性の色(0〜15)、その値が実際
                にグラフィック画面に描画するときのパレットコード
                (0〜15)です。

                △MEMORY: テキストVRAM相当(桁数*行数*2バイト)のメ
                  モリを確保します。実際の容量は、 TextVramSize*2
                  バイトです。


------------------------------------------------------------------------
■ PC-9801 30行BIOS制御 ■■■■■■■■■■■■■■■■■■■■■■■■

        　PC-9801のノーマルモード機でテキスト画面の行数を増やす、
        lucifer氏の "30行BIOS"および、早紀氏の TT.com  を利用する
        関数群です。
        　30行BIOSについては、30行BIOSに付属するドキュメント
        30tech.doc ((c)walker,lucifer)を参照してください。
        　TTについては、パソコン通信などで入手してください。

        　TT.com の場合、30行BIOS API  のエミュレーション機能があ
        ればそれを優先し、ないときには TT 1.50 の APIを使用します。

        以下のソフトに対応しています。
          30bios.com 0.08〜  (現在 1.20)
          TT.com 0.90〜      (現在 1.51)

------------------------------------------------------------------------
□ 構造体／グローバル変数

        ● bios30_getparam()の結果を格納する構造体

typedef struct bios30param bios30param;
struct bios30param {    ディスプレイ出力のパラメータ
    char hs;
    char vs;
    char vbp;
    char vfp;
    char hbp;
    char hfp;
};

------------------------------------------------------------------------
□ 定数

        ● bios30_tt_exist の戻り値と比較する定数
        表記               値    意味
        BIOS30_TT_OLD      0x02  TT 0.70〜0.80(30bios APIなし)
        BIOS30_30BIOS_OLD  0x80  30bios 0.20未満
        BIOS30_30BIOS_020  0x81  30bios 0.20〜1.20未満
        BIOS30_30BIOS_120  0x89  30bios 1.20以降
        BIOS30_TT_100      0x82  TT 1.00
        BIOS30_TT_090      0x83  TT 0.90
        BIOS30_TT_105      0x83  TT 1.05
        BIOS30_TT_150      0x06  TT 1.50〜

        ● bios30_tt_exist と論理積をとって比較する定数
        表記               値    意味
        BIOS30_TT          0x02  TT

        ● bios30_setmode,bios30_getmode で使用する定数
        標準/拡張モード
        表記               値    意味
        BIOS30_MODEMASK   0x9090 (getmode)
        BIOS30_NORMAL     0x9000 (getmode/setmode)
        BIOS30_SPECIAL    0x9010 (getmode/setmode)
        BIOS30_VGA        0x9090 (getmode/setmode)
        BIOS30_LAYER      0x9080 (getmode/setmode)
        BIOS30_RATIONAL   0x9080 (getmode/setmode)

        最下行設定
        表記               値    意味
        BIOS30_FKEYMASK   0x2020 (getmode)
        BIOS30_FKEY       0x2000 (getmode/setmode)
        BIOS30_CW         0x2020 (getmode/setmode)

        行間隔設定
        表記               値    意味
        BIOS30_LINEMASK   0x0101 (getmode)
        BIOS30_WIDELINE   0x0101 (getmode/setmode)
        BIOS30_NORMALLINE 0x0100 (getmode/setmode)

        ● bios30_setclock,bios30_getclock で使用する定数
        表記               値    意味
        BIOS30_CLOCK2     0      GDC 2.5MHz
        BIOS30_CLOCK5     1      GDC 5.0MHz

------------------------------------------------------------------------
□ bios30_exist - 30行BIOS API の存在検査

C:      int bios30_exist(void);                            マクロ

        ------------------------------------------98N 98H AT DOS-
        bios30_exist                               ○  × ×
        -----------------------------------------------------<->-

                ● 30bios APIの存在検査を行います。

                → 1  30bios APIが利用できる
                   0  存在しない

                ○ 実際には bios30_tt_exist()の結果、値が
                   BIOS30_30BIOS_OLD 以上であるかどうか検査してい
                   るマクロです。このマクロは、master.lib  の古い
                   バージョンとの互換性のために存在します。
                ○ 30bios APIの存在検査です。 TTの場合は、 30bios
                   APIのエミュレーション機能がなければ 0 が返りま
                   す。

                ○ 参照:  bios30_tt_exist()

------------------------------------------------------------------------
□ bios30_getclock - 30行BIOSによるGDCクロックの取得

C:      int bios30_getclock(void);

        ------------------------------------------98N 98H AT DOS-
        bios30_getclock                            ○  × ×
        ------------------------------------------<b30clock.asm>-

                ● GDCクロック周波数の取得を行います。

                → BIOS30_CLOCK2  2.5MHzまたは取得失敗
                   BIOS30_CLOCK5  5.0MHz

                ○ この機能は、30行BIOS 1.20以降、TT 1.50以降で有
                   効です。

                ○ 参照:  bios30_setclock()

------------------------------------------------------------------------
□ bios30_getlimit - 30行関連の設定可能行数範囲の取得

C:      unsigned bios30_getlimit(void);

        ------------------------------------------98N 98H AT DOS-
        bios30_getlimit                            ○  × ×
        ------------------------------------------<b30limit.asm>-

                ● bios30_setline() によって、 設定可能な行数の範
                   囲を得ます。

                → 上位8bit=上限
                   下位8bit=下限

                ★ TT 1.50 API, 30bios 0.20 APIのどちらも存在して
                   いなければ、上限、下限とも 25 が返ります。

------------------------------------------------------------------------
□ bios30_getline - 30行BIOSの管理行数の読み取り

C:      unsigned bios30_getline(void);

        ------------------------------------------98N 98H AT DOS-
        bios30_getline                             ○  × ×
        -------------------------------------------<b30line.asm>-

                ● 現在の行間隔設定に関係なく、行間あり、なしの両
                   方の場合の行数を得ます。

                → 上位バイト:  行間ありのときの行数-1
                   下位バイト:  行間なしのときの行数-1

                ★ TT 1.50 API, 30bios 0.20 APIのどちらも存在して
                   いなければ、0が返ります。

                ★ 現在の行数を得るだけならば、 text_height()を使
                   用してください。

                ○ 参照:  bios30_setline()

------------------------------------------------------------------------
□ bios30_getmode - 30行BIOSのモード取得

C:      unsigned bios30_getmode(void);

        ------------------------------------------98N 98H AT DOS-
        bios30_getmode                             ○  × ×
        ------------------------------------------<b30getmo.asm>-

                ● 現在の30行BIOSのモードを取得します。取得結果は
                   標準／拡張モード値と最下行設定と行間隔設定と
                   0xff00 の論理和(or)になっていますので、
                   BIOS30_*MASK定数との論理積をとることで目的の種
                   類のモードを得ることができます。

                ○ 30bios 1.20 以降では、Rational  Modeのときに、
                   戻り値と BIOS30_MODEMASKの 論理積の結果が
                   BIOS30_RATIONAL になります。
                ○ TT 1.50 以降では、Graphics Layer Modeのときに、
                   戻り値と BIOS30_MODEMASKの 論理積の結果が
                   BIOS30_LAYER になります。

                ★ TT 1.50 API, 30bios  APIのどちらも存在していな
                   ければ、0が返ります。

                例:
                  switch ( bios30_getmode() & BIOS30_LINEMASK ) {
                  case BIOS30_WIDELINE :
                      /* 行間あり */
                      break;
                  case BIOS30_NORMALLINE :
                      /* 行間なし */
                      break;
                  }

                ○ 参照:  bios30_setmode()

------------------------------------------------------------------------
□ bios30_getparam - 30行BIOSのGDCパラメータの取得

C:      int bios30_getparam( int line, bios30param * param );

        ------------------------------------------98N 98H AT DOS-
        bios30_getparam                            ○  × ×
        ------------------------------------------<b30getpa.asm>-

                ● 仮に行間なしの line 行表示に変更したときに GDC
                   に設定される各種パラメータの値を取得します。

                ← line   設定を見たい行数 ( 0 なら現在表示されて
                          いる行数 )
                   param  結果の格納先

                → 1  param に格納した
                   0  取得できない(30bios  1.10以上が常駐していな
                      い)

------------------------------------------------------------------------
□ bios30_getversion - 30行BIOS/TTのバージョン取得

C:      unsigned bios30_getversion(void);

        ------------------------------------------98N 98H AT DOS-
        bios30_getversion                          ○  × ×
        --------------------------------------------<b30ver.asm>-

                ● 常駐している 30bios または TT の、バージョン番
                   号を得ます。

                → 0       30bios/TT API が存在しない
                   0以外:  上位8bit=メジャーバージョン
                           下位8bit=マイナーバージョン
                           例: 0x010a = version 1.10

------------------------------------------------------------------------
□ bios30_getvsync - 30行BIOSにによるVSYNC周波数の取得

C:      unsigned bios30_getvsync(void);

        ------------------------------------------98N 98H AT DOS-
        bios30_getvsync                            ○  × ×
        ------------------------------------------<b30vsync.asm>-

                ● 30行BIOS 1.20以降の機能である、VSYNC周波数を取
                   得を実行します。

                → 0      30bios 1.20以上が常駐していない
                   1以上  上位8bit: 整数部  下位8bit:小数部

------------------------------------------------------------------------
□ bios30_lock - 30行BIOSの常駐解除禁止

C:      void bios30_lock(void);

        ------------------------------------------98N 98H AT DOS-
        bios30_lock                                ○  × ×
        -------------------------------------------<b30lock.asm>-

                ● 30行BIOS 1.20以降の機能である、 常駐解除禁止設
                   定を行います。

                ○ 参照:  bios30_unlock()

------------------------------------------------------------------------
□ bios30_pop - 30行BIOSのモード復元

C:      int bios30_pop(void);

        ------------------------------------------98N 98H AT DOS-
        bios30_pop                                 ○  × ×
        -----------------------------------------------<b30.asm>-

                ● 30行BIOS/TT内のスタックから現在の行数やモード
                   を取り出して設定します。

                → 1  成功
                   0  失敗(APIが存在しない)

                ★ プログラム終了時、 bios30_push()を実行した回数
                   だけbios30_pop()を実行してもとに戻さなければい
                   けません。

                ★ TT 1.50 API, 30bios  APIのどちらも存在していな
                   ければ、0が返ります。

                ○ 参照:  bios30_push()

------------------------------------------------------------------------
□ bios30_push - 30行BIOSのモード保存

C:      int bios30_push(void);

        ------------------------------------------98N 98H AT DOS-
        bios30_push                                ○  × ×
        -----------------------------------------------<b30.asm>-

                ● 30行BIOS/TT内のスタックへ現在の行数やモードを
                   保存します。

                → 1  成功
                   0  失敗(APIが存在しない)

                ★ TT 1.50 API, 30bios  APIのどちらも存在していな
                   ければ、0が返ります。

                ○ 参照:  bios30_pop()

------------------------------------------------------------------------
□ bios30_setclock - 30行BIOSによるGDCクロックの変更

C:      void bios30_setclock( int clock );

        ------------------------------------------98N 98H AT DOS-
        bios30_setclock                            ○  × ×
        ------------------------------------------<b30clock.asm>-

                ● GDCクロック周波数の変更を実行します。

                ← BIOS30_CLOCK2  2.5MHz
                   BIOS30_CLOCK5  5.0MHz

                ○ この機能は、30行BIOS 1.20以降、TT 1.50以降で有
                   効です。

                ○ 参照:  bios30_getclock()

------------------------------------------------------------------------
□ bios30_setline - 30行BIOSに行間なしの時の行数を設定する

C:      void bios30_setline( int line );

        ------------------------------------------98N 98H AT DOS-
        bios30_setline                             ○  × ×
        -------------------------------------------<b30line.asm>-

                ● 行間なしの時の値で行数を設定します。  実行後、
                   bios30_setmode()を実行することにより、初めて行
                   数が変化します。

                ← line  行数

                ★ 行間ありのときに設定した場合、少ない行数で表示
                   されます。bios30_setmode()によって行間なしに設
                   定した場合に初めて指定行数になります。

                ○ 参照:  bios30_getline()

------------------------------------------------------------------------
□ bios30_setmode - 30行BIOSのモード設定

C:      void bios30_setmode( unsigned mode );

        ------------------------------------------98N 98H AT DOS-
        bios30_setmode                             ○  × ×
        ------------------------------------------<b30setmo.asm>-

                ● 30行BIOSのモードを設定します。

                ← mode  BIOS30_*定数の中から、 setmodeの印がつい
                         たものを | (or)で組み合わせた値

                ○ 30bios 1.20 以降では、BIOS30_RATIONAL を組み合
                   わせると、Rational Mode になります。
                ○ TT 1.50 以降では、BIOS30_LAYER  を組み合わせの
                   中に設定すると Graphics Layer modeになります。

                ○ 行間の有無を変更するだけならば、text_20line(行
                   間あり), text_25line(行間なし)を呼ぶほうが画面
                   が乱れず、安全です。

                例:
                  bios30_setmode( BIOS30_FKEY );
                    最下行設定をファンクションキー表示に設定しま
                    す。
                    (行間、拡張モード指定は変化しない)

                  bios30_setmode( BIOS30_VGA | BIOS30_WIDELINE );
                    拡張モード(VGA)、行間ありに設定します。
                    (最下行設定は変化しない)

                ○ 参照:  bios30_getmode()

------------------------------------------------------------------------
□ bios30_tt_exist - 30行関連(30bios,TT)の存在検査

C:      int bios30_tt_exist(void);

        ------------------------------------------98N 98H AT DOS-
        bios30_tt_exist                            ○  × ×
        -----------------------------------------------<b30.asm>-

                ● 常駐している 30bios API の種類を調査します。

                → 0                  なにも常駐していない(TT
                                      0.70未満も含む)
                   0以外(下記参照)    常駐している
                     BIOS30_30BIOS_OLD  30bios 0.20未満
                     BIOS30_30BIOS_020  30bios 0.20〜1.20未満
                     BIOS30_30BIOS_120  30bios 1.20以降
                     BIOS30_TT_OLD      TT 0.70〜0.80(30bios  API
                                        なし)
                     BIOS30_TT_090      TT 0.90
                     BIOS30_TT_100      TT 1.00
                     BIOS30_TT_105      TT 1.05
                     BIOS30_TT_150      TT 1.50〜
                     また、以下の式で TT であるかどうかがわかりま
                     す。
                       if ( bios30_tt_exist() & BIOS30_TT ) {
                         /* TT だ− */
                       }
                     なにか常駐してて、TT でなければ 30bios  です
                     ね。

                ○ 結果が BIOS30_30BIOS_OLD  以上であれば  30bios
                   APIは存在していることになります。
                ○ また、 BIOS30_30BIOS_020  以上であれば  30bios
                   0.20 API が存在していることになります。
                ○ 常駐しているプログラムの種類からより細かい処理
                   分けをする必要があるときに使いましょう。

                ○ 参照:  bios30_exist()

------------------------------------------------------------------------
□ bios30_unlock - 30行BIOSの常駐解除許可

C:      void bios30_unlock(void);

        ------------------------------------------98N 98H AT DOS-
        bios30_unlock                              ○  × ×
        -------------------------------------------<b30lock.asm>-

                ● 30行BIOS 1.20以降の機能である、 常駐解除禁止設
                   定解除を行います。

                ○ 参照:  bios30_lock()


------------------------------------------------------------------------
■ グラフィック処理 ■■■■■■■■■■■■■■■■■■■■■■■■■■


------------------------------------------------------------------------
■ グラフィック画面関係 ■■■■■■■■■■■■■■■■■■■■■■■■

        　グラフィック画面に描画したり、 読み込んだりする関数群で
        す。
        　画像ファイルを読み込む関数もあります。

        　<AT>すべての描画の前に、かならず vga4_start  またはそれ
        に相当する処理を行う必要があります。

        　文字(列)描画をする場合は、前もって font_write(),
        font_entry_bfnt(), font_entry_cgrom() などで  font_AnkSeg
        セグメントのオフセット 0 からフォントパターンを格納してお
        く必要があります。

        ● font、ank、kanji 系の関数の使い分け

        　機能がほとんど同じこれらの関数が存在するにはそれなりの
        訳があります。
        　まず、ank 系の関数を利用すると、SHIFT-JIS  コードに割り
        当てられている文字も ank のフォントで表示することができま
        す。また、kanji 系の関数は、font 系の関数で必要なフォント
        を準備しなくても利用できます。 font 系の関数は ank と漢字
        のまじった文字列を表示するときに使うわけです。
        　もちろん、ank  系の関数では漢字は表示できないし、 kanji
        系の関数では ank は表示できないので、注意が必要ですが。

------------------------------------------------------------------------
□ 構造体／グローバル変数


        ● Pi画像ヘッダ構造体
typedef struct PiHeader PiHeader;
struct PiHeader {
    char far *comment;      /* graph_pi_load_pack()では */
                            /* NULLがsetされるだけ */
    unsigned commentlen;
    unsigned char mode;     /* bit7が立っていればパレットなし */
    unsigned char n;        /* アスペクト比 */
    unsigned char m;        /* アスペクト比 */
    unsigned char plane;    /* 4だと16色 */
    char machine[4];        /* 保存した機種, "PC98" */
    unsigned maexlen;       /* 機種予約エリアの長さ */
    void far *maex;         /* 機種予約エリアの中身 */
    unsigned xsize;         /* 画像の横ドット数 */
    unsigned ysize;         /* 画像の縦ドット数 */
    char palette[48];       /* (mode &  0x80)=0ならパレットが格納
                            される */
};

        ● MAG画像ヘッダ構造体
typedef struct MagHeader MagHeader;
struct MagHeader {
    unsigned commentseg;    /* 読み込んだコメントのセグメント */
    unsigned commentlen;    /* コメントの長さ */
    char head;
    char machine;
    char exflag;
    char scrnmode;
    int x1;                 /* 論理的な左上座標 */
    int y1;
    int x2;                 /* 論理的な右下座標 */
    int y2;
    long flagAofs;
    long flagBofs;
    long flagBsize;
    long pixelofs;
    long pixelsize;
    unsigned xsize ;        /* メモリ上データの 1ラインの横ドット
                            数 */
    unsigned ysize ;        /* メモリ上データの縦ドット数 */
    char palette[48];
};



unsigned graph_VramSeg; グラフィックVRAMの先頭アドレス
                                初期値は、0xa800になっています。
unsigned graph_VramWords;       グラフィックVRAMの１プレーンのワ
                                ード数(0〜32767)が入ります。
                                初期値は、16000になっています。
unsigned graph_VramLines;       グラフィック画面のy座標のライン数
                                が入ります。通常、200または400で、
                                初期値は400です。
unsigned graph_VramWidth;       グラフィックVRAMの１ラインの横バ
                                イト数。16色(4プレーン),横640ドッ
                                トのときには 80 が入ります。
unsigned graph_VramZoom;        上位8bitは、GDCの周波数が5MHzなら
                                40h, 2.5MHzなら 0が入ります。
                                下位8bitは、画面の縦倍シフト量
                                (1dotがほぼ正方形なら0, 640x200の
                                ように縦長なら1)が入ります。
                                この変数は、graph_200line,
                                graph_400lineで設定されます。
unsigned char graph_MeshByte;   grcg_bytemesh_x, vgc_bytemesh_xで、
                                偶数ラインのときに塗り潰すパター
                                ン。初期値は0x55。 graph_VramZoom
                                が1になっているときは、  この値を
                                0xccなどに書き換えると奇麗になり
                                ます。

unsigned font_AnkSeg;           半角フォントの格納セグメント
unsigned font_AnkSize;          半角フォントの1文字の大きさ(上位
                                8bitは横dot数/8, 下位8bitは縦ドッ
                                ト数)
unsigned font_AnkPara;          半角フォント1文字の占めるパラグラ
                                フサイズ
unsigned wfont_AnkSeg;          圧縮半角フォントの格納セグメント
unsigned char wfont_Plane1;     圧縮漢字の偶数ライン描画用 GRCGモ
                                ードレジスタ設定値
unsigned char wfont_Plane2;     圧縮漢字の奇数ライン描画用 GRCGモ
                                ードレジスタ設定値
unsigned char wfont_Reg;        圧縮文字の描画時のタイルレジスタ
                                に設定する値

int at98_APage;                 at98_accesspage()に渡された値の保
                                存
int at98_VPage;                 at98_showpage()に渡された値の保存

------------------------------------------------------------------------
□ GB_GETSIZE - グラフィック領域保存に必要なメモリの大きさを得る

C:      long GB_GETSIZE(x1,y1,x2,y2);                      マクロ

        ------------------------------------------98N 98H AT DOS-
        GB_GETSIZE
        -----------------------------------------------------<->-

                ● graph_byteget, vga4_byteget で保存するときに必
                   要なメモリ領域の大きさを計算します。

                ← x1,y1,x2,y2  graph_bytegetに渡すのと同じ値。

                → 必要なバイト数(long値なので注意)

------------------------------------------------------------------------
□ graph_16color - 9821 16色モードに設定

C:      void graph_16color(void);

        ------------------------------------------98N 98H AT DOS-
        graph_16color                              ○  × ×
        --------------------------------------------<grp256.asm>-

                ● 16色モードに設定し、BIOSワークエリアを書き換え
                   ます。

                ○ 9821/A/Cでなければ何もしません。

------------------------------------------------------------------------
□ graph_200line - グラフィック画面を200lineに設定する

C:      void graph_200line( int tail );

        ------------------------------------------98N 98H AT DOS-
        graph_200line                              ○  × ＊
        ------------------------------------------<grp200li.asm>-

                ● BIOSを用いて 640x200dotモードに設定します。
                   書き込みページは0にします。
                   tail =  0  の場合、 グラフィック画面の前半分、
                   tail = 1 の場合、後ろ半分を選択します。

                   グローバル変数を、下記のように設定します。
                        graph_VramSeg =
                                tailが0: 0xa800
                                tailが1: 0xabe8
                        graph_VramWords = 8000
                        graph_VramLines = 200
                        graph_VramZoom = 1

                   また、grc_setclipのクリッピング領域を  640x200
                   全体に設定します。

                ○ <AT>実際には、以下のことをします。
                    1. vga4_start(0x8e,640,200)
                    2.
                graph_VramSeg=ClipYT_seg=(0xa000+((t)&1)*400*5)
                    3. at98_showpage(at98_VPage)
                    4. at98_accesspage(at98_APage)
                    5. vtextx_start()
                    　すなわち、 640x200dotモードのドットの縦の大
                    きさを半分にすることで、640x400を実現していま
                    す。

                ★ <AT>AT互換機では、パレットは初期化されます。

------------------------------------------------------------------------
□ graph_24kHz - 9821水平周波数を24kHzに設定する

C:      void graph_24kHz(void);                            マクロ

        ------------------------------------------98N 98H AT DOS-
        graph_24kHz                                ○  × ×
        -----------------------------------------------------<->-

                ● 水平周波数を 24kHzにします。

                ○ 9821/A/Cでなければ何もしません。

------------------------------------------------------------------------
□ graph_256color - 9821 256色モードに設定

C:      void graph_256color(void);

        ------------------------------------------98N 98H AT DOS-
        graph_256color                             ○  × ×
        --------------------------------------------<grp256.asm>-

                ● 256色モードに設定し、 BIOSワークエリアを書き換
                   えます。

                ○ 9821/A/Cでなければ何もしません。

                ★ master.libには、256色描画関数はありません。 注
                   意してください。

------------------------------------------------------------------------
□ graph_31kHz - 9821水平周波数を31kHzに設定する

C:      void graph_31kHz(void);                            マクロ

        ------------------------------------------98N 98H AT DOS-
        graph_31kHz                                ○  × ×
        -----------------------------------------------------<->-

                ● 水平周波数を 31kHzにします。

                ○ 9821/A/Cでなければ何もしません。

------------------------------------------------------------------------
□ graph_400line, at98_graph_400line - グラフィック画面を400lineに設定す
   る

C:      void graph_400line(void);
C:      void at98_graph_400line(void);

        ------------------------------------------98N 98H AT DOS-
        graph_400line                              ○  × ＊
        ------------------------------------------<grp400li.asm>-
        at98_graph_400line                         ×  × ○
        ------------------------------------------<at98g400.asm>-

                ● BIOSを用いて 640x400dotモードに設定します。
                   書き込みページは0にします。

                   グローバル変数を、下記のように設定します。
                        graph_VramSeg = 0xa800
                        graph_VramWords = 16000
                        graph_VramLines = 400
                        graph_VramZoom = <98>(GDCが5MHzなら
                        0x4000, 2.5MHzなら0)
                                         <AT>0

                   また、grc_setclipのクリッピング領域を  640x400
                   全体に設定します。

                ○ <AT>実際には、以下のことをします。
                    1. vga4_start(0x8e,640,400)
                    2. vga_vzoom_off()
                    3. at98_showpage(at98_VPage)
                    4. at98_accesspage(at98_APage)
                    5. vtextx_start()
                    　すなわち、 640x200dotモードのドットの縦の大
                    きさを半分にすることで、640x400を実現していま
                    す。

                ★ <AT>AT互換機では、パレットは初期化されます。

------------------------------------------------------------------------
□ graph_480line - 9821画面を480lineモードに設定する

C:      void graph_480line(void);                          マクロ

        ------------------------------------------98N 98H AT DOS-
        graph_480line                              ○  × ×
        -----------------------------------------------------<->-

                ● 480ラインモードにします。

                ○ 9821/A/Cでなければ何もしません。

------------------------------------------------------------------------
□ graph_accesspage, at98_accesspage - グラフィック画面CPUアクセスページ
   設定

C:      void graph_accesspage( int page );                 マクロ
C:      void at98_accesspage( int page );

        ------------------------------------------98N 98H AT DOS-
        graph_accesspage                           ○  × ＊
        -----------------------------------------------------<->-
        at98_accesspage                            ×  × ○
        ------------------------------------------<at98scrl.asm>-

                ● CPUがアクセスするページを指定します。
                   pageには、0 または 1 が指定できます。

                ○ <AT> graph_VramSeg, ClipYT_seg  変数を操作しま
                   す。

------------------------------------------------------------------------
□ graph_analog - パレットモードをアナログ16色にする

C:      void graph_analog(void);                           マクロ

        ------------------------------------------98N 98H AT DOS-
        graph_analog                               Ｖ  × ×
        -----------------------------------------------------<->-

                ● I/Oポートを直接アクセスして、 アナログパレット
                   モードに設定します。

------------------------------------------------------------------------
□ graph_ank_putc - 半角文字の描画

C:      void graph_ank_putc( int x, int y, int c, int color );

        ------------------------------------------98N 98H AT DOS-
        graph_ank_putc                             Ｖ  × ＊
        ------------------------------------------<grpaputc.asm>-

                ● グラフィック画面へ半角文字(8x16dot)を1文字描画
                   します。

                ← x,y    左上座標
                   c      文字コード(0〜255)
                   color  色(0〜15)

                ★ フォントデータは font_write()や
                   font_entry_bfnt(), font_entry_cgrom() であらか
                   じめ登録してある必要があります。
                ★ クリッピングは行っていません。

------------------------------------------------------------------------
□ graph_ank_putp - 半角(パスカル)文字列の描画

C:      void graph_ank_putp( int x, int y, int step,
                            const char *passtr, int color );

        ------------------------------------------98N 98H AT DOS-
        graph_ank_putp                             Ｖ  × ×
        ------------------------------------------<grpaputp.asm>-

                ● グラフィック画面に半角文字(8x16dot)列を描画し
                   ます。

                ← x,y    左上座標
                   step   文字間隔(8でぴったり連続します)
                   str    パスカル文字列の先頭アドレス
                   color  色(0〜15)

                ★ 漢字の混在はできません。
                ★ フォントデータは font_write()や
                   font_entry_bfnt(), font_entry_cgrom() であらか
                   じめ登録してある必要があります。
                ★ クリッピングは行っていません。

------------------------------------------------------------------------
□ graph_ank_puts - 半角文字列の描画

C:      void graph_ank_puts( int x, int y, int step,
                            const char * str, int color );

        ------------------------------------------98N 98H AT DOS-
        graph_ank_puts                             Ｖ  × ＊
        ------------------------------------------<grpaputs.asm>-

                ● グラフィック画面に半角文字(8x16dot)列を描画し
                   ます。

                ← x,y    左上座標
                   step   文字間隔(8でぴったり連続します)
                   str    文字列の先頭アドレス
                   color  色(0〜15)

                ★ 漢字の混在はできません。混在するには、
                   graph_font_puts()を使用してください。
                ★ フォントデータは font_write()や
                   font_entry_bfnt(), font_entry_cgrom() であらか
                   じめ登録してある必要があります。
                ★ クリッピングは行っていません。

------------------------------------------------------------------------
□ graph_clear, vga4_clear - グラフィック画面の消去

C:      void graph_clear(void);
C:      void vga4_clear(void);

        ------------------------------------------98N 98H AT DOS-
        graph_clear                                Ｖ  × ＊
        ------------------------------------------<grpclear.asm>-
        vga4_clear                                 ×  × ○
        ------------------------------------------<vgcclear.asm>-

                ● グラフィック画面の表示領域を 0  番の色で塗り潰
                   します。
                   <98>GRCGを用いて消去します。

                ○ 塗りつぶす領域は、セグメント graph_VramSeg  の
                   オフセット  0 から、graph_VramWords * 2 バイト
                   分です。

------------------------------------------------------------------------
□ graph_copy_page - グラフィック画面の内容を他のページから複写する

C:      int graph_copy_page( int to_page );

        ------------------------------------------98N 98H AT DOS-
        graph_copy_page                            ○  × ＊ ○
        -------------------------------------------<grpcppg.asm>-

                ● グラフィック画面の指定ページへ、反対のページの
                   内容を転写し、アクセスページを  コピー先の頁に
                   設定します。

                ← to_page   コピー先の頁(0または1)

                → 1  成功
                   0  <98>失敗(smem_wget()によって 32KBのメモリが
                      確保できなかった)

                △MEMORY: <98>この関数の内部で、一時的に VRAM 1プ
                  レーン分(640x400時、32KB)の領域を確保し、開放し
                  ます。

------------------------------------------------------------------------
□ graph_backup - グラフィック画面(表裏とも)のEMSへの保存

C:      int graph_backup( int pagemask );

        ------------------------------------------98N 98H AT DOS-
        graph_backup                               ○  × ×
        ------------------------------------------<grpbakup.asm>-

                ● グラフィック画面の表、裏、または両方を、格納で
                   きる必要な大きさをEMSに確保して保存します。
                   　ems_exist()は、 内部で呼んでいるのであらかじ
                   め呼んでおく必要はありません。
                ← pagemask = G_PAGE0   表頁を保存する(EMS  128KB
                                        使用)
                              G_PAGE1   裏頁を保存する(EMS  128KB
                                        使用)
                              G_ALLPAGE  表裏両方の画面を保存する
                              (EMS 256KB使用)
                              上記以外の値を指定した場合、 動作は
                              不定です。

                → 1  成功
                   0  失敗(EMSがない、足りない、 すでに退避してあ
                      る、pagemaskが異常)

------------------------------------------------------------------------
□ graph_bfnt_putc, vgc_bfnt_putc - BFNT文字の描画

C:      void graph_bfnt_putc( int x, int y, int ank, int color );
C:      void vgc_bfnt_putc( int x, int y, int ank );

        ------------------------------------------98N 98H AT DOS-
        graph_bfnt_putc                            Ｖ  × ＊
        ------------------------------------------<grpbputc.asm>-
        vgc_bfnt_putc                              ×  × ○
        ------------------------------------------<vgcbputc.asm>-

                ● 文字をグラフィック画面に描画します。

                ← x,y    描画開始左上座標
                   ank    文字コード(0〜255)
                   color  色(0〜15) (graph_bfnt_putcのみ)

                ○ vgc_bfnt_putc は、色は vgc_setcolor で指定しま
                   す。

                ★ フォントデータはあらかじめ   font_entry_bfnt()
                   などで登録しておいてください。
                ★ クリッピングは行っていません。

------------------------------------------------------------------------
□ graph_bfnt_putp - パスカル文字列描画(BFNT)

C:      void graph_bfnt_putp(   int   x,   int   y,   int   step,
                             char * passtr, int color);

        ------------------------------------------98N 98H AT DOS-
        graph_bfnt_putp                            Ｖ  × ×
        ------------------------------------------<grpbputp.asm>-

                ● graph_ank_putpの文字サイズ対応版です。大きさは
                   font_AnkSize に対応します。

                ← x,y     描画左上座標
                   step    1文字ごとに進めるドット数(0=移動しない)
                   str     パスカル文字列(ANKのみ)
                   color   色 (0〜15)

                ★ フォントデータはあらかじめ   font_entry_bfnt()
                   などで登録しておいてください。
                ★ クリッピングは行っていません。

------------------------------------------------------------------------
□ graph_bfnt_puts, vgc_bfnt_puts - BFNT文字列の描画

C:      void graph_bfnt_puts( int x, int y, int step, char * ank,
                             int color);
C:      void vgc_bfnt_puts( int x, int y, int step, char * ank );

        ------------------------------------------98N 98H AT DOS-
        graph_bfnt_puts                            Ｖ  × ＊
        ------------------------------------------<grpbputs.asm>-
        vgc_bfnt_puts                              ×  × ○
        ------------------------------------------<vgcbputs.asm>-

                ● graph_ank_putsの文字サイズ対応版です。大きさは
                   font_AnkSize に対応します。

                ← x,y     描画左上座標
                   step    1文字ごとに進めるドット数(0=移動しない)
                   str     文字列(ANKのみ)
                   color   色(0〜15) (graph_bfnt_putsのみ)

                ○ vgc_bfnt_puts は、色は vgc_setcolor で指定しま
                   す。

                ★ フォントデータはあらかじめ   font_entry_bfnt()
                   などで登録しておいてください。
                ★ クリッピングは行っていません。

------------------------------------------------------------------------
□ graph_byteget, vga4_byteget - グラフィック画面の領域保存

C:      void graph_byteget( int cx1,int y1, int cx2,int y2, void far *buf );
C:      void vga4_byteget( int cx1,int y1, int cx2,int y2, void far *buf );

        ------------------------------------------98N 98H AT DOS-
        graph_byteget                              ○  × ＊
        -------------------------------------------<grpbget.asm>-
        vga4_byteget                               ×  × ○
        -------------------------------------------<vg4bget.asm>-

                ● 横8ドット単位での領域保存です。

                ← cx1,cx2  テキスト座標で横位置。cx1は必ず左で、
                            cx2は右
                   y1,y2    グラフィック座標の縦位置。y1が上、 y2
                            が下
                   buf      マクロ  GB_GETSIZE(cx1,y1,cx2,y2)バイ
                            ト以上のメモリ領域

                ★ クリッピングは行っていません。

------------------------------------------------------------------------
□ graph_byteput, vga4_byteput - グラフィック画面の領域復元

C:      void graph_byteput( int cx1,int y1, int cx2,int y2, const
                           void far *buf );
C:      void vga4_byteput( int cx1,int y1, int cx2,int y2,  const
                          void far *buf );

        ------------------------------------------98N 98H AT DOS-
        graph_byteput                              ○  × ＊
        -------------------------------------------<grpbget.asm>-
        vga4_byteput                               ×  × ○
        -------------------------------------------<vg4bget.asm>-

                ● graph_byteget()で退避した画面部分を表示します。

                ← cx1,cx2  テキスト座標で横位置。cx1は必ず左で、
                            cx2は右
                   y1,y2    グラフィック座標の縦位置。y1が上、 y2
                            が下
                   buf      graph_bytegetで退避したバッファ

                ★ クリッピングは行っていません。

------------------------------------------------------------------------
□ graph_crt - 画面のドットずれ補正解除

C:      void graph_crt(void);                              マクロ

        ------------------------------------------98N 98H AT DOS-
        graph_crt                                  Ｖ  × ×
        -----------------------------------------------------<->-

                ● I/Oポートを直接アクセスして、 グラフィック画面
                   とテキスト画面の表示位置を 1ドットずらします。

                ○ システム起動時は 1ドットずれていますが、現在の
                   状態を知ることができないし、普段一致させている
                   人もいるので、ドットずれ補正した後にわざわざず
                   らす必要はないでしょう。

------------------------------------------------------------------------
□ graph_digital - パレットモードをデジタル8色にする

C:      void graph_digital(void);                          マクロ

        ------------------------------------------98N 98H AT DOS-
        graph_digital                              Ｖ  × ×
        -----------------------------------------------------<->-

                ● I/Oポートを直接アクセスして、 デジタルパレット
                   (8色)モードに設定します。

                ★ master.libの関数は、 デジタル8色モードでのパレ
                   ット操作はできません。

------------------------------------------------------------------------
□ graph_end, vga4_end - グラフィック画面一括終了処理

C:      void graph_end(void);
C:      void vga4_end(void);

        ------------------------------------------98N 98H AT DOS-
        graph_end                                  Ｖ  × ＊
        --------------------------------------------<grpend.asm>-
        vga4_end                                   ×  × ○
        ------------------------------------------<vgcstart.asm>-

                ● <98>終了のために、以下の処理を行います。
                   graph_hide
                   graph_400line
                   graph_clear

                   <AT>ビデオモードを  vga4_startで記録した値に設
                   定します。
                   また、VTextState変数を 0x7fffでANDします。

------------------------------------------------------------------------
□ graph_enter - グラフィック画面を消さない初期設定

C:      void graph_enter(void);

        ------------------------------------------98N 98H AT DOS-
        graph_enter                                Ｖ  × ＊
        ------------------------------------------<grpenter.asm>-

                ● 開始のために、以下の処理を行います。

                   1. graph_plasma
                   2. 常駐パレットが存在すれば読み取り、 なければ
                   Palettes を初期化して PaletteTone=100,
                   graph_analog() を実行する
                   3. graph_400line
                   4. graph_show

------------------------------------------------------------------------
□ graph_extmode - 9821拡張グラフィックモードの設定／取得

C:      unsigned graph_extmode( unsigned modmask, unsigned bhal );

        ------------------------------------------98N 98H AT DOS-
        graph_extmode                              ○  × ×
        ------------------------------------------<grpextmd.asm>-

                ● PC-9821/A/Cシリーズの拡張CRT  BIOSを使用して、
                   各種画面モードを制御します。

                ← modmask  上位8bit:  BHレジスタの操作するビット
                            に1を立てたマスク
                            下位8bit: AL〃
                   bhal     上位8bit: BHレジスタに設定する値
                            下位8bit: AL〃

                → 設定後の BH,ALレジスタの値

                ビットの内容:
                  AL  b7 b6 b5 b4 b3 b2 b1 b0
                                  || ||    ++- 0 ノンインターレー
                                           ス
                                  || ||        1 インターレース
                                  ++-++------- 00 15.98kHz(98GS)
                                               10 24.83kHz
                                               11 31.47kHz
                  BH  b7 b6 b5 b4 b3 b2 b1 b0
                            || ||       ++-++- 00 20行
                            || ||              01 25行
                            || ||              10 30行
                            ++-++------------- 00 640x200(UPPER)
                                               01 640x200(LOWER)
                                               10 640x400
                                               11 640x480

                ○ modmaskを 0にすることで、 現在のモード値を取得
                   できます。
                ○ 逆に、modmaskを0ffffhにすることで、 すべてのビ
                   ットを操作することになります。
                ○ 9821/A/Cでなければ何もせず、常に 0 を返します。

------------------------------------------------------------------------
□ graph_font_put, vgc_font_put - 1文字描画

C:      void graph_font_put( int x, int y, const char * str, int color );
C:      void vgc_font_put( int x, int y, const char * str );

        ------------------------------------------98N 98H AT DOS-
        graph_font_put                             Ｖ  × ＊
        -------------------------------------------<grpfput.asm>-
        vgc_font_put                               ×  × ○
        -------------------------------------------<vgcfput.asm>-

                ● グラフィック画面に、文字列の最初の1文字
                   (8x16dotまたは16x16dot)を描画します。
                   全角・半角のどちらも描画できます。

                ← x,y    左上座標
                   str    文字列の先頭アドレス
                   color  色(0〜15) (graph_font_putのみ)

                ★ フォントデータは font_write()や
                   font_entry_bfnt(), font_entry_cgrom() であらか
                   じめ登録してある必要があります。
                ★ クリッピングは行っていません。

                ○ vgc_font_put は、色は vgc_setcolor  で指定しま
                   す。
                ○ <vgc_font_put>日本語テキストモード以外で処理す
                   るためには、日本語テキストモードのうちに
                   font_at_init()を実行しておく必要があります。

------------------------------------------------------------------------
□ graph_font_putp - パスカル文字列描画

C:      void graph_font_putp( int x, int y, int step,
                             const char * passtr, int color );

        ------------------------------------------98N 98H AT DOS-
        graph_font_putp                            Ｖ  × ×
        ------------------------------------------<grpfputp.asm>-

                ● グラフィック画面へ文字列を描画します。

                ← x,y    左上座標
                   step   文字間隔(全角文字の幅を基準にするので、
                          16でぴったり連続します。 半角文字はこの
                          指定の半分(端数切り捨て)だけ進みます)
                   str    パスカル文字列
                   color  色(0〜15)

                ★ 漢字半角には対応していません。
                ★ フォントデータは font_write()や
                   font_entry_bfnt(), font_entry_cgrom() であらか
                   じめ登録してある必要があります。
                ★ クリッピングは行っていません。

------------------------------------------------------------------------
□ graph_font_puts, vgc_font_puts - 文字列描画

C:      void graph_font_puts( int x, int y, int step,
                             const char * str, int color );
C:      void vgc_font_puts( int x, int y, int step, const char * str );

        ------------------------------------------98N 98H AT DOS-
        graph_font_puts                            Ｖ  × ＊
        ------------------------------------------<grpfputs.asm>-
        vgc_font_puts                              ×  × ○
        ------------------------------------------<vgcfputs.asm>-

                ● グラフィック画面へ文字(8x16dotまたは16x16dot)
                   列を描画します。

                ← x,y    左上座標
                   step   文字間隔(全角文字の幅を基準にするので、
                          16でぴったり連続します。 半角文字はこの
                          指定の半分(端数切り捨て)だけ進みます)
                   str    文字列の先頭アドレス
                   color  色(0〜15) (graph_font_putsのみ)

                ★ 漢字半角には対応していません。
                ★ フォントデータは font_write()や
                   font_entry_bfnt(), font_entry_cgrom() であらか
                   じめ登録してある必要があります。
                ★ クリッピングは行っていません。

                ○ vgc_font_puts は、色は vgc_setcolor で指定しま
                   す。
                ○ <vgc_font_puts>日本語テキストモード以外で処理
                   するためには、日本語テキストモードのうちに
                   font_at_init()を実行しておく必要があります。

------------------------------------------------------------------------
□ graph_gaiji_putc - 外字描画

C:      void graph_gaiji_putc( int x, int y, int c, int color );

        ------------------------------------------98N 98H AT DOS-
        graph_gaiji_putc                           Ｖ  × ×
        ------------------------------------------<grpgjput.asm>-

                ● グラフィック画面に外字(16x16dot)を描画します。

                ← x,y     描画左上座標
                   c       外字コード( 0〜0ffh )

                ★ クリッピングは行っていません。

------------------------------------------------------------------------
□ graph_gaiji_puts - 外字文字列描画

C:      void graph_gaiji_puts( int x, int y, int step,
                              const char * str, int color );

        ------------------------------------------98N 98H AT DOS-
        graph_gaiji_puts                           Ｖ  × ×
        ------------------------------------------<grpgputs.asm>-

                ● グラフィック画面に外字(16x16dot)文字列を描画し
                   ます。

                ← x,y     描画左上座標
                   step    1文字ごとに進めるドット数(0=移動しない)
                   str     外字文字列(ANKのみ)
                   color   色 (0〜15)

                ★ クリッピングは行っていません。

------------------------------------------------------------------------
□ graph_getextmode - 9821拡張グラフィックモードの取得

C:      unsigned graph_getextmode(void);                   マクロ

        ------------------------------------------98N 98H AT DOS-
        graph_getextmode                           ○  × ×
        -----------------------------------------------------<->-

                ● 現在の9821/A/C拡張モードの状態を得ます。

                → 上位8bit:  BHの値
                   下位8bit:  ALの値

                ○ ビット内容については graph_extmode 参照
                ○ 9821/A/Cでなければ常に 0 を返します。

------------------------------------------------------------------------
□ graph_hide - グラフィック画面の表示を隠す

C:      void graph_hide(void);

        ------------------------------------------98N 98H AT DOS-
        graph_hide                                 ○  × ×
        -------------------------------------------<grphide.asm>-

                ● BIOSを用いてグラフィック画面の表示を隠します。

------------------------------------------------------------------------
□ graph_is256color - 9821 256色モードかどうか判定

C:      int graph_is256color(void);

        ------------------------------------------98N 98H AT DOS-
        graph_is256color                           ○  × ×
        --------------------------------------------<grp256.asm>-

                ● BIOSワークエリアを参照して、 256色モードかどう
                   か判定します。

                → 0      16色モード
                   0以外  256色モード

                ○ 9821/A/Cでなければ 0を返します。

------------------------------------------------------------------------
□ graph_is31kHz - 9821が水平周波数31kHzかどうか得る

C:      int graph_is31kHz(void);                           マクロ

        ------------------------------------------98N 98H AT DOS-
        graph_is31kHz                              ○  × ×
        -----------------------------------------------------<->-

                ● 31kHzなら 1(true)を返します。

                ○ 9821/A/Cでなければ常に 0 を返します。

------------------------------------------------------------------------
□ graph_kanji_put - 全角文字描画

C:      void graph_kanji_put( int x, int y, const char * str, int color );

        ------------------------------------------98N 98H AT DOS-
        graph_kanji_put                            Ｖ  × ＊
        -------------------------------------------<grpkput.asm>-

                ● グラフィック画面へ全角文字(16x16dot)を描画しま
                   す。

                ← x,y    左上座標
                   str    文字列の先頭アドレス。この1文字目が描画
                          されます。
                   color  色(0〜15)

                ★ 漢字半角には対応していません。
                ★ クリッピングは行っていません。

------------------------------------------------------------------------
□ graph_kanji_large_put - 4倍角漢字描画

C:      void graph_kanji_large_put( int x, int y,
                                   const char * str, int color );

        ------------------------------------------98N 98H AT DOS-
        graph_kanji_large_put                      Ｖ  × ×
        ------------------------------------------<grpklput.asm>-

                ● グラフィック画面に、 全角文字を4倍角で描画しま
                   す。

                ← x,y    左上座標
                   str    文字列の先頭アドレス(この1文字目が描画
                          されます)
                   color  色(0〜15)

                ★ 半角文字には対応していません。
                ★ クリッピングは行っていません。

------------------------------------------------------------------------
□ graph_kanji_puts - 全角文字列描画

C:      void graph_kanji_puts( int x, int y, int step,
                              const char * str, int color );

        ------------------------------------------98N 98H AT DOS-
        graph_kanji_puts                           Ｖ  × ＊
        ------------------------------------------<grpkputs.asm>-

                ● グラフィック画面に、全角文字(16x16dot)のみで構
                   成された文字列を描画します。

                ← x,y    左上座標
                   step   文字間隔(16でぴったり連続します)
                   str    文字列の先頭アドレス
                   color  色(0〜15)

                ★ 漢字半角には対応していません。
                ★ クリッピングは行っていません。

------------------------------------------------------------------------
□ graph_leave - グラフィック画面を消さない終了処理

C:      void graph_leave(void);                            マクロ

        ------------------------------------------98N 98H AT DOS-
        graph_leave                                Ｖ  × ×
        -----------------------------------------------------<->-

                ● 終了のために、以下の処理を行います。

                   respal_set_palettes

------------------------------------------------------------------------
□ graph_pack_get_8, vga4_pack_get_8 - パックデータ読み取り(8dot単位)

C:      void graph_pack_get_8( int x, int y, void far * linepat, int len );
C:      void vga4_pack_get_8( int x, int y, void far * linepat, int len );

        ------------------------------------------98N 98H AT DOS-
        graph_pack_get_8                           Ｖ  × ＊
        ------------------------------------------<grppget8.asm>-
        vga4_pack_get_8                            ×  × ○
        ------------------------------------------<vg4pget8.asm>-

                ● グラフィック画面から水平に1バイトに2dot詰めて
                   メモリに読み込みます。
                ← x        左端座標( 8の倍数に切り捨てます )
                   y        描画 y 座標
                   linepat  読み込み先の先頭アドレス
                            　このデータは、1バイトの上位4bitに左
                            側、 下位4bitに右側のカラーコードを格
                            納して2bitを表す形式のデータ列で、 16
                            色のときの BFNT+, BMP(DIB), magの圧縮
                            前のときの状態と同じです。
                            　★len/2バイトの領域を用意してくださ
                                い。
                   len      横ドット数( 8の倍数に切り捨てられます
                            )

                ★ クリッピングは上下は grc_setclip範囲、左右は画
                   面幅で行っています。
                   クリッピング範囲外の領域は読み込みません。

------------------------------------------------------------------------
□ graph_pack_put_8, vga4_pack_put_8 - パックデータ描画(8dot単位)

C:      void graph_pack_put_8( int x, int y,
                              const void far * linepat, int len );
C:      void vga4_pack_put_8( int x, int y,
                             const void far * linepat, int len );

        ------------------------------------------98N 98H AT DOS-
        graph_pack_put_8                           Ｖ  × ＊
        ------------------------------------------<grppput8.asm>-
        vga4_pack_put_8                            ×  × ○
        ------------------------------------------<vg4pput8.asm>-

                ● 1バイトに2dot詰めたグラフィックイメージデータ
                   を1line描画します。

                ← x        左端座標( 8の倍数に切り捨てます )
                   y        描画 y 座標
                   linepat  パターンデータの先頭(左端)アドレス
                            　このデータは、1バイトの上位4bitに左
                            側、 下位4bitに右側のカラーコードを格
                            納して2bitを表す形式のデータ列で、 16
                            色のときの BFNT+, BMP(DIB), magの圧縮
                            前のときの状態と同じです。
                   len      横ドット数( 8の倍数に切り捨てられます
                            )

                ★ クリッピングは上下は grc_setclip範囲、左右は画
                   面幅で行っています。

------------------------------------------------------------------------
□ graph_pi_comment_load - Pi画像ファイルのコメント部分読み込み

C:      int graph_pi_comment_load( const char * filename, PiHeader * header );

        ------------------------------------------98N 98H AT DOS-
        graph_pi_comment_load                                ○
        ------------------------------------------<grppicom.asm>-

                ● Pi形式ファイルのコメントを読み込み、メモリ上に
                   読み込んだアドレスを header.comment に格納しま
                   す。

                ← filename    ファイルファイル名
                   header      ヘッダ情報格納場所

                → NoError             成功, またはコメントがない
                   FileNotFound        ファイルがない
                   InvalidData         Piファイルじゃない
                   InsufficientMemory  メモリが足りない
                   InvalidData         サイズが  PiHeaderに書いて
                                       あるより小さい

                ○ NoError以外のときは、PiHeaderのcommentフィール
                   ドは 0 にセットされます。

                ○ 読み込んだコメントを含む  PiHeaderの内容の開放
                   には、graph_pi_free を使用してください。

                ★ graph_pi_load_* によってヘッダ情報をあらかじめ
                   格納しておく必要があります。

                例: graph_pi_load_pack参照

                △MEMORY:  コメントデータに必要なメモリブロックを
                  確保します。

                ○ 参照:  graph_pack_put_8(),
                          graph_pi_comment_load(),
                          graph_pi_free(),  graph_pi_load_pack(),
                          mag_free(), mag_load_pack(),
                          vga4_pack_put_8()

------------------------------------------------------------------------
□ graph_pi_free - Pi画像をメモリから開放

C:      void graph_pi_free( PiHeader * header, void far * image );

        ------------------------------------------98N 98H AT DOS-
        graph_pi_free
        ------------------------------------------<grppifre.asm>-

                ● 読み込んだPi画像のヘッダから、 (もし読み込んだ
                   なら)comment, (もし存在したら)機種予約エリアを
                   開放し、image(画像データ)も開放します。

                ← header   Piヘッダ
                   image    graph_pi_load_packでbufptrに返された
                            アドレス

                ○ 開放すると、headerの中の以下のメンバデータは 0
                   に初期化されます。
                   　comment, commentlen, maexlen, maex

                ○ 画像データだけを先に単独で開放した場合
                   ( hmem_free(FP_SEG(image))  )、 この関数の引数
                   image  にはそのアドレスは渡さずに、NULL を渡し
                   て下さい。

                ★ graph_pi_load_packによってメモリに読み込んだ画
                   像が不要になったら、必ずこの関数で開放してくだ
                   さい。

                例: graph_pi_load_pack参照

                ○ 参照:  graph_pack_put_8(),
                          graph_pi_comment_load(),
                          graph_pi_free(),  graph_pi_load_pack(),
                          mag_free(), mag_load_pack(),
                          vga4_pack_put_8()

------------------------------------------------------------------------
□ graph_pi_load_pack - 16色Pi画像fileのメモリへの読み込み(1バイト=2dot)

C:      int graph_pi_load_pack( const char * filename,
                               PiHeader * header, void far **bufptr );

        ------------------------------------------98N 98H AT DOS-
        graph_pi_load_pack                                   ○
        ------------------------------------------<grppilod.asm>-

                ● 16色  Pi形式ファイルの画像データ及びヘッダ情報
                   を読み込みます。

                ← filename  Pi画像ファイル名
                   header    ヘッダ情報格納場所
                   bufptr    画像データの先頭アドレスの格納先

                → NoError             読み込み成功(bufptrにアド
                                       レスを格納した)
                   FileNotFound        ファイルが見つからない
                   InvalidData         16色Piファイルではない
                   InsufficientMemory  メモリ不足

                ○ やなぎさわ氏の作成した画像フォーマット Pi 形式
                   のファイルを読み込みます。
                ○ コメントを読み込むには、この関数を実行した後で
                   graph_pi_comment_load を実行してください。
                ○ 読み込んだ画像データの表示は、
                   graph_pack_put_8() を用いて header.xsize / 2バ
                   イトずつ進めながら 1line分ずつ表示してください。
                ○ 読み込んだ  PiHeaderの内容および画像データの開
                   放には、graph_pi_free を使用してください。
                ○ パレットデータは、headerに入っています。表示す
                   るには、palette_set_all( header.palette ) を実
                   行してください。

                ○ 画像のために確保されるメモリは、
                   (xsize/2*(ysize+2))バイトです。

                ★ 256色データには対応していません。 画面比率デー
                   タにも対応していません。

                例: 画像を読み込んで表示する(98用)

････････････････････････････････････････････････････････････････････････
#include "master.h"
int main(void) {
    char piname[] = "test.pi";
    PiHeader piheader;
    void far * buf;
    char far * ptr;
    int y;
    int s = graph_pi_load_pack( piname, &piheader, &buf );
    if ( s == NoError ) {
        if ( piheader.commentlen ) {
            if ( graph_pi_comment_load( piname, &piheader ) == NoError ) {
                dos_puts( "コメント : " );
                dos_write(1, piheader.comment, piheader.commentlen );
                dos_puts( CRLF );
            } else {
                dos_puts( "コメントが変?"CRLF );
            }
        }
        graph_start();
        palette_set_all( &piheader.palette );
        palette_show();
        ptr = buf;
        for ( y = 0; y < piheader.ysize; ++y ) {
            graph_pack_put_8( 0, y, ptr, piheader.xsize );
            ptr += piheader.xsize / 2;
            ptr = FP_REGULAR(ptr);
        }
        graph_pi_free( &piheader, buf );
    } else if ( s == InsufficientMemory ) {
        dos_puts( "メモリが足りないの"CRLF );
    } else if ( s == InvalidData ) {
        dos_puts( "ファイルが 16色Piじゃありませんね"CRLF );
    } else if ( s == FileNotFound ) {
        dos_puts( "ファイルがみつかりません"CRLF );
    }
    return 0;
}
････････････････････････････････････････････････････････････････････････

                △MEMORY: 画像データ、 機種依存データに必要なメモ
                  リブロックを確保します。
                          また作業中、一時的に 17KB  のバッファを
                          確保します。

                ○ 参照:  graph_pack_put_8(),
                          graph_pi_comment_load(),
                          graph_pi_free(),  graph_pi_load_pack(),
                          mag_free(), mag_load_pack(),
                          vga4_pack_put_8()

------------------------------------------------------------------------
□ graph_plasma - 画面のドットずれ補正

C:      void graph_plasma(void);                           マクロ

        ------------------------------------------98N 98H AT DOS-
        graph_plasma                               Ｖ  × ×
        -----------------------------------------------------<->-

                ● I/Oポートを直接アクセスして、 グラフィック画面
                   とテキスト画面の表示位置を一致させます。

                ○ システム起動時は 1ドットずれていますが、現在の
                   状態を知ることができないし、普段一致させている
                   人もいるので、ドットずれ補正した後にわざわざず
                   らす必要はないでしょう。
                ○ 98はプラズマディスプレイのときにドットずれがな
                   い状態で起動するので、この名前になっています。

------------------------------------------------------------------------
□ graph_readdot, vga4_readdot - グラフィック画面の任意の地点の色を得る

C:      int graph_readdot( int x, int y );
C:      int vga4_readdot(int x,int y);

        ------------------------------------------98N 98H AT DOS-
        graph_readdot                              ○  × ＊
        ------------------------------------------<grprddot.asm>-
        vga4_readdot                               ×  × ○
        ------------------------------------------<vgcrddot.asm>-

                ● 指定座標の色コードを得ます。

                ← x,y  読み取る座標

                → 0〜15  読み取った色
                   -1     座標が範囲外

                ★ <98>8色の機械では、8〜15が返ります。

------------------------------------------------------------------------
□ graph_restore - EMSに退避したグラフィック画面の復元

C:      int graph_restore(void);

        ------------------------------------------98N 98H AT DOS-
        graph_restore                              ○  × ×
        ------------------------------------------<grpbakup.asm>-

                ● graph_backupによって退避したグラフィック画面を
                   復元し、その保持に使ったEMSメモリを開放します。

                → 1  成功
                   0  失敗(まだ退避してないなど)

------------------------------------------------------------------------
□ graph_setextmode - 9821拡張グラフィックモードの設定

C:      void graph_setextmode(unsigned v);                 マクロ

        ------------------------------------------98N 98H AT DOS-
        graph_setextmode                           ○  × ×
        -----------------------------------------------------<->-

                ● 現在の9821/A/C拡張モードを設定します。

                ← v  上位8bit:  BHの値
                      下位8bit:  ALの値

                ○ ビット内容については graph_extmode 参照
                ○ 9821/A/Cでなければ何もしません。

------------------------------------------------------------------------
□ graph_show - グラフィック画面を表示する

C:      void graph_show(void);

        ------------------------------------------98N 98H AT DOS-
        graph_show                                 ○  × ×
        -------------------------------------------<grpshow.asm>-

                ● BIOSを用いてグラフィック画面を表示します。

------------------------------------------------------------------------
□ graph_shown - グラフィック画面の表示状態を得る

C:      int graph_shown(void);

        ------------------------------------------98N 98H AT DOS-
        graph_shown                                ○  × ×
        ------------------------------------------<grpshown.asm>-

                ● グラフィック画面が現在表示されているかどうかを
                   得ます。

                → 1 表示
                   0 非表示

------------------------------------------------------------------------
□ graph_showpage, at98_showpage - グラフィック画面表示ページ設定

C:      void graph_showpage( int page );                   マクロ
C:      void at98_showpage( int page );

        ------------------------------------------98N 98H AT DOS-
        graph_showpage                             ○  × ＊
        -----------------------------------------------------<->-
        at98_showpage                              ×  × ○
        ------------------------------------------<at98scrl.asm>-

                ● 表示ページを指定します。
                   pageには、0 または 1 が指定できます。

                ○ <AT> graph_400line()などによって、640x400(以下)
                   になっている場合専用です。ハードウェアスクロー
                   ルによって、page切り替えをエミュレーションしま
                   す。この際、 at98_scroll()によるスクロール設定
                   を継承します。 また、VSYNC外に呼び出されると内
                   部でVSYNC内になるまで待ってから作業しているの
                   でかなり時間がかかります。

------------------------------------------------------------------------
□ graph_scroll, at98_scroll -  グラフィック画面をハードウェアスクロール
   する

C:      void graph_scroll( unsigned line1, unsigned adr1, unsigned adr2 );
C:      void at98_scroll( unsigned line1, unsigned adr1 );

        ------------------------------------------98N 98H AT DOS-
        graph_scroll                               ○  × ＊
        ------------------------------------------<grpscrol.asm>-
        at98_scroll                                ×  × ○
        ------------------------------------------<at98scrl.asm>-

                ● GDCの機能である画面分割機能を利用して、 グラフ
                   ィック画面をスクロールさせます。グラフィック画
                   面は２分割できるため、一つの画面上で二つの領域
                   を別々にスクロールさせることができます。横方向
                   は  16ドットで 1つアドレスがずれるため、16ドッ
                   ト単位でのみスクロールさせることができます。

                ← line1  第一領域のline数 ( 0 〜 graph_VramLines
                          )
                   adr1   第一領域の先頭アドレス(ワード単位。すな
                          わち実際のoffset addresを2で割った値)
                   adr2   <98>下部分の先頭 GDC オフセットアドレス

                ★ graph_400line や graph_200line などの、
                   graph_VramZoom  変数を設定する処理をあらかじめ
                   実行しておく必要があります。

                ★ <AT>98と違い、第二領域のアドレスが設定できませ
                   ん。このため、縦スクロールと横スクロールはでき
                   ますが、縦横同時にずらすと画面がずれます。
                ★ <AT>内部でVSYNCを待っています。このため、VSYNC
                   内に入ったタイミングで呼び出されると高速ですが、
                   そうでないときに呼び出されると低速です。

                ○ 縦スクロールは、上画面のアドレスを
                   (graph_VramLines-ライン数)*40に設定し、 下画面
                   の先頭を 0 にすることで行えます。

------------------------------------------------------------------------
□ graph_scrollup - グラフィック画面をハードウェア縦スクロールする

C:      void graph_scrollup( unsigned line1 );

        ------------------------------------------98N 98H AT DOS-
        graph_scrollup                             ○  × ＊
        ------------------------------------------<grpscrlu.asm>-

                ● GDCの機能である画面分割機能を利用して、 グラフ
                   ィック画面を縦にスクロールさせます。

                ← line   正常時に対して上にずらすライン数 ( 0 〜
                          graph_VramLines-1 )

                ★ graph_400line や graph_200line などの、
                   graph_VramZoom  を設定する処理をあらかじめ実行
                   しておく必要があります。

------------------------------------------------------------------------
□ graph_start, vga4_start - 16色グラフィック画面一括初期設定

C:      void graph_start(void);
C:      int vga4_start(int videomode, int xdots, int ydots);

        ------------------------------------------98N 98H AT DOS-
        graph_start                                Ｖ  × ＊
        ------------------------------------------<grpstart.asm>-
        vga4_start                                 ×  × ○
        ------------------------------------------<vgcstart.asm>-

                ● <98>開始のために、以下の処理を行います。
                   graph_plasma
                   palette_init
                   graph_showpage(0)
                   graph_accesspage(0)
                   graph_400line
                   graph_clear
                   graph_show

                   <AT>現在のビデオモードを記録し、ビデオモードを
                   変更、グラフィック画面描画に関する変数を設定し、
                   grc_setclip, dac_initを呼び出します。

                → 1  成功
                   0  ビデオモード変更に失敗

                ○ <AT>現在までのビデオモードを内部に記録します。
                ○ <AT>ビデオモード変更に成功した場合、設定する変
                   数などは以下の通りです。
                   graph_VramSeg   0xa000
                   graph_VramWidth xdots/8         横一列のバイト
                                                   数
                   graph_VramWords xdots*ydots/16  全体のワード数
                   graph_VramLines ydots           縦ドット数
                   graph_VramZoom  0または1        ビデオモード
                                                   0x0e(640x200)
                                                   に指定した場合
                                                   のみ、 1になり
                                                   ます。
                   grc_setclip(0,0,xdots-1,ydots-1)
                   VTextState      0x8000をOR      グラフィックモ
                                                   ード

                例:
                   ・通常の640x480x16colorの場合
                       vga4_start(0x12,640,480);
                   ・VESAの800x600x16colorの場合
                       vga4_start(0x6a,800,600);
                   ・640x200x16colorにしたい場合
                       vga4_start(0x0e,640,200);
                   ・全画面の640x400x16colorにしたい場合
                       vga4_start(0x0e,640,400),vga_vzoom_off();

                ○ 参照:  graph_end(), graph_enter(),
                          graph_leave(), vgc_start()

------------------------------------------------------------------------
□ graph_unpack_get_8, vga4_unpack_get_8 - バイト単位データ読み取り(8dot
   単位)

C:      void graph_unpack_get_8( int x, int y,
                                void far * linepat, int len );
C:      void vga4_unpack_get_8( int x, int y, void far * linepat, int len );

        ------------------------------------------98N 98H AT DOS-
        graph_unpack_get_8                         Ｖ  × ＊
        ------------------------------------------<grpuget8.asm>-
        vga4_unpack_get_8                          ×  × ○
        ------------------------------------------<vg4uget8.asm>-

                ● グラフィック画面の16色データを１バイト１色形式
                   にして読み込みます。

                ← x        左端座標( 8の倍数に切り捨てます )
                   y        描画 y 座標
                   linepat  色データを格納する先頭アドレス
                            　★lenバイトの領域を用意してください。
                   len      横ドット数( 8の倍数に切り捨てられます
                            )

                ★ クリッピングは上下は grc_setclip範囲、左右は画
                   面幅で行っています。
                   クリッピング範囲外の領域は読み込みません。

------------------------------------------------------------------------
□ graph_unpack_large_put_8 - バイト単位4倍角データ描画(8dot単位)

C:      void graph_unpack_large_put_8( int x, int y,
                                      const void far * linepat, int len );

        ------------------------------------------98N 98H AT DOS-
        graph_unpack_large_put_8                   Ｖ  × ×
        ------------------------------------------<grpulpt8.asm>-

                ● グラフィック画面に、１バイト１色形式のデータを
                   4倍角(縦横2倍)で書き込みます。

                ← x        左端座標( 8の倍数に切り捨てます )
                   y        描画 y 座標
                   linepat  色データの先頭アドレス
                   len      横ドット数( 8の倍数に切り捨てられます
                            )

                ★ クリッピングは上下は grc_setclip範囲、左右は画
                   面幅で行っています。

------------------------------------------------------------------------
□ graph_unpack_put_8, vga4_unpack_put_8 - バイト単位データ描画(8dot単位)

C:      void graph_unpack_put_8( int x, int y,
                                const void far * linepat, int len );
C:      void vga4_unpack_put_8( int x, int y,
                               const void far * linepat, int len );

        ------------------------------------------98N 98H AT DOS-
        graph_unpack_put_8                         Ｖ  × ＊
        ------------------------------------------<grpuput8.asm>-
        vga4_unpack_put_8                          ×  × ○
        ------------------------------------------<vg4uput8.asm>-

                ● グラフィック画面に、１バイト１色形式のデータを
                   書き込みます。

                ← x        左端座標( 8の倍数に切り捨てます )
                   y        描画 y 座標
                   linepat  色データの先頭アドレス
                   len      横ドット数( 8の倍数に切り捨てられます
                            )

                ★ クリッピングは上下は grc_setclip範囲、左右は画
                   面幅で行っています。

------------------------------------------------------------------------
□ graph_wank_putc - 圧縮半角文字描画

C:      void graph_wank_putc( int x, int y, int c );

        ------------------------------------------98N 98H AT DOS-
        graph_wank_putc                            Ｖ  × ×
        ------------------------------------------<grpwaput.asm>-

                ● グラフィック画面に8x8ドットの半角文字を描画し
                   ます。

                ← x,y    左上座標
                   c      文字

                ★ クリッピングは行っていません。
                ★ あらかじめ  wfont_entry_bfnt()による圧縮フォン
                   トの登録が必要です。

------------------------------------------------------------------------
□ graph_wank_putca - 圧縮半角文字描画(色指定)

C:      void graph_wank_putca( int x, int y, int ch, int color );

        ------------------------------------------98N 98H AT DOS-
        graph_wank_putca                           Ｖ  × ×
        ------------------------------------------<grpwapca.asm>-

                ● グラフィック画面に 8x8  ドットの半角文字を指定
                   した色で描画します。

                ← x,y    左上座標
                   ch     文字コード ( 0〜255 )
                   color  色( 0〜15 )

                ★ クリッピングは行っていません。
                ★ あらかじめ  wfont_entry_bfnt()による圧縮フォン
                   トの登録が必要です。

------------------------------------------------------------------------
□ graph_wank_puts - 圧縮半角文字列描画

C:      void graph_wank_puts( int x, int y, int step, const char * str );

        ------------------------------------------98N 98H AT DOS-
        graph_wank_puts                            Ｖ  × ×
        ------------------------------------------<grpwapts.asm>-

                ● グラフィック画面に8x8ドットの半角文字で文字列
                   を描画します。

                ← x,y    左上座標
                   step   文字間隔(8でぴったり連続します)
                   str    文字列の先頭アドレス

                ★ クリッピングは行っていません。
                ★ あらかじめ  wfont_entry_bfnt()による圧縮フォン
                   トの登録が必要です。

------------------------------------------------------------------------
□ graph_wank_putsa - 圧縮半角文字列描画(色指定)

C:      void graph_wank_putsa( int x, int y, int step,
                              const char * str, int color );

        ------------------------------------------98N 98H AT DOS-
        graph_wank_putsa                           Ｖ  × ×
        ------------------------------------------<grpwapsa.asm>-

                ● グラフィック画面に 8x8  ドットの半角文字列を指
                   定した色で描画します。

                ← x,y    左上座標
                   step   文字間隔(8でぴったり連続します)
                   str    文字列の先頭アドレス
                   color  色( 0〜15 )

                ★ クリッピングは行っていません。
                ★ あらかじめ  wfont_entry_bfnt()による圧縮フォン
                   トの登録が必要です。

------------------------------------------------------------------------
□ graph_wfont_plane - 圧縮半角文字描画のプレーン設定

C:      void graph_wfont_plane( int a, int b, int c )      マクロ

        ------------------------------------------98N 98H AT DOS-
        graph_wfont_plane                          Ｖ  × ×
        -----------------------------------------------------<->-

                ● 圧縮文字描画を行うプレーンを設定します。

                ← a   漢字フォント内の偶数ライン描画を行うプレー
                       ン
                   b   漢字フォント内の奇数ライン描画を行うプレー
                       ン
                        a,bは、共に以下の中から指定します。
                        (GC_RMW|GC_B)   セグメント 0a800h に描画
                        (GC_RMW|GC_R)   セグメント 0b000h に描画
                        (GC_RMW|GC_G)   セグメント 0b800h に描画
                        (GC_RMW|GC_I)   セグメント 0e000h に描画
                   c   GRCGのタイルレジスタの値指定。 4プレーンす
                       べてのこの値でうめられます。  デフォルトは
                       0ffh、すなわちすべてのビットONですが、この
                       値を0にすると、すべてのビットを0にすること
                       ができます。(黒い文字を書くときなどのため)

                ○ wfont_Plane1, wfont_Plane2,  wfont_Reg変数に代
                   入しているだけです。

------------------------------------------------------------------------
□ graph_wfont_put - 圧縮1文字描画

C:      void graph_wfont_put( int x, int y, const char * str );

        ------------------------------------------98N 98H AT DOS-
        graph_wfont_put                            Ｖ  × ×
        ------------------------------------------<grpwfput.asm>-

                ● グラフィック画面に、 文字列の最初の1文字を描画
                   します。
                   全角・半角のどちらも描画できます。

                ← x,y    左上座標
                   str    文字列の先頭アドレス

                ★ クリッピングは行っていません。
                ★ あらかじめ  wfont_entry_bfnt()による圧縮フォン
                   トの登録が必要です。

------------------------------------------------------------------------
□ graph_wfont_puts - 圧縮文字列描画

C:      void graph_wfont_puts( int x, int y, int step, const char * str );

        ------------------------------------------98N 98H AT DOS-
        graph_wfont_puts                           Ｖ  × ×
        ------------------------------------------<grpwfpts.asm>-

                ● グラフィック画面へ圧縮文字列を描画します。

                ← x,y    左上座標
                   step   文字間隔(全角文字の幅を基準にするので、
                          16でぴったり連続します。 半角文字はこの
                          指定の半分(端数切り捨て)だけ進みます)
                   str    文字列の先頭アドレス

                ★ 漢字半角には対応していません。
                ★ クリッピングは行っていません。
                ★ あらかじめ  wfont_entry_bfnt()による圧縮フォン
                   トの登録が必要です。

------------------------------------------------------------------------
□ graph_wkanji_put - 圧縮全角文字描画

C:      void graph_wkanji_put( int x, int y, const char * str );

        ------------------------------------------98N 98H AT DOS-
        graph_wkanji_put                           Ｖ  × ×
        ------------------------------------------<grpwkput.asm>-

                ● グラフィック画面へ圧縮全角文字を描画します。

                ← x,y    左上座標
                   str    文字列の先頭アドレス。この1文字目が描画
                          されます。

                ★ 漢字半角には対応していません。
                ★ クリッピングは行っていません。
                ★ あらかじめ  wfont_entry_bfnt()による圧縮フォン
                   トの登録が必要です。

------------------------------------------------------------------------
□ graph_wkanji_puts - 圧縮全角文字列描画

C:      void graph_wkanji_puts( int x, int y, int step, const char * str );

        ------------------------------------------98N 98H AT DOS-
        graph_wkanji_puts                          Ｖ  × ×
        ------------------------------------------<grpwkpts.asm>-

                graph_kanji_puts
                ● グラフィック画面に、全角文字のみで構成された文
                   字列を圧縮して描画します。

                ← x,y    左上座標
                   step   文字間隔(16でぴったり連続します)
                   str    文字列の先頭アドレス

                ★ 漢字半角には対応していません。
                ★ クリッピングは行っていません。
                ★ あらかじめ  wfont_entry_bfnt()による圧縮フォン
                   トの登録が必要です。

------------------------------------------------------------------------
□ graph_xlat_dot - グラフィック画面の点の色を置き換える

C:      void graph_xlat_dot( int x, int y, char * trans );

        ------------------------------------------98N 98H AT DOS-
        graph_xlat_dot                             ○  × ＊
        ------------------------------------------<grpxldot.asm>-

                ● 任意の地点の色番号を、 配列transの添え字として
                   その内容の色に置き換えます。
                   transは 0〜15の 16要素が必要で、値は下位  4bit
                   のみが有効です。

                ★ 画面の大きさを 640x400ドットとしてクリッピング
                   しています。

------------------------------------------------------------------------
□ graph_xorboxfill - XOR矩形塗り潰し

C:      void graph_xorboxfill( int x1,int y1, int x2,int y2, int color );

        ------------------------------------------98N 98H AT DOS-
        graph_xorboxfill                           Ｖ  × ＊
        ------------------------------------------<grpxorbf.asm>-

                ● グラフィック画面の長方形領域に対して、指定色で
                   xor をかけます。

                ← x1,y1  頂点1
                   x2,y2  頂点2
                   color  xorする値(0〜15)

                ★ クリッピングは、現在の画面全体で行っています。

                ○ VGAには vgc_setcolorに VGA_XOR  を指定すること
                   で XOR描画ができますが、98では XOR指定ができな
                   いため、単独で用意しました。

------------------------------------------------------------------------
□ mag_free - MAG画像をメモリから開放

C:      void mag_free( MagHeader * header, void far * image );

        ------------------------------------------98N 98H AT DOS-
        mag_free
        -------------------------------------------<magfree.asm>-

                ● 読み込んだMag画像のヘッダから comment を開放し、
                   image(画像データ)も開放します。

                ← header   MAGヘッダ
                   image    mag_load_packでbufptrに返されたアドレ
                            ス

                ○ 開放すると、headerの中の以下のメンバデータは 0
                   に初期化されます。
                   　commentseg, commentlen

                ○ 画像データだけを先に単独で開放した場合
                   ( hmem_free(FP_SEG(image))  )、 この関数の引数
                   image  にはそのアドレスは渡さずに、NULL を渡し
                   て下さい。

                ★ mag_load_packによってメモリに読み込んだ画像が
                   不要になったら、必ずこの関数で開放してください。

                ○ 参照:  graph_pack_put_8(),
                          graph_pi_comment_load(),
                          graph_pi_free(),  graph_pi_load_pack(),
                          mag_free(), mag_load_pack(),
                          vga4_pack_put_8()

------------------------------------------------------------------------
□ mag_load_pack - 16色MAG画像fileのメモリへの読み込み

C:      int mag_load_pack( const char * filename,
                          MagHeader * header, void far ** bufptr );

        ------------------------------------------98N 98H AT DOS-
        mag_load_pack                                        ○
        ------------------------------------------<magloadp.asm>-

                ● 16色 MAG形式ファイルの画像データ及びヘッダ情報、
                   コメントを読み込みます。

                ← filename  MAG画像ファイル名
                   header    ヘッダ情報格納場所
                   bufptr    画像データの先頭アドレスの格納先

                → NoError             読み込み成功(bufptrにアド
                                       レスを格納した)
                   FileNotFound        ファイルが見つからない
                   InvalidData         16色MAGファイルではない
                   InsufficientMemory  メモリ不足

                ○ W.Rinn氏の作成した画像フォーマット MAG (MAKI02)
                   形式のファイルを読み込みます。
                ○ 画像データは、MAG フォーマット自体の都合により、
                   横座標が 8dot単位で格納されています。このため、
                   データが部分セーブされたものである場合、
                   (header.x1 and not 7)から(header.x2 or  7)まで
                   入っています。左側 (header.x1 and 7)ドットと、
                   右側(7  - (header.x2 and 7))ドットは、表示しな
                   いことになっていますが…(笑)。
                ○ コメントは、header.commentseg のセグメントのオ
                   フセット0のアドレスから、header.commentlenバイ
                   ト格納されています。
                ○ 読み込んだ画像データの表示は、
                   graph_pack_put_8() を用いて header.xsize / 2バ
                   イトずつ進めながら 1line分ずつ表示してください。
                ○ 読み込んだ画像データの開放には、
                   hmem_free(FP_SEG(bufptr));を実行してください。
                ○ パレットデータは、headerに入っています。表示す
                   るには、palette_set_all( header.palette ) を実
                   行してください。

                ○ 画像のために確保されるメモリは、(xsize/2*ysize)
                   バイトです。

                ★ 256色データには対応していません。

                例: 画像を読み込んで表示する(98用)

････････････････････････････････････････････････････････････････････････
#include "master.h"
int main(void) {
    char magname[] = "test.mag";
    MagHeader mag;
    void far * buf;
    char far * ptr;
    int y;
    int s = mag_load_pack( magname, &mag, &buf );
    if ( s == NoError ) {
        if ( mag.commentlen ) {
            dos_puts( "コメント : " );
            dos_write(1, SEG2FP(mag.commentseg), mag.commentlen );
            dos_puts( CRLF );
        }
        graph_start();
        palette_set_all( &mag.palette );
        palette_show();
        ptr = buf;
        for ( y = mag.y1 ; y <= mag.y2 ; ++y ) {
            graph_pack_put_8( mag.x1 & ~7, y, ptr, mag.xsize );
            ptr = FPADD(ptr, mag.xsize/2);
        }
        mag_free( &mag, buf );
    } else if ( s == InsufficientMemory ) {
        dos_puts( "メモリが足りないの"CRLF );
    } else if ( s == InvalidData ) {
        dos_puts( "ファイルが 16色magじゃありませんね"CRLF );
    } else if ( s == FileNotFound ) {
        dos_puts( "ファイルがみつかりません"CRLF );
    }
    return 0;
}
････････････････････････････････････････････････････････････････････････

                △MEMORY:  画像データに必要なメモリブロックを確保
                  します。
                          また作業中、一時的に 17KB  のバッファを
                          確保します。

                ○ 参照:  graph_pack_put_8(),
                          graph_pi_comment_load(),
                          graph_pi_free(),  graph_pi_load_pack(),
                          mag_free(), mag_load_pack(),
                          vga4_pack_put_8()

------------------------------------------------------------------------
□ vga4_bfnt_putc - BFNT文字描画(上書き)

C:      void vga4_bfnt_putc( int x, int y, int c, int color );

        ------------------------------------------98N 98H AT DOS-
        vga4_bfnt_putc                             ×  × ○
        ------------------------------------------<vg4bputc.asm>-

                ● ANK文字を描画します。文字の背景も塗り潰します。

                ← x,y    描画開始左上座標
                   c      半角文字
                   color  背景色*16+文字色(色は0〜15)

                ○ 横8dot単位の境界線に従って背景は塗り潰されます。
                ★ フォントデータはあらかじめ   font_entry_bfnt()
                   などで登録しておいてください。
                ★ 文字が重なると結果はくずれる場合があります。

------------------------------------------------------------------------
□ vga4_bfnt_puts - BFNT文字列描画(上書き)

C:      void vga4_bfnt_puts( int x, int y, int step,
                            const char * anks, int color );

        ------------------------------------------98N 98H AT DOS-
        vga4_bfnt_puts                             ×  × ○
        ------------------------------------------<vg4bputs.asm>-

                ● ANK文字列を描画します。 文字の背景も塗り潰しま
                   す。

                ← x,y    描画開始左上座標
                   step   文字ごとに進めるドット数(0=進めない)
                   anks   ANK文字列
                   color  背景色*16+文字色(色は0〜15)

                ○ 横8dot単位の境界線に従って背景は塗り潰されます。

                ★ フォントデータはあらかじめ   font_entry_bfnt()
                   などで登録しておいてください。
                ★ 文字が重なると結果はくずれる場合があります。

------------------------------------------------------------------------
□ vga4_byte_move - 矩形部分の転送(横8dot単位)

C:      void vga4_byte_move(  int  x1,int  y1,  int  x2,int   y2,
                            int tox,int toy );

        ------------------------------------------98N 98H AT DOS-
        vga4_byte_move                             ×  × ○
        ------------------------------------------<vg4bmove.asm>-

                ● VRAMの長方形領域を他の座標に転送します。座標範
                   囲の検査や、重なりは考慮していませんので注意し
                   てください。

                ← x1,y1    転送元の第1頂点
                   x2,y2    転送元の第2頂点
                   tox,toy  第1頂点の転送先

------------------------------------------------------------------------
□ vga_dc_modify - VGAレジスタのビット操作

C:      void vga_dc_modify( int num, int andval, int orval );

        ------------------------------------------98N 98H AT DOS-
        vga_dc_modify                              ×  × ○
        ------------------------------------------<vgasetli.asm>-

                ● VGAのレジスタのビットをand, or操作します。

                ← num     レジスタインデックス(port 3d4h)
                   andval  ANDする値
                   orval   ORする値
                   値は下位8bitのみ有効です。

                ○ 詳しくは、 VGAのディスプレイコントローラに関す
                   る資料を入手してください。

------------------------------------------------------------------------
□ vga_setline - 表示ライン数の設定

C:      void vga_setline( unsigned lines );

        ------------------------------------------98N 98H AT DOS-
        vga_setline                                ×  × ○
        ------------------------------------------<vgasetli.asm>-

                ● VGAの表示ライン数を変更します。

                ← lines  表示ライン数(1〜819, 普段は 480)

                ○ このライン数を変更すると、画面は上からそのライ
                   ン数だけ表示されます。
                ○ そのライン数が画面全体に広がるのではなく、その
                   ライン数以下は表示をマスクしているだけです。

------------------------------------------------------------------------
□ vga_startaddress - 表示開始アドレスの設定

C:      void vga_startaddress( unsigned address );

        ------------------------------------------98N 98H AT DOS-
        vga_startaddress                           ×  × ○
        ------------------------------------------<vgastadr.asm>-

                ● 画面の表示開始アドレスを指定します。

                ← address  画面左上隅にする VRAMのオフセットアド
                            レス(普段は0)

                ○ mode 12hだと、 819lineぶんあるグラフィック画面
                   の 480lineしか表示されていません。ここで、この
                   アドレスを変更すると、 819lineの中であれば自由
                   にスクロールすることができることになります。

                ○ たとえば vga_setline(400)を実行し、
                   vga_startaddress( 0 ) と
                   vga_startaddress( 0x8000 ) を切り替えて2pageあ
                   ることにすれば、98用のVRAM直接アクセス型プログ
                   ラムからの移植を助けることもできます。(VRAM
                   segmentは page 0=0xa000, page 1=0xa800になりま
                   す)

------------------------------------------------------------------------
□ vga_vzoom_off - 縦2倍拡大モードOFF

C:      void vga_vzoom_off(void);                          マクロ

        ------------------------------------------98N 98H AT DOS-
        vga_vzoom_off                              ×  × ○
        -----------------------------------------------------<->-

                ● vga_vzoom_on による縦倍状態を解除します。

                ○ 実行後、graph_VramZoom 変数は 0 に設定されます。

------------------------------------------------------------------------
□ vga_vzoom_on - 縦2倍拡大モードON

C:      void vga_vzoom_on(void);                           マクロ

        ------------------------------------------98N 98H AT DOS-
        vga_vzoom_on                               ×  × ○
        -----------------------------------------------------<->-

                ● グラフィック16色モード時、 1ドットの縦の大きさ
                   を倍にします。これにより、640x200や、800x300と
                   いった画面解像度にすることができます。

                ○ 実行後、graph_VramZoom 変数は 1 に設定されます。

                ★ ビデオカードによってはうまく動作しないかもしれ
                   ません。

------------------------------------------------------------------------
□ vgc_kanji_putc - 全角文字の描画

C:      void vgc_kanji_putc(int x, int y, unsigned kanji );

        ------------------------------------------98N 98H AT DOS-
        vgc_kanji_putc                             ×  × ○
        ------------------------------------------<vgckputc.asm>-

                ● 全角文字(16x16dot)をグラフィック画面に描画しま
                   す。

                ← x,y   描画開始左上座標
                   ank   全角文字コード(shift-JISのみ)

                ○ 色は、vgc_setcolor で指定します。
                ○ 日本語テキストモード以外で処理するためには、日
                   本語テキストモードのうちにfont_at_init()を実行
                   しておく必要があります。

                ★ クリッピングは行っていません。

------------------------------------------------------------------------
□ vgc_kanji_puts - 全角文字列の描画

C:      void vgc_kanji_puts( int x, int y, int step, const char * kanji );

        ------------------------------------------98N 98H AT DOS-
        vgc_kanji_puts                             ×  × ○
        ------------------------------------------<vgckputs.asm>-

                ● 全角文字列をグラフィック画面に描画します。

                ← x,y   描画開始左上座標
                   step  1文字ごとに右に進めるドット数(0だとすべ
                         て同じ位置に描画)
                   kanji 全角文字のみから構成する文字列

                ○ 色は、vgc_setcolor で指定します。
                ○ 日本語テキストモード以外で処理するためには、日
                   本語テキストモードのうちにfont_at_init()を実行
                   しておく必要があります。
                ★ フォントデータはあらかじめ   font_entry_bfnt()
                   などで登録しておいてください。

                ★ クリッピングは行っていません。

------------------------------------------------------------------------
□ vgc_start - 640x480dot 16色グラフィック設定

C:      void vgc_start(void);                              マクロ

        ------------------------------------------98N 98H AT DOS-
        vgc_start                                  ×  × Ｖ
        -----------------------------------------------------<->-

                ● VGAを 640x480dot, 16色グラフィックとして初期化
                   します。

                ○ 具体的には、vga4_start(0x12,640,480)を実行しま
                   す。

                ○ 参照:  graph_end(), graph_enter(),
                          graph_leave(), vga4_start()


------------------------------------------------------------------------
■ アナログ16色パレット制御 ■■■■■■■■■■■■■■■■■■■■■■

        　16色グラフィック画面では、98だと4096色、VGAだと26万色の
        中から、同時には16個を選んで表示できます。
        　ここで説明する関数は、その内容をすべて配列変数に保存し、
        この値を書き換え、 表示関数(palette_show)を呼び出すことで
        実際に反映させる形態をとっています。
        　また、 実際のハードウェアに装備されているパレットと異な
        り、全体の明るさを別に指定できます(PaletteTone変数)。
        　実際にこれらの関数を実行する場合は、最初に palette_init
        を実行するようにしてください。

------------------------------------------------------------------------
□ 構造体／グローバル変数

unsigned PaletteTone;            パレットの明るさ
                                 0(黒)〜100(純色)〜200(白)
const char PalettesInit[16][3];  パレットの初期値(N88BASIC(86)風)
unsigned char Palettes[16][3];   パレットの現在の値。
                                 palette_init()を実行する前は真っ
                                 黒になっています。
                                 並びは r,g,bの順で、 各値は  0〜
                                 255 です。
int PaletteNote;                 液晶8階調モードフラグ
                                 0=CRT
                                 1=<98>液晶8階調, <AT>色反転

------------------------------------------------------------------------
□ palette_100, dac_100 - 明るさを100%にする

C:      void palette_100(void);                            マクロ
C:      void dac_100(void);                                マクロ

        ------------------------------------------98N 98H AT DOS-
        palette_100                                Ｖ     ＊
        dac_100                                    ×  × ○
        -----------------------------------------------------<->-

                ● パレットの明るさを 100%にします。

------------------------------------------------------------------------
□ palette_black, dac_black - 画面を真っ黒にする

C:      void palette_black(void);                          マクロ
C:      void dac_black(void);                              マクロ

        ------------------------------------------98N 98H AT DOS-
        palette_black                              Ｖ     ＊
        dac_black                                  ×  × ○
        -----------------------------------------------------<->-

                ● パレットの明るさを  0%にすることで画面を真っ黒
                   にします。あとで100%に戻さないと、いつまでたっ
                   ても真っ黒です。

------------------------------------------------------------------------
□ palette_black_in, dac_black_in - 画面を黒からフェードインする

C:      void palette_black_in( unsigned speed );
C:      void dac_black_in( unsigned speed );

        ------------------------------------------98N 98H AT DOS-
        palette_black_in                           Ｖ     ＊
        -------------------------------------------<blackin.asm>-
        dac_black_in                               ×  × ○
        -------------------------------------------<dacblin.asm>-

                ● 最初にパレットのトーンを 0(黒)に設定し、徐々に
                   100(本来の色)へと変化させます。

                ← speed 変化させる速さ
                         0 が最速で、1  以上にするとパレットを  1
                         段階変化させるのに speed 回の VSYNC を待
                         ちます。  つまり、 speed * 16 回の VSYNC
                         だけの時間を消費します。

                ○ 内部で  palette_show  と  vsync_wait,   または
                   dac_show と vga_vsync_wait を呼んでいます。
                ★ 実行後、トーンは 100%になります。

------------------------------------------------------------------------
□ palette_black_out, dac_black_out - 画面を黒にフェードアウトする

C:      void palette_black_out( unsigned speed );
C:      void dac_black_out( unsigned speed );

        ------------------------------------------98N 98H AT DOS-
        palette_black_out                          Ｖ     ＊
        ------------------------------------------<blackout.asm>-
        dac_black_out                              ×  × ○
        ------------------------------------------<dacblout.asm>-

                ● 最初にパレットのトーンを 100(本来の色)に設定し、
                   徐々に 0(黒)へと変化させます。変化させる速さは
                   speed で指定します。

                ← speed 変化させる速さ
                         0 が最速で、1  以上にするとパレットを  1
                         段階変化させるのに speed 回の VSYNC を待
                         ちます。  つまり、 speed * 16 回の VSYNC
                         だけの時間を消費します。

                ○ 内部で  palette_show  と  vsync_wait,   または
                   dac_show と vga_vsync_wait を呼んでいます。

                ★ 実行後、トーンは 0%になります。このため、 この
                   後トーンを再設定しない限りパレットをどんな値に
                   設定しても画面は黒いままになるので注意が必要で
                   す。

------------------------------------------------------------------------
□ palette_entry_rgb - RGBファイルを読み込む

C:      int palette_entry_rgb( const char * filename );

        ------------------------------------------98N 98H AT DOS-
        palette_entry_rgb                                    ○
        -------------------------------------------<rgbload.asm>-

                ● RGBファイルを読み込んで、グローバル変数
                   Palettesに設定します。

                ← RGBファイル名

                → NoError      成功
                   FileNotFound 指定された RGB ファイルがオープン
                   できない

                ★ 表示するためには  palette_show()を使用してくだ
                   さい。

                ★ RGBファイルは、以下のような仕様を要求します。
                     ・拡張子 .RGB で、48バイトのファイル
                       内容は、3バイトで1色を表し、16個並ぶ。
                       1色は、Red, Green, Blue  の各要素を  0〜15
                       (0h〜0fh)で表す。

------------------------------------------------------------------------
□ palette_init, dac_init - パレット変数の初期化

C:      void palette_init(void);
C:      void dac_init(void);

        ------------------------------------------98N 98H AT DOS-
        palette_init                               Ｖ     ＊
        -------------------------------------------<palinit.asm>-
        dac_init                                   ×  × ○
        -------------------------------------------<dacinit.asm>-

                ● アナログパレットを使用する準備をします。
                   <98>   Palettes に、PalettesInit  の内容を複写
                          し、graph_analog()を実行し、PaletteTone
                          を  100にした後、palette_show()を実行し
                          ます。
                   <AT>   Palettesに PalettesInit の内容を設定し、
                          トーンを100%にし、dac_showを実行します。
                          また、パレットコード16を黒にし、 ボーダ
                          ーカラーを16にします。

------------------------------------------------------------------------
□ palette_set - パレットを一つ設定する

C:      void palette_set( int num, int r, int g, int b );  マクロ

        ------------------------------------------98N 98H AT DOS-
        palette_set
        -----------------------------------------------------<->-

                ● パレットに値を一つ設定します。表示は
                   palette_showを使用してください。

------------------------------------------------------------------------
□ palette_set_all - パレットを全部設定する(256階調)

C:      void palette_set_all( char pal[48] );              マクロ

        ------------------------------------------98N 98H AT DOS-
        palette_set_all
        -----------------------------------------------------<->-

                ● パレットに16色すべての情報を設定します。表示は
                   palette_showを使用してください。

                ← pal  パレット16個(R,G,B各値の最大値が  255であ
                        るデータ)

------------------------------------------------------------------------
□ palette_set_all_16 - パレットを全部設定する(16階調)

C:      void palette_set_all_16( char pal[48] );

        ------------------------------------------98N 98H AT DOS-
        palette_set_all_16
        ------------------------------------------<palset16.asm>-

                ● パレットに16色すべての情報を設定します。表示は
                   palette_showを使用してください。

                ← pal  パレット16個(R,G,B各値の最大値が 15である
                        データ)

------------------------------------------------------------------------
□ palette_settone, dac_settone - パレットの明るさを設定する

C:      void palette_settone( int tone );                  マクロ
C:      void dac_settone( int tone );                      マクロ

        ------------------------------------------98N 98H AT DOS-
        palette_settone                            Ｖ     ＊
        dac_settone                                ×  × ○
        -----------------------------------------------------<->-

                ● PaletteToneに値を設定し、画面に反映します。

------------------------------------------------------------------------
□ palette_show, dac_show - パレット変数の画面への反映

C:      void palette_show(void);
C:      void dac_show(void);

        ------------------------------------------98N 98H AT DOS-
        palette_show                               Ｖ     ＊
        -------------------------------------------<palshow.asm>-
        dac_show                                   ×  × ○
        -------------------------------------------<dacshow.asm>-

                ● Palettes,PaletteToneの内容に従って、パレットの
                   ハードウェアに色を設定します。
                   PaletteNote が 1ならば次のように補正します。

                ○ <98> PaletteNote が 1  ならば液晶8階調用に補正
                   して初期化します。液晶8階調補正対象機種は、NEC
                   製  PC-9801NS,NS/E,NS/T,NV,NA,NL,NS/L,NS/R の8
                   機種です。
                ○ <AT> PaletteNote が 1ならば、 パレットの値を反
                   転します。

                ★ <AT>グラフィックモードでしか動作しません
                   (vga4_start(), VTextState変数参照)

------------------------------------------------------------------------
□ palette_show100 - パレット変数の画面への反映(100%固定)

C:      void palette_show100(void);

        ------------------------------------------98N 98H AT DOS-
        palette_show100                            Ｖ     ×
        ------------------------------------------<palsh100.asm>-

                ● Palettesの内容に従って、パレットのハードウェア
                   に色を設定します。
                   PaletteToneは無視し、100%と見なします。

                ★ palette_showより幾分高速です。
                   速度のためだけに存在します。
                ★ 液晶モードには対応していません。

------------------------------------------------------------------------
□ palette_white, dac_white - 画面を真っ白にする

C:      void palette_white(void);                          マクロ
C:      void dac_white_white(void);                        マクロ

        ------------------------------------------98N 98H AT DOS-
        palette_white                              Ｖ     ＊
        dac_white                                  ×  × ○
        -----------------------------------------------------<->-

                ● パレットの明るさを  200%にすることで画面を真っ
                   白にします。あとで100%に戻さないと、いつまでた
                   っても真っ白です。

------------------------------------------------------------------------
□ palette_white_in, dac_white_in - 画面を白からフェードインする

C:      void palette_white_in( unsigned speed );
C:      void dac_white_in( unsigned speed );

        ------------------------------------------98N 98H AT DOS-
        palette_white_in                           Ｖ     ＊
        -------------------------------------------<whitein.asm>-
        dac_white_in                               ×  × ○
        -------------------------------------------<dacwhin.asm>-

                ● 最初にパレットのトーンを 200(白)に設定し、徐々
                   に 100(本来の色)へと変化させます。変化させる速
                   さはspeed で指定します。

                ← speed 変化させる速さ
                         0 が最速で、1  以上にするとパレットを  1
                         段階変化させるのに speed 回の VSYNC を待
                         ちます。  つまり、 speed * 16 回の VSYNC
                         だけの時間を消費します。

                ○ 内部で  palette_show  と  vsync_wait,   または
                   dac_show と vga_vsync_wait を呼んでいます。

                ★ 実行後、トーンは 100%になります。

------------------------------------------------------------------------
□ palette_white_out, dac_white_out - 画面を白にフェードアウトする

C:      void palette_white_out( unsigned speed );
C:      void dac_white_out( unsigned speed );

        ------------------------------------------98N 98H AT DOS-
        palette_white_out                          Ｖ     ＊
        ------------------------------------------<whiteout.asm>-
        dac_white_out                              ×  × ○
        ------------------------------------------<dacwhout.asm>-

                ● 最初にパレットのトーンを 100  (本来の色)に設定
                   し、徐々に 200 (白)へと変化させます。

                ← speed 変化させる速さ
                         0 が最速で、1  以上にするとパレットを  1
                         段階変化させるのに speed 回の VSYNC を待
                         ちます。  つまり、 speed * 16 回の VSYNC
                         だけの時間を消費します。

                ○ 内部で  palette_show  と  vsync_wait,   または
                   dac_show と vga_vsync_wait を呼んでいます。

                ★ 実行後、トーンは 200%になります。このため、 こ
                   の後トーンを再設定しない限りパレットをどんな値
                   に設定しても画面は白いままになるので注意が必要
                   です。


------------------------------------------------------------------------
■ PC-9801 ノーマルモード常駐パレット操作 ■■■■■■■■■■■■■■■

        ●常駐パレットとは
        　PC-9801ノーマルモードでは、パレットは書き込み専用であり、
        読むことができません。(無理に読んでも異なる値になる)
        　このため、プログラムが終了したあと、 画面に残った絵を他
        のプログラムが利用したくても、 色が分からないという問題が
        あります。これを解決するため、 パソコン通信上で有志が決め
        た、 書き込んだパレットのコピーをメモリ内に保存しておく規
        格です。
        　私はこの出所を正確に知らないのですが、 このきまりに従っ
        たソフトがパソコン通信では結構あるので、 対応したというわ
        けです。

------------------------------------------------------------------------
□ 構造体／グローバル変数

unsigned ResPalSeg;     常駐パレットの存在するセグメントアドレス。
                        0なら不在か、または未検索。

------------------------------------------------------------------------
□ respal_create - 常駐パレットの作成

C:      int respal_create(void);

        ------------------------------------------98N 98H AT DOS-
        respal_create                                     × ５
        ------------------------------------------<rspexist.asm>-

                ● 常駐パレットを作成します。
                   すでに存在する場合、なにもしません。
                   存在しない場合、メインメモリの末尾の64バイトの
                   メモリを確保して作成します。

                → 0  メモリ不足で失敗
                   1  作成した(パレット等の値は不定)
                   2  すでに存在している

                ★ 常駐パレットを作成した場合、内容は書き込みませ
                   ん。respal_set_palettes()によって master.libで
                   管理するパレットのコピーを書き込むことができま
                   す。

                ★ master.libのメモリマネージャを呼び出す関数を
                   mem_assignなしで呼び出すと、メモリが全く空いて
                   いないことが多いので、起動してからなるべく早い
                   時期に実行したほうがいいでしょう。

------------------------------------------------------------------------
□ respal_exist - 常駐パレットの存在検査

C:      int respal_exist(void);

        ------------------------------------------98N 98H AT DOS-
        respal_exist                                      × ５
        ------------------------------------------<rspexist.asm>-

                ● 常駐パレットを検索します。
                   UMBは検索しません。
                   見つかったら常駐しているセグメント値を、見つか
                   らなければ 0 を返します。

------------------------------------------------------------------------
□ respal_free - 常駐パレットの開放

C:      void respal_free(void);

        ------------------------------------------98N 98H AT DOS-
        respal_free                                       × ５
        -------------------------------------------<rspfree.asm>-

                ● 常駐パレットを開放します。
                   まだ検索されていない場合、検索も行います。
                   存在しなければなにもしません。

------------------------------------------------------------------------
□ respal_get_palettes - 常駐パレットからパレット変数への読み込み

C:      void respal_get_palettes(void);

        ------------------------------------------98N 98H AT DOS-
        respal_get_palettes                        ○     ×
        ------------------------------------------<rspgetpa.asm>-

                ● 常駐パレットに書かれた、  トーンとパレット値を
                   Palettes, PaletteToneに設定します。
                   内部で respal_exist を呼び出しています。
                   常駐パレット存在しないと何もしません。

------------------------------------------------------------------------
□ respal_set_palettes - パレット変数から常駐パレットへの書き込み

C:      void respal_set_palettes(void);

        ------------------------------------------98N 98H AT DOS-
        respal_set_palettes                        ○     ×
        ------------------------------------------<rspsetpa.asm>-

                ● Palettes,  PaletteToneの値を常駐パレットに書き
                   込みます。
                   事前に常駐パレットが respal_exist によって検索
                   されているか、respal_create によって作成されて
                   いなければ何もしません。


------------------------------------------------------------------------
■ PC-9801 外字処理 ■■■■■■■■■■■■■■■■■■■■■■■■■■

        　PC-9801シリーズは、テキストフォントに外字が定義できます。
        　外字領域は、 カタログに外字が63文字と表記されている機種
        では  64文字分、188文字と表記されている機種では 256文字分
        のメモリが用意されています。
        　ところが、テキスト画面へ表示しようとすると、00h と  80h
        の二つの文字が半角 'V' に化けてしまいます。これは、VRAMに
        書き込む値が半角'V'と全く同じコードになってしまうことと、
        外字より半角が優先されることから来ます。
        　グラフィックとして描画するためのフォント記憶領域として
        使う場合は問題ありません。
        　EPSONの機種では、0,1,16,17,128,129,144,145の  8文字が登
        録できないものがあります。 この場合は表示どころの騒ぎでは
        ありません。:-)
        　このため、通常はこれらのコードは避けて使用してください。
        　また、通常は外字を定義する前に内容を gaiji_backup  で保
        存して、外字の使用を終了したら gaiji_restore で復元してく
        ださい。DOSのテキスト画面のフォントを外字で置換えている人
        がいますので。

------------------------------------------------------------------------
□ gaiji_backup - 外字の退避

C:      int gaiji_backup(void);

        ------------------------------------------98N 98H AT DOS-
        gaiji_backup                               ○  × × ○
        ------------------------------------------<gjbackup.asm>-

                ● メインメモリに外字形状を待避します。

                → 1 成功
                   0 失敗(すでに待避されている, メモリがない )

                △MEMORY: 512パラグラフ(=8KB)のブロックを確保しま
                  す。

------------------------------------------------------------------------
□ gaiji_entry_bfnt - 外字をBFNTファイルから登録する

C:      int gaiji_entry_bfnt( const char * filename );

        ------------------------------------------98N 98H AT DOS-
        gaiji_entry_bfnt                           ○  × × ○
        ------------------------------------------<gjentryb.asm>-

                ● 指定形式のBFNTファイル(  1.6に依るがバージョン
                   は無視している, モノクロ, 16x16dot, 0から255番
                   に固定, 拡張ヘッダの有無は問わず(内容は無視) )
                   を読み込んで、外字に一括登録します。このときに
                   一時的に  smem_wget()によってメモリを8KB確保し
                   ます。また、file_ropen()を呼び出しているので、
                   file_ropen()の規定に従った準備をしてください。

                → 1 成功
                   0 失敗( メモリない/ファイルが開けない/指定形式
                   のBFNTじゃない )

                ★ この関数は、現在の外字の退避を行いません。退避
                   には gaiji_backup()などを利用して下さい。

------------------------------------------------------------------------
□ gaiji_putc - 外字で1文字表示(属性なし)

C:      void gaiji_putc( unsigned x, unsigned y, unsigned c );

        ------------------------------------------98N 98H AT DOS-
        gaiji_putc                                 ○     ×
        --------------------------------------------<gjputc.asm>-

                ● テキスト画面の y行目(0 が一番上)の x桁目(0  が
                   一番左)の地点に、外字を直接書き込みます。

                ← x,y  表示テキスト座標
                   c    文字コード(0〜255)

                ○ 書き込む地点の色、属性は変化しません。
                ○ c に指定した値が 0と128のときは、 外字ではなく
                   'V'が表示されます。

                ★ 画面外を指定すると、関係ないメモリ内容を破壊す
                   ることになるかもしれません。

------------------------------------------------------------------------
□ gaiji_putca - 外字で1文字表示(属性あり)

C:      void gaiji_putca( unsigned x, unsigned y, unsigned c, unsigned atrb );

        ------------------------------------------98N 98H AT DOS-
        gaiji_putca                                ○     ×
        -------------------------------------------<gjputca.asm>-

                ● テキスト画面の y行目(0 が一番上)の x桁目(0  が
                   一番左)の地点に、 属性atrbで外字を直接書き込み
                   ます。

                ← x,y   表示テキスト座標
                   c     文字コード(0〜255)
                   atrb  属性

                ○ c に指定した値が 0と128のときは、 外字ではなく
                   'V'が表示されます。

                ★ 画面外を指定すると、関係ないメモリ内容を破壊す
                   ることになるかもしれません。

------------------------------------------------------------------------
□ gaiji_putni - 外字で数字列を表示(幅指定あり,属性なし)

C:      void gaiji_putni( unsigned x, unsigned y,  unsigned  val,
                         unsigned width );

        ------------------------------------------98N 98H AT DOS-
        gaiji_putni                                ○     ×
        -------------------------------------------<gjputni.asm>-

                ● テキスト画面に外字で数字を直接書き込みます。
                   　書き込む地点の色、属性は変化しません。

                ← x      左端の桁の画面上の位置(0=画面左端)
                   y      画面上の行位置(0=画面上端)
                   val    表示したい数値(0〜65535)
                   width  表示する桁数 (数値の下から width 桁が表
                          示されます)

                ★ 画面外を指定すると、関係ないメモリ内容を破壊す
                   ることになるかもしれません。
                ★ val が width  桁に満たないときに左側に空いた桁
                   は、'0'が埋められます。

------------------------------------------------------------------------
□ gaiji_putnia - 外字で数字列を表示(幅指定あり,属性あり)

C:      void gaiji_putnia( unsigned x, unsigned y, unsigned  val,
                          unsigned width, unsigned atrb );

        ------------------------------------------98N 98H AT DOS-
        gaiji_putnia                               ○     ×
        ------------------------------------------<gjputnia.asm>-

                ● テキスト画面に外字で数字を直接書き込みます。

                ← x      左端の桁の画面上の位置(0=画面左端)
                   y      画面上の行位置(0=画面上端)
                   val    表示したい数値(0〜65535)
                   width  表示する桁数 (数値の下から width 桁が表
                          示されます)
                   atrb   表示するテキスト属性

                ★ 画面外を指定すると、関係ないメモリ内容を破壊す
                   ることになるかもしれません。
                ★ val が width  桁に満たないときに左側に空いた桁
                   は、'0'が埋められます。

------------------------------------------------------------------------
□ gaiji_putp - 外字でパスカル文字列を表示(属性なし)

C:      void gaiji_putp( unsigned x, unsigned y, char * pstr );

        ------------------------------------------98N 98H AT DOS-
        gaiji_putp                                 ○     ×
        --------------------------------------------<gjputp.asm>-

                ● テキスト画面の y行目(0 が一番上)の x桁目(0  が
                   一番左)からの領域に外字文字列を直接書き込みま
                   す。
                   　書き込む地点の色、属性は変化しません。

                ★ 画面外を指定すると、関係ないメモリ内容を破壊す
                   ることになるかもしれません。

------------------------------------------------------------------------
□ gaiji_putpa - 外字でパスカル文字列を表示(属性あり)

C:      void gaiji_putpa( unsigned x, unsigned y, char * pstr, unsigned atrb );

        ------------------------------------------98N 98H AT DOS-
        gaiji_putpa                                ○     ×
        -------------------------------------------<gjputpa.asm>-

                ● テキスト画面の y行目(0 が一番上)の x桁目(0  が
                   一番左)からの領域に外字文字列を属性atrbで直接
                   書き込みます。

                ★ 画面外を指定すると、関係ないメモリ内容を破壊す
                   ることになるかもしれません。

------------------------------------------------------------------------
□ gaiji_puts - 外字で文字列を表示(属性なし)

C:      void gaiji_puts( unsigned x, unsigned y, char * str );

        ------------------------------------------98N 98H AT DOS-
        gaiji_puts                                 ○     ×
        --------------------------------------------<gjputs.asm>-

                ● テキスト画面の y行目(0 が一番上)の x桁目(0  が
                   一番左)からの領域に外字文字列を直接書き込みま
                   す。
                   　書き込む地点の色、属性は変化しません。

                ★ 画面外を指定すると、関係ないメモリ内容を破壊す
                   ることになるかもしれません。

------------------------------------------------------------------------
□ gaiji_putsa - 外字で文字列を表示(属性あり)

C:      void gaiji_putsa( unsigned x, unsigned y, char * str, unsigned atrb );

        ------------------------------------------98N 98H AT DOS-
        gaiji_putsa                                ○     ×
        -------------------------------------------<gjputsa.asm>-

                ● テキスト画面の y行目(0 が一番上)の x桁目(0  が
                   一番左)からの領域に外字文字列を属性atrbで直接
                   書き込みます。

                ★ 画面外を指定すると、関係ないメモリ内容を破壊す
                   ることになるかもしれません。

------------------------------------------------------------------------
□ gaiji_read - 外字の読み取り(1文字)

C:      void gaiji_read( int code, void far * pattern );

        ------------------------------------------98N 98H AT DOS-
        gaiji_read                                 ○  × ×
        --------------------------------------------<gjread.asm>-

                ● 外字形状を1文字読み取ります。
                   　パターンは、左8dot,右8dotの順に計2バイト、こ
                   れが上から順に16ライン分並ぶ形になります。

------------------------------------------------------------------------
□ gaiji_read_all - 外字の読み取り(256文字)

C:      void gaiji_read_all( void far * pattern );

        ------------------------------------------98N 98H AT DOS-
        gaiji_read_all                             ○  × ×
        --------------------------------------------<gjread.asm>-

                ● 外字形状をすべて読み込みます。
                   　パターンは、左8dot,右8dotの順に計2バイト、こ
                   れが上から順に16ライン分並ぶ形になります。

------------------------------------------------------------------------
□ gaiji_restore - 外字の復元

C:      int gaiji_restore(void);

        ------------------------------------------98N 98H AT DOS-
        gaiji_restore                              ○  × × ○
        ------------------------------------------<gjbackup.asm>-

                ● gaiji_backup()で待避した外字パターンを復元し、
                   占有していたメモリを開放します。

                → 1 成功
                   0 失敗( 退避していない )

------------------------------------------------------------------------
□ gaiji_write - 外字の登録(1文字)

C:      void gaiji_write( int code, const void far * pattern );

        ------------------------------------------98N 98H AT DOS-
        gaiji_write                                ○  × ×
        -------------------------------------------<gjwrite.asm>-

                ● 外字形状を1文字登録します。
                   codeの値には  0〜255が指定でき、 0〜127は  NEC
                   JISの7600h〜767fhに対応し、 128〜255は 7700h〜
                   777fhに対応します。
                   　外字が  63文字とカタログに表記されている機種
                   の場合、32〜95の 64文字が指定でき、188文字と表
                   記されている機種では  0〜255の全てが指定できま
                   す。
                   　パターンは、左8dot,右8dotの順に計2バイト、こ
                   れが上から順に16ライン分並ぶ形になります。

                ★ EPSONの一部の機種では
                   0,1,16,17,128,129,144,145の  8文字が登録できな
                   いものがあります。

------------------------------------------------------------------------
□ gaiji_write_all - 外字の登録(256文字)

C:      void gaiji_write_all( const void far * pattern );

        ------------------------------------------98N 98H AT DOS-
        gaiji_write_all                            ○  × ×
        -------------------------------------------<gjwrite.asm>-

                ● 外字形状を256文字登録します。
                   　外字が  63文字とカタログに表示されている機種
                   の場合、 このうちの(0番を先頭として)32〜95番の
                   64文字のみが登録されます。
                   　パターンは、左8dot,右8dotの順に計2バイト、こ
                   れが上から順に16ライン分並ぶ形になります。


------------------------------------------------------------------------
■ フォント処理 ■■■■■■■■■■■■■■■■■■■■■■■■■■■■

        　ANKのフォントパターンを、独自に管理します。

------------------------------------------------------------------------
□ 構造体／グローバル変数

const volatile int font_ReadChar;  <98>割り込みによってこれから読
                                   み込む文字コード
const int font_ReadEndChar;        <98>割り込みで読み込む最後の文
                                   字コード
void (far *font_AnkFunc)(void);    <AT>全角フォント読み取りルーチ
                                   ンのアドレス
void (far *font_KanjiFunc)(void);  <AT>半角フォント読み取りルーチ
                                   ンのアドレス

------------------------------------------------------------------------
□ font_at_entry_cgrom - <AT>システム半角fontを内部半角フォントに登録

C:      int font_at_entry_cgrom( unsigned firstchar, unsigned lastchar );

        ------------------------------------------98N 98H AT DOS-
        font_at_entry_cgrom                        ×  × ○
        ------------------------------------------<fontatcg.asm>-

                ● システム半角フォント(8x16dot)をfont_write()で
                   登録します。

                ← firstchar  開始文字コード(0〜255)
                   lastchar   終了文字コード(firstchar〜255)

                → 0   成功(失敗しません)

                ★ firstchar > lastchar である場合、 何もせずに終
                   了します。
                ★ 98版 font_entry_cgromと異なり、 処理は短時間で
                   終わり、戻ってきたときには完了しています。

------------------------------------------------------------------------
□ font_at_init - <AT>フォントの読み取り準備

C:      void font_at_init(void);

        ------------------------------------------98N 98H AT DOS-
        font_at_init                               ×  × ○ Ｖ
        ------------------------------------------<fontatin.asm>-

                ● DOS/Vの文字フォント読み取りルーチンのアドレス
                   を取得し、記憶します。 DOS/Vが認識するビデオモ
                   ード(03h,12hなど)でこの関数を実行すると、 以後
                   SVGAのグラフィックモード(VESA SVGA  800x600dot
                   など)に変更しても日本語のフォントが
                   font_at_read で読み込めるようになります。

                ○ font_AnkFunc, font_KanjiFunc変数を設定します。

                ★ 日本語の画面モードでしか使わないのであれば必要
                   ありません。

------------------------------------------------------------------------
□ font_at_read - <AT>フォントの読み取り

C:      int font_at_read( unsigned ccode, unsigned fontsize, void far * buf);

        ------------------------------------------98N 98H AT DOS-
        font_at_read                               ×  × ○
        ------------------------------------------<fontatre.asm>-

                ● AX=1800h, int 10h を呼び出すことで、フォントデ
                   ータを読み取ります。

                ← ccode        文字コード
                   fontsize     上位8bit: 横ドット数
                                下位8bit: 縦ドット数
                   buf          フォントデータの格納先(ベタ形式)

                → NoError      成功
                   InvalidData  失敗(指定サイズのフォントがないな
                                ど)

                ★ get_machineを事前に実行する必要があります。

------------------------------------------------------------------------
□ font_entry_bfnt - フォントのBFNTファイルからの登録

C:      int font_entry_bfnt(const char *filename);

        ------------------------------------------98N 98H AT DOS-
        font_entry_bfnt                            ○        ○
        ------------------------------------------<fontentb.asm>-

                ● BFNT 形式のファイルを読み込み、ANK  フォントと
                   して登録します。
                   8x16dotフォント以外の場合、graph_bfnt_puts,
                   graph_bfnt_putpのどちらか以外では正しく表示で
                   きません。

                ← BFNTファイル名 (データは必ず 2色)

                → NoError             成功
                   FileNotFound        ファイルが開けない
                   InvalidData         フォントファイルが使えない
                                       規格である
                   InsufficientMemory  フォントを登録する為のメモ
                                       リが足りない

                ★ 文字の大きさは、横は8dot単位で、かつ((横ドット
                   数/8)*縦ドット数)が16の倍数になる大きさでなけ
                   ればなりません。
                ★ graph_bfnt_puts, graph_bfnt_putpのどちらかで表
                   示するのでなければ、文字の大きさは 8x16dotでな
                   ければなりません。

                △MEMORY: 以前に確保されていなければ  font_AnkSeg
                  に  256文字ぶん、たとえば8x16dotなら256パラグラ
                  フのブロックを確保します。

------------------------------------------------------------------------
□ font_entry_cgrom - フォントのCG ROMからの登録

C:      int font_entry_cgrom( unsigned firstchar, unsigned lastchar );

        ------------------------------------------98N 98H AT DOS-
        font_entry_cgrom                           ○  × ＊ ○
        ------------------------------------------<fontentc.asm>-

                ● VSYNC割り込みを使って、98本体のフォントROMの半
                   角ANKデータを読み込み、ANK  フォントとして登録
                   する作業を開始します。
                   　font_ReadChar > font_ReadEndChar  が成立した
                   ときが読み込み完了したときです。

                ← firstchar    読み込み開始文字
                   lastchar     読み込み終了文字

                → NoError             読み込みを開始した
                   InsufficientMemory  フォントを登録する為のメモ
                                       リが足りない
                   InvalidData         フォントの大きさが8x16dot
                                       じゃない

                ★ この関数を呼び出す前に vsync_startを実行する必
                   要があります。
                ★ 内部で vsync_proc_set を実行していますので、以
                   前の設定は失われます。読み込み完了確認後に再設
                   定してください。
                ★ vsync_startを実行したら、プログラム終了前に
                   vsync_endを実行する必要があります。

                ○ <98> VSYNC割り込み一回で 1文字読み込んでいます。
                   このため 256文字指定した場合、25行モードで 5秒
                   弱かかります。
                ○ <AT> ATではすぐに処理が完了します。

                △MEMORY: 確保されていなければ font_AnkSeg に 256
                  パラグラフのブロックを確保します。

------------------------------------------------------------------------
□ font_entry_gaiji - フォントの外字からの登録

C:      void font_entry_gaiji(void);

        ------------------------------------------98N 98H AT DOS-
        font_entry_gaiji                           ○  × × ○
        ------------------------------------------<fontentg.asm>-

                ● 外字を半角として登録してある事を前提に、 ANKフ
                   ォントとして登録します。

                ○ 登録範囲は、NEC JIS外字 7620h〜769fhを ANK 00h
                   〜7fhに割り当てます。

                ★ メモリに確保されたfontの大きさが8x16dot以外な
                   ら(font_AnkSize!=0x0110)、何もしません。

                △MEMORY: 以前に確保されていなければ  font_AnkSeg
                  に 256パラグラフのブロックを確保します。

------------------------------------------------------------------------
□ font_entry_kcg - フォントの2バイト半角からの登録

C:      void font_entry_kcg(void);

        ------------------------------------------98N 98H AT DOS-
        font_entry_kcg                             ○  × ＊ ○
        ------------------------------------------<fontentk.asm>-

                ● 2バイト半角のフォントの内、 英数記号およびカタ
                   カナ部分のみを ANKフォントとして登録します。

                ○ 登録範囲は、20h(空白)〜7eh(~),  a1h(｡)〜dfh(ﾟ)
                   です。

                ★ メモリに確保されたfontの大きさが8x16dot以外な
                   ら(font_AnkSize!=0x0110)、何もしません。

                △MEMORY: 確保されていなければ font_AnkSeg に 256
                  パラグラフのブロックを確保します。

------------------------------------------------------------------------
□ font_read - フォントの読み取り

C:      void font_read( unsigned code, void * pattern );

        ------------------------------------------98N 98H AT DOS-
        font_read                                  ○  × ＊
        ------------------------------------------<fontread.asm>-

                ● JISまたはシフトJISコードで文字を指定すると、そ
                   の文字の形状を pattern に格納します。
                   　格納形式は、左半分(8x16dot)を上から順に、 次
                   に右半分(〃)を格納します。(計32バイト)
                   半角は codeに 0〜255を入れて呼び出すこと
                   で､font_entry_bfnt()でメモリ上に読み込んだパタ
                   ーンを得ることができます。

------------------------------------------------------------------------
□ font_write - フォントの登録

C:      void font_write( unsigned code, const void * pattern );

        ------------------------------------------98N 98H AT DOS-
        font_write                                 ○  × ○
        ------------------------------------------<fontwrit.asm>-

                ● 外字および半角フォントを定義します。

                ← code  0〜255   半角フォントデータ(8x16dot固定)
                                  の書き換え。以前に1文字も登録さ
                                  れていなければ、 新たにメモリが
                                  確保されます。
                         256以上  <98>JISコードや、 シフトJISコー
                                  ドを指定することで、 漢字フォン
                                  トROMを書き換えます。ただし実際
                                  に書き換えられるのは、 外字領域
                                  だけです。
                                  <AT>絶対に指定してはいけません。

                ○ パターンは、左半分(8x16dot)を上から順に、 次に
                   右半分(〃)を格納します。(計32バイト)
                ○ <98>gaiji_writeと似ていますが、 文字コードと、
                   パターンの並びが違います。

                ★ メモリに確保されたfontの大きさが8x16dot以外な
                   ら(font_AnkSize!=0x0110)、何もしません。

                △MEMORY: 以前に確保されていなければ  font_AnkSeg
                  に 256パラグラフのブロックを確保します。

------------------------------------------------------------------------
□ wfont_entry_bfnt - 圧縮フォントのBFNTファイルからの登録

C:      int wfont_entry_bfnt(const char *);

        ------------------------------------------98N 98H AT DOS-
        wfont_entry_bfnt                           ○        ○
        ------------------------------------------<wfntentb.asm>-

                ● BFNT 形式のファイルを読み込み、 圧縮フォントの
                   ANK 部分として登録します。
                   圧縮フォントの ANK 部分は、単に 8x8dot  のフォ
                   ントになります。
                   (全角部分は、縦に半分に圧縮して  2プレーンを使
                   用して表示されます)

                ← BFNTファイル名 (データは必ず 2色,8x8dot)

                → NoError             成功
                   FileNotFound        ファイルが開けない
                   InvalidData         フォントファイルが使えない
                                       規格である
                   InsufficientMemory  フォントを登録する為のメモ
                                       リが足りない

                △MEMORY: 128パラグラフのブロックを確保します。


------------------------------------------------------------------------
■ グラフィックカーソル ■■■■■■■■■■■■■■■■■■■■■■■■

        ★PC-9801 16色, PC/AT VGA 16色モードにのみ対応します。
        　グラフィック画面用カーソルを管理します。
        　グラフィックカーソルは、16x16dotで任意の2色を使うことが
        できます。
        　表示状態は、16ビット符号付き整数で管理し、0を表示、負数
        を非表示とします。(マイクロソフトマウスドライバと同じ)
        　移動範囲は、安全のため、画面全体でのみ制限します。 が、
        カーソル位置を取得する方法を用意していません。 カーソル範
        囲や位置は、呼び出し側で管理してください。
        使い方の骨格:
        　準備:
                cursor_init();                          /*   必要
                                                        */
                cursor_pattern(cx,cy,bc,wc,pattern);    /*   必要
                                                        */
                cursor_moveto( x,y );   /* 初期位置 */  /* 必要に
                                                        応じて */
                cursor_show();          /* カーソル表示 */
        　表示:
                cursor_moveto( x,y );   /* カーソル移動 */
                cursor_hide();          /* カーソル除去 */
                cursor_moveto( x,y );   /* カーソル移動 */
                cursor_show();          /* カーソル表示 */
        　終り:
                cursor_hide();          /* カーソル除去 */

------------------------------------------------------------------------
□ 構造体／グローバル変数

        ● カーソル形状構造体(cursor_setpattern()で利用してくださ
           い)
struct CursorData {
    unsigned char px, py;
    unsigned pattern[32];
};
struct CursorData cursor_Arrow; 左上向きの矢印
struct CursorData cursor_Cross; 十字
struct CursorData cursor_Hand;  手(人差し指を立てている)
struct CursorData cursor_Ok;    (Ok?)

------------------------------------------------------------------------
□ cursor_hide - カーソルの表示カウンタ減少

C:      int cursor_hide(void);

        ------------------------------------------98N 98H AT DOS-
        cursor_hide                                Ｖ  × ○
        --------------------------------------------<cursor.asm>-

                ● 現在の表示カウンタを減少し、 -1になったなら(今
                   まで0だったなら)画面上のカーソルを除去します。

                → 実行後の表示カウンタ(-1なら除去した)

------------------------------------------------------------------------
□ cursor_init - カーソル表示状態の初期化

C:      void cursor_init(void);

        ------------------------------------------98N 98H AT DOS-
        cursor_init                                Ｖ  × ○
        --------------------------------------------<cursor.asm>-

                ● 現在のカーソル表示状態にかかわらず、表示カウン
                   タを -1 に初期化します。

                ★ PC/ATで実行する場合は、かならず事前に
                   get_machine()を実行し、 かつ16色グラフィックモ
                   ードにしてください。

------------------------------------------------------------------------
□ cursor_moveto - カーソルの移動

C:      void cursor_moveto( int x, int y );

        ------------------------------------------98N 98H AT DOS-
        cursor_moveto                              Ｖ  × ○
        --------------------------------------------<cursor.asm>-

                ● 現在の表示カウンタが 0 ならばカーソルを移動し、
                   そうでないならば無視します。

                ○ 画面外を指定しても、最も近い端に丸められます。

------------------------------------------------------------------------
□ cursor_pattern - カーソルパターンの定義1

C:      void cursor_pattern( int px, int py, int  blc,  int  whc,
                            void far * pattern );

        ------------------------------------------98N 98H AT DOS-
        cursor_pattern                             Ｖ  × ○
        --------------------------------------------<cursor.asm>-

                ● カーソル中のセンターポイントの位置、カーソル描
                   画に使う２色、およびカーソル形状を設定します。
                ← px,py     センターポイント。カーソルパターンの
                             中のどの地点をカーソル座標とするかを
                             表します。0,0が左上、15,15が右下です。
                   blc,whc   0〜15 カーソルパターンに使う２色のパ
                             レットコード
                   pattern   カーソルパターン。 blc用が16ワード、
                             続けてwhc用が16ワードです。
                             描画はblc,whcの順に行うので、 両方の
                             ビットが立っている所はwhc側が優先で
                             す。

------------------------------------------------------------------------
□ cursor_pattern2 - カーソルパターンのMOUSE.COM風定義

C:      void cursor_pattern2( int px, int py, int whc, void far * pattern );

        ------------------------------------------98N 98H AT DOS-
        cursor_pattern2                            Ｖ  × ○
        -------------------------------------------<curpat2.asm>-

                ● MS MOUSE.COMや  gr.libで指定する形式のカーソル
                   データを、 master.lib cursor_*形式に変換して登
                   録します。

                ← px,py     センターポイント。カーソルパターンの
                             中のどの地点をカーソル座標とするかを
                             表します。0,0が左上、15,15が右下です。
                   whc       0〜15  "XORマスク"の描画に使うパレッ
                             トコード
                   pattern   カーソルパターン。 ANDマスクが16ワー
                             ド、続けてXORマスクが16ワードです。
                             ただし、XORマスクは実際にはXORせず、
                             whcの色で描画する点が異なります。AND
                             マスクは反転を黒で描画することにより、
                             同一結果になるよう変換しています。

------------------------------------------------------------------------
□ cursor_setpattern - カーソルパターンの定義2

C:      void cursor_setpattern(  struct CursorData cdat, int blc,
                               int whc )                   マクロ

        ------------------------------------------98N 98H AT DOS-
        cursor_setpattern                          Ｖ  × ○
        -----------------------------------------------------<->-

                ● CursorData構造体によってカーソルパターンを定義
                   します。

------------------------------------------------------------------------
□ cursor_show - カーソルの表示カウンタ増加

C:      int cursor_show(void);

        ------------------------------------------98N 98H AT DOS-
        cursor_show                                Ｖ  × ○
        --------------------------------------------<cursor.asm>-

                ● 現在の表示カウンタが 0 でなければ増加し、0にな
                   ったならばカーソルを描画します。

                → 実行後の表示カウンタ(0なら描画した)

                ★ カーソルが描画された状態で、ほかの手段でグラフ
                   ィック画面をアクセスするとカーソルが移動したと
                   きにその付近がおかしくなります。


------------------------------------------------------------------------
■ パターン/キャラクタの登録/削除 ■■■■■■■■■■■■■■■■■■■

        　パターンは、 16色(透明色を含む)の小さなグラフィックデー
        タを登録し、管理番号を振ったものです。

        　キャラクタは、パターン番号と、 パターンを表示するときに
        待避する領域を持った構造体を登録し、 管理番号を振ったもの
        です。

        　表示するパターン/キャラクタは、あらかじめ登録しておく必
        要があります。super_put() 系、 仮想VRAM系の関数を利用する
        場合にはパターンとして、super_in() 系の関数を利用する場合
        にはキャラクタとして登録する必要があります。

        　super_entry_pat()では、  透明色が指定できます。  通常は
        color  0 を指定するが、別の色に変更することもできます。透
        明色として指定した色の部分は背景が透けて残ることになりま
        す。

        　登録していない番号や、削除した番号のパターン/キャラクタ
        を表示した場合の動作は予想できません。

------------------------------------------------------------------------
□ 構造体／グローバル変数

unsigned super_patdata[];       パターンごとのパターンデータのセ
                                グメントアドレス
unsigned super_patsize[];       パターンごとのパターンデータの大
                                きさ
                                (上位8bit=横ドット数  /  8,  下位
                                8bit=縦ドット数)
unsigned super_buffer;          パターン処理のための一時作業領域
                                のセグメントアドレス。
unsigned super_patnum;          次に登録されるパターン番号。 常に
                                末尾の番号+1です。

const char BFNT_ID[5];          "BFNT\x1a"(BFNTファイルのID文字列)


------------------------------------------------------------------------
□ super_backup_ems - 登録されたパターンをEMSに待避

C:      int super_backup_ems( unsigned * handle,  int  first_pat,
                             int last_pat );

        ------------------------------------------98N 98H AT DOS-
        super_backup_ems
        ------------------------------------------<superbak.asm>-

                ● 指定範囲の登録済みパターンを、一括して EMSにコ
                   ピーします。

                ← handle     待避管理ブロックのセグメントアドレ
                              スの格納先
                   first_pat  最小番号
                   last_apt   最大番号

                → NoError              保存成功(作業完了)
                   InsufficientMemory   EMSが足りない(作業前)
                   GeneralFailure       その範囲にデータは全く登
                                        録されていない(作業前)
                   InvalidData          first_pat,last_patの値が
                                        無効(作業前)
                                        (first_pat > last_patのと
                                        き、 どちらかが最終登録番
                                        号より大きかったとき)

------------------------------------------------------------------------
□ super_cancel_pat - パターンの削除

C:      int super_cancel_pat( int num );

        ------------------------------------------98N 98H AT DOS-
        super_cancel_pat
        ------------------------------------------<supercan.asm>-

                ● 登録されているパターンを削除、占有していたメモ
                   リを開放します。

                ← num パターン番号

                → NoError        成功
                   GeneralFailure 登録されていない番号を指定した

                ★ 最後のパターン (最大の番号のパターン) を削除し
                   た場合には、次に登録されるパターンの番号は、残
                   っている最大の番号の次の番号に変更されます。

                △MEMORY:  パターンに使用されていたメモリを開放し
                  ます。

------------------------------------------------------------------------
□ super_change_erase_pat - 消去パターンの変更

C:      void super_change_erase_pat( int num, void far *image);

        ------------------------------------------98N 98H AT DOS-
        super_change_erase_pat
        ------------------------------------------<superchg.asm>-

                ● 指定パターンの消去パターンを再設定します。

                ← num    変更対象のパターン番号
                   image  新しい消去パターン(ベタ形式)

                ★ image の size は、登録したパターンと同じ  size
                   でなければなりません。
                ★ image はコピーして登録されます。
                ★ 登録済みのキャラクタにも変更が反映されます。

------------------------------------------------------------------------
□ super_clean - 複数パターンの削除

C:      void super_clean( int min_pat, int max_pat );

        ------------------------------------------98N 98H AT DOS-
        super_clean
        ------------------------------------------<supercln.asm>-

                ● パターン番号 min_patからmax_patまでを、 すべて
                   登録されていない状態にします。

                ← min_pat 最小番号
                   max_pat 最大番号

                ○ もともと何も登録されていない領域の場合、または
                   max_pat < min_pat の場合は何もしません。

------------------------------------------------------------------------
□ super_convert_tiny - パターンデータ形式を高速表示用に変換

C:      int super_convert_tiny( int num );

        ------------------------------------------98N 98H AT DOS-
        super_convert_tiny                                ＊
        ------------------------------------------<supertin.asm>-

                ● すでに登録されたパターン num のデータを、 高速
                   表示用形式に変換します。

                → InvalidData  パターン番号が異常、 またはパター
                                ンデータに  5色以上使われている。
                                このときはパターンデータは破壊さ
                                れない。
                   NoError      変換成功

                ★ この形式に変換したら、表示は super_put_tiny ま
                   たは  super_put_tiny_small  でしか行えません。
                   (異常なパターンになります)

                ★ この高速形式は、使われている色が  透明+4色以内
                   のデータに対してしか行えません。 なぜなら、5色
                   以上ならばこの形式を使った場合に却って遅くなる
                   からです(^^;

                ★ <AT>VGAでは、 tiny形式にしてもそれほど高速化が
                   見込まれないので、この関数はATでは無視します。
                   また、tiny描画関数もすべて通常の描画関数で置き
                   変わります。

                ○ 高速形式とは、通常 4プレーン全てに順番にアクセ
                   スして描画するのに対し、GRCGの色指定を利用して
                   色ごとの描画をするようにしたものです。この関係
                   で、色数が少なければそれだけ高速になります。
                ○ シューティングゲームの弾など、2〜3色程度しか使
                   わずパターンも小さいが大量に表示されるものは、
                   高速形式を使う事をお奨めします。

------------------------------------------------------------------------
□ super_dup - パターンの複製を登録

C:      int super_dup(int pat);                            マクロ

        ------------------------------------------98N 98H AT DOS-
        super_dup
        -----------------------------------------------------<->-

                ● すでに登録されたパターン pat  と全く同一内容の
                   データを、新たに登録します。

                ← pat     複写元パターン番号

                → 0〜511               登録したパターン番号
                   InsufficientMemory   メモリが足りない
                   GeneralFailure       patが登録されていない、登
                                        録パターンが512に達した

                △MEMORY: patに使用していたメモリと同じだけ確保し
                  ます。

------------------------------------------------------------------------
□ super_duplicate - パターンの複製を指定番号に登録

C:      int super_duplicate(int topat, int frompat);

        ------------------------------------------98N 98H AT DOS-
        super_duplicate
        ------------------------------------------<superdup.asm>-

                ● すでに登録されたパターン frompat  と全く同一内
                   容のデータを、パターン番号topatに作成します。

                ← topat     登録先番号
                   frompat   複写元パターン番号

                → 0〜511               登録したパターン番号
                   InsufficientMemory   メモリが足りない
                   GeneralFailure       frompatが登録されていない、
                                        または topat が512以上

                ○ すでにtopatにデータが存在する場合は、 自動的に
                   開放してくれます。

                △MEMORY: frompatに使用していたメモリと同じだけ確
                  保します。

------------------------------------------------------------------------
□ super_entry_at - パターンを直接登録

C:      int super_entry_at( int num, int patsize, unsigned pat_seg );

        ------------------------------------------98N 98H AT DOS-
        super_entry_at
        -------------------------------------------<superat.asm>-

                ● すでに使用する形式でhmemブロックに書き込まれた
                   パターンを登録します。

                ← num      登録先のパターン番号。 すでに存在した
                            ら古い物は開放されてから登録される。
                   patsize  パターンサイズ。super_entry_pat参照
                   pat_seg  パターンデータを使用する形式で格納し
                            た、 hmemメモリブロックの先頭セグメン
                            トアドレス。

                ★ この関数は、他の関数から内部的に呼び出されてい
                   る下位関数です。

                ○ パターンデータは、メモリブロックのoffset 0番地
                   からマスク、青、赤、緑、 輝度プレーン(それぞれ
                   パターン全体分)の順にならべた形式です。 マスク
                   データはbitが0のところが透明を表します。実際の
                   描画は、マスクを黒で塗ってから各プレーンにORし
                   てゆくので、実際に透明にするにはすべてのプレー
                   ンはマスクデータでANDしなければ正しく処理でき
                   ません。

------------------------------------------------------------------------
□ super_entry_char - パターンをキャラクタに登録

C:      int super_entry_char( int num );

        ------------------------------------------98N 98H AT DOS-
        super_entry_char
        ------------------------------------------<superchr.asm>-

                ● パターンをキャラクタに登録します。

                ← パターン番号

                → 0〜511             登録されたキャラクタ番号
                   GeneralFailure     登録できるキャラクタ数を越
                                      えている
                   InsufficientMemory  キャラクタを登録するための
                   メモリが足りない

                ★ キャラクタ番号は 0  から順番に割り当てられてい
                   きます。

                △MEMORY:  キャラクタを表示するときの待避領域を確
                  保します。実際の大きさは、super_entry_pat()で登
                  録するのに要した大きさの4/5です。

------------------------------------------------------------------------
□ super_entry_pack - パック16色データからパターンを登録

C:      int super_entry_pack( const void far  *  image,  unsigned
                             image_width, int patsize, int clear_color );

        ------------------------------------------98N 98H AT DOS-
        super_entry_pack
        ------------------------------------------<superpak.asm>-

                ● パック16色形式のデータの一部分をパターンに登録
                   します。

                ← patsize      パターンの大きさ(super_entry_pat
                                参照)
                   image        パックデータのパターンに登録する
                                部分の先頭アドレス
                   image_width  パックデータの横ドット数
                   patsize      パターンの大きさ(super_entry_pat
                                参照)
                   clear_color  透明色(通常は 0)

                → 0〜511              パターン番号
                   GeneralFailure      登録できるパターン数を越え
                                       ている
                   InsufficientMemory  パターンを登録する為のメモ
                                       リが足りない

                △MEMORY: super_entry_pat 参照

------------------------------------------------------------------------
□ super_entry_pat - パターンのアドレスを指定して登録

C:      int super_entry_pat( int patsize, void far *image,  int color );

        ------------------------------------------98N 98H AT DOS-
        super_entry_pat
        ------------------------------------------<superpat.asm>-

                ● パターンを登録します。

                ← patsize   パターンの大きさ(下記参照)
                   image     パターンの先頭アドレス
                             (ベタ形式で BRGI プレーンの順)
                   color     透明色(通常は 0)

                → 0〜511              パターン番号
                   GeneralFailure      登録できるパターン数を越え
                                       ている
                   InsufficientMemory  パターンを登録する為のメモ
                                       リが足りない

                ★ 登録が成功した場合には imageは far領域にコピー
                   されて保存されるので image(データ本体も含む)は
                   不要となります。
                ★ パターン番号は 0から順番に割り当てられていきま
                   す。
                ★ 登録できるパターンは 512 個までです。

                ★ size の指定は、((xdot/8) * 256 + ydot)で行いま
                   すが、以下のように定数も定義してあるので、ご利
                   用下さい。
                ★ 「パターンに必要なメモリ」が64KBを越えるデータ
                   は正しく処理できません。
                   　具体的には、縦を255dotにした場合、横は
                   51*8=408dotまでになります。

                     8 ドット ×  8 ドット  SIZE8x8   0x0108
                    16 ドット × 16 ドット  SIZE16x16 0x0210
                    24 ドット × 24 ドット  SIZE24x24 0x0318
                    32 ドット × 32 ドット  SIZE32x32 0x0420
                    40 ドット × 40 ドット  SIZE40x40 0x0528
                    48 ドット × 48 ドット  SIZE48x48 0x0630
                    56 ドット × 56 ドット  SIZE56x56 0x0738
                    64 ドット × 64 ドット  SIZE64x64 0x0840
                  の中から選択します。 xdots と ydots  が異なる場
                  合 (ex. 32x16)には、
                      xdots
                     8 ドット  xSIZE8  0x0100
                    16 ドット  xSIZE16 0x0200
                    24 ドット  xSIZE24 0x0300
                    32 ドット  xSIZE32 0x0400
                    40 ドット  xSIZE40 0x0500
                    48 ドット  xSIZE48 0x0600
                    56 ドット  xSIZE56 0x0700
                    64 ドット  xSIZE64 0x0800
                  と、
                      ydots
                     8 ドット  ySIZE8  0x0008
                    16 ドット  ySIZE16 0x0010
                    24 ドット  ySIZE24 0x0018
                    32 ドット  ySIZE32 0x0020
                    40 ドット  ySIZE40 0x0028
                    48 ドット  ySIZE48 0x0030
                    56 ドット  ySIZE56 0x0038
                    64 ドット  ySIZE64 0x0040
                  の論理和を指定する (ex. xSIZE32 | ySIZE16)。

                △MEMORY: パターンに必要なメモリを確保します。 そ
                  の実際の大きさは、「横ドット数 / 8 * 縦ドット数
                  *  5バイト」、ただし 16で割った余りがある場合は
                  割り切れるように切り上げた量になります。
                　また、それとは別に、 最初の一つを登録するときに
                管理領域の確保のため、 super_buffer に 9216バイト
                のブロックを確保します。

------------------------------------------------------------------------
□ super_free - すべてのパターンとキャラクタの削除

C:      void super_free(void);

        ------------------------------------------98N 98H AT DOS-
        super_free                                           ○
        ------------------------------------------<superfre.asm>-

                ● すべてのパターンとキャラクタに使用していたメモ
                   リを開放します。これを実行すると、起動してから
                   まだ一度もパターンを登録していなかったのと同じ
                   状態になります。

                △MEMORY:  パターンなどに使用していたメモリを開放
                  します。

------------------------------------------------------------------------
□ super_free_ems - EMSに待避されたパターンを開放

C:      void super_free_ems(void);

        ------------------------------------------98N 98H AT DOS-
        super_free_ems
        ------------------------------------------<superbak.asm>-

                ● super_backup_emsで待避されたすべてのパターンデ
                   ータをEMSから開放します。

                ★ 確保されたhandleは開放されません。すべての
                   handleを、必ず hmem_free()で開放してください。

                ○ handleの開放と  super_free_ems()の実行順序は自
                   由ですが、片方だけ実行することは避けてください。

------------------------------------------------------------------------
□ super_hrev - パターンを左右反転

C:      void super_hrev(int patnum);

        ------------------------------------------98N 98H AT DOS-
        super_hrev
        ------------------------------------------<superhrv.asm>-

                ● すでに登録されたパターンを左右反転します。

                ← patnum   左右反転したいパターン番号

                ○ 2度実行すると元にもどります。
                ○ 登録されていない番号を指定した場合、何もせずに
                   帰ってきます。

                ★ 同じパターンを毎回複数個表示している場合、全部
                   一斉に反転してしまいます。これを避けたい場合は、
                   一つ一つ表示の度に必要に応じて反転させるか、
                   super_dupなどで別のパターンにしてしまう方法が
                   あります。

------------------------------------------------------------------------
□ super_restore_ems - EMSに待避されたパターンを再登録

C:      int super_restore_ems( unsigned handle, int load_to );

        ------------------------------------------98N 98H AT DOS-
        super_restore_ems
        ------------------------------------------<superbak.asm>-

                ● super_backup_emsで待避された複数のパターンを一
                   括して再登録します。

                ← handle   super_backup_emsで得た管理セグメント
                            アドレス
                   load_to  先頭の登録番号。 -1なら待避した時点と
                            同じ値

                → NoError              格納成功。(作業完了)
                   InsufficientMemory   復元結果を格納するメモリ
                                        が足りない。(作業途中)
                   InvalidData          load_toが無効(作業前)

                ○ load_to+待避パターン数が512を越える場合にも、
                   何もせずにInvalidDataを返します。
                ○ 再登録先の番号のパターンがすでに存在する場合は、
                   削除しながら更新します。
                ○ 現在登録されている末尾に追加する形で読み込みた
                   い場合は、
                   super_restore_ems( handle, super_patnum );  で
                   行ってください。


------------------------------------------------------------------------
■ BFNT/BFNT+ ■■■■■■■■■■■■■■■■■■■■■■■■■■■■■

        　noenoe   氏提唱の   BFNT/BFNT+   フォーマットは、  free
        software 用の共通フォントファイル形式として普及が進んでい
        ます (gr.manより引用)。
        　master.lib   では、  カラーフォントのフォーマットである
        BFNT+  形式のファイルを読み込んでパターンとして登録できま
        す。

        　上位関数の super_entry_bfnt()、super_change_erase_bfnt()
        とそれを実現している下位関数に分けられます。
        　下位関数を利用するとヘッダや拡張ヘッダにアクセスするこ
        とができます。

        　super_entry_bfnt()は、BFNT+ Rev.1.6  で採用された透明色
        の拡張ヘッダに対応しています。
        　BFNT+  ファイルに透明色の拡張ヘッダが含まれていない場合
        には、デフォルトで color 0 が透明色となりますが、拡張ヘッ
        ダで指定するとこれを異なる色に変更することができます。
        　また、BFNT+ Rev.1.6 では、 複数の透明色が認められていま
        すが、 master.libでは最初に出てくる透明色の拡張ヘッダにし
        か対応していません。

        　下位関数の実行は、必ず以下の順序を守ってください。

        ・BFNT+(16色)パターンを読み込む場合
        1.  fontfile_open() (または dos_ropen())
        2.  bfnt_header_read()
        3.  bfnt_extend_header_analysis()  または
bfnt_extend_header_skip()
        4.  bfnt_palette_set() または bfnt_palette_skip()
        5.  bfnt_entry_pat()
        6.  fontfile_close() (または dos_close())

        ・BFNT(2色)ファイルから消去パターンを読み込む場合
        1.  fontfile_open() (または dos_ropen())
        2.  bfnt_header_read()
        3.  bfnt_change_erase_pat()
        4.  fontfile_close() (または dos_close())

------------------------------------------------------------------------
□ 構造体／グローバル変数

        　下位関数で用いる BfntHeader 構造体は、 以下のようになっ
        ています。

typedef struct BfntHeader BfntHeader;
struct BfntHeader {
   unsigned char id[5], col;   "BFNT\x1a", 色数
   unsigned char ver, x00;     バージョン,0
   unsigned int Xdots;         横ドット数
   unsigned int Ydots;         縦ドット数
   unsigned int START;         開始キャラクタ番号
   unsigned int END;            終了キャラクタ番号
   unsigned char font_name[8];  フォント名
   unsigned long time;          作成時刻
   unsigned int extSize;        拡張ヘッダサイズ
   unsigned int hdrSize;        ヘッダサイズ
};

------------------------------------------------------------------------
□ bfnt_change_erase_pat - (低)BFNTファイルから消去パターンを設定

C:      int bfnt_change_erase_pat(int patnum, int handle, BfntHeader *header);

        ------------------------------------------98N 98H AT DOS-
        bfnt_change_erase_pat                                ○
        ------------------------------------------<bftchnge.asm>-

                ● BFNT(2色)ファイルから、 patnum以降の登録済みパ
                   ターンの消去パターンを一括再設定します。

                ← patnum  消去パターンを再設定する最初の登録済み
                           パターン番号
                   handle  読み込みオープンされたファイルハンドル
                   header  すでに読み込まれた BFNT+ヘッダ

                → NoError             成功
                   InvalidData         フォントファイルが使えない
                                       規格である
                   InsufficientMemory  パターンを一時的に読み込む
                                       メモリが足りない

                ★ BFNT ファイルは 2色で、 登録済みパターンと全く
                   同じ大きさでなければなりません。

------------------------------------------------------------------------
□ bfnt_entry_pat - (低)BFNT+ファイルからパターンを登録

C:      int bfnt_entry_pat( int handle, BfntHeader *header, int color );

        ------------------------------------------98N 98H AT DOS-
        bfnt_entry_pat                                       ○
        ------------------------------------------<bftentry.asm>-

                ● BFNT+ファイルにかかれた全てのデータをパターン
                   として一括登録します。

                ← color  透明色(通常は 0)

                → NoError             成功
                   GeneralFailure      登録できるキャラクタ数を越
                                       えている
                   InvalidData         フォントファイルが使えない
                                       規格である
                   InsufficientMemory  パターンを登録する為のメモ
                                       リが足りない

                ★ BFNT+ ファイルは 16 色で、xdots が 8  の倍数か
                   つ 64 以下でなければなりません。
                ★ パターンの大きさと数は、headerをもとに自動設定
                   します。
                ★ InsufficientMemory が返ったら、 登録途中のまま
                   のメモリを開放しません。
                ★ ファイルポインタは、データの先頭でなければなり
                   ません。(bfnt_header_read でヘッダを読み込み、
                   拡張ヘッダ、パレットデータがあればそれぞれの大
                   きさだけ進んだ位置)

------------------------------------------------------------------------
□ bfnt_extend_header_analysis - (低)BFNT+ファイルから透明色を得る

C:      int bfnt_extend_header_analysis( int handle, BfntHeader *header );

        ------------------------------------------98N 98H AT DOS-
        bfnt_extend_header_analysis                          ○
        ------------------------------------------<bfthdran.asm>-

                ● ファイルの拡張ヘッダを読み込み、最初に見つかっ
                   た透明色を返します。

                → 0-15                透明色(透明色の拡張ヘッダ
                                       がないときも 0 を返す)
                   InsufficientMemory  拡張ヘッダを読込む為のメモ
                                       リが足りない
                   InvalidData         拡張ヘッダが読み込めない

                ★ ファイルポインタは、bfnt_header_read()の直後の
                   状態(先頭から32バイトの位置)でなければなりませ
                   ん。
                ★ 実行後、ファイルポインタは拡張ヘッダの末尾の次
                   の位置に移動します。

------------------------------------------------------------------------
□ bfnt_extend_header_skip - (低)BFNT+ファイルの拡張ヘッダを飛ばす

C:      int bfnt_extend_header_skip( int handle, BfntHeader *header );

        ------------------------------------------98N 98H AT DOS-
        bfnt_extend_header_skip                              ○
        ------------------------------------------<bfntexts.asm>-

                ● ファイルポインタを、 BFNT+の(拡張)ヘッダ末尾の
                   次の位置に移動します。

                → NoError      成功
                   InvalidData  seek失敗

                ★ ファイルポインタは、bfnt_header_read()の直後の
                   状態(先頭から32バイトの位置)でなければなりませ
                   ん。

------------------------------------------------------------------------
□ bfnt_header_load - BFNT/BFNT+ファイルのヘッダを読む

C:      int bfnt_header_load( const char *filename, BfntHeader *header );

        ------------------------------------------98N 98H AT DOS-
        bfnt_header_load                                     ○
        ------------------------------------------<bfnthead.asm>-

                ● BFNT/BFNT+ファイルのヘッダ部分だけを読み込みま
                   す。ただし、そのバイト数を構造体に入れるだけで、
                   何の検査もしていません。

                ← filename  ファイル名
                   header    読み込み先の構造体のアドレス

                → NoError       成功
                   FileNotFound  指定された BFNT ファイルがオープ
                                 ンできない

------------------------------------------------------------------------
□ bfnt_header_read - (低)BFNT+ファイルのヘッダを読む

C:      int bfnt_header_read( int handle, BfntHeader *header );

        ------------------------------------------98N 98H AT DOS-
        bfnt_header_read                                     ○
        ------------------------------------------<bfnthdrr.asm>-

                ● BFNT/BFNT+ファイルであることを検査したあと、フ
                   ァイルからヘッダを読み込みます。

                → NoError      成功
                   InvalidData  指定されたファイルは   BFNT/BFNT+
                                形式でない

                ★ ファイルポインタは、BFNT/BFNT+  ファイルの先頭
                   を示している必要があります。通常、
                   fontfile_open()の実行直後の状態で呼び出して下
                   さい。

------------------------------------------------------------------------
□ bfnt_palette_set - (低)BFNT+ファイルからパレット情報を読む

C:      int bfnt_palette_set( int handle, BfntHeader *header );

        ------------------------------------------98N 98H AT DOS-
        bfnt_palette_set                                     ○
        ------------------------------------------<bftpalst.asm>-

                ● BFNT+ファイルからパレット情報を読み出してグロ
                   ーバル変数 Palettes に設定します。

                → NoError             成功
                   InvalidData         パレット情報が存在しないか、
                                       読み込めない

                ★ パレット情報は 16 色でなければなりません。
                ★ ファイルポインタは、BFNT/BFNT+  ファイルのパレ
                   ット情報の先頭を示している必要がります。 (拡張
                   ヘッダのない場合には、bfnt_header_read()の実行
                   直後、拡張ヘッダのある場合には、
                   bfnt_extend_header_skip()、
                   bfnt_extend_header_analysis()の実行直後の状態)。

------------------------------------------------------------------------
□ bfnt_palette_skip - (低)BFNT+ファイルのパレット情報を無視する

C:      int bfnt_palette_skip( int handle, BfntHeader *header );

        ------------------------------------------98N 98H AT DOS-
        bfnt_palette_skip                                    ○
        ------------------------------------------<bftpalsk.asm>-

                ● ファイルポインタを、パレット情報を読み飛ばした
                   位置まで進めます。

                → NoError             成功
                   InvalidData         パレット情報が存在しないか、
                                       読み込めない

                ★ ファイルポインタは、BFNT/BFNT+  ファイルのパレ
                   ット情報の先頭を示している必要がります。
                   (拡張ヘッダのない場合には bfnt_header_read()の
                   実行直後の状態、
                   ある場合には bfnt_extend_header_skip()、
                   bfnt_extend_header_analysis()実行直後の状態)

------------------------------------------------------------------------
□ fontfile_close - (低)BFNT+ファイルを閉じる

C:      int fontfile_close( int handle );

        ------------------------------------------98N 98H AT DOS-
        fontfile_close                                       ○
        ------------------------------------------<fntclose.asm>-

                ● ファイルを閉じます。

                ← handle ファイルハンドル

                → NoError     成功
                   InvalidData 指定されたファイルがクローズできな
                   い

                ★ dos_closeの別名です。

------------------------------------------------------------------------
□ fontfile_open - (低)BFNT+ファイルを開く

C:      int fontfile_open( const char *filename );

        ------------------------------------------98N 98H AT DOS-
        fontfile_open                                        ○
        ------------------------------------------<fontopen.asm>-

                ● ファイルを読み込みオープンします。

                → FileNotFound  オープン失敗
                   それ以外      ファイルハンドル

                ★ dos_ropenの別名です。

------------------------------------------------------------------------
□ super_change_erase_bfnt - (高)BFNTファイルから消去パターンを一括設定

C:      int super_change_erase_bfnt( int patnum, const char *filename );

        ------------------------------------------98N 98H AT DOS-
        super_change_erase_bfnt                              ○
        ------------------------------------------<supercgb.asm>-

                ● BFNTファイルを読み込み、指定番号のパターンから
                   ファイルに格納されているすべてのデータで消去パ
                   ターンを再設定します。

                ← patnum    変更される最初の登録されているパター
                             ン番号
                   filename  BFNTファイル名

                → NoError       成功
                   FileNotFound  指定された BFNT ファイルがオープ
                                 ンできない
                   InvalidData   フォントファイルが使えない規格で
                                 ある

                ★ BFNTファイルは 2色で、登録済みパターンと全く同
                   じ大きさある必要があります。

------------------------------------------------------------------------
□ super_entry_bfnt - (高)BFNT+ファイルからパターンに一括登録

C:      int super_entry_bfnt( const char *filename );

        ------------------------------------------98N 98H AT DOS-
        super_entry_bfnt                                     ○
        ------------------------------------------<superbft.asm>-

                ● BFNT+ファイルを読み込み、 すべてのデータをパタ
                   ーンとして一括登録し、パレット情報があれば
                   Palettes に読み込みます。

                ← BFNT+ファイル名 (16色で xdotsが8の倍数で64以下
                   でなければなりません)

                → 1〜511              登録したパターン数
                   GeneralFailure      登録できるキャラクタ数を越
                                       えている
                   FileNotFound        指定された BFNT ファイルが
                                       オープンできない
                   InvalidData         フォントファイルが使えない
                                       規格である(16色でない場合
                                       も含む)
                   InsufficientMemory  パターンを登録する為のメモ
                                       リが足りない

                ★ パターンの大きさおよび数は、 BFNT+ファイルから
                   自動的に設定します。
                ★ 戻り値は登録したパターン数であり、パターン番号
                   ではありません。
                ★ 登録の途中でメモリが足りなくなった場合には、登
                   録を中断してInsufficientMemory  を返しますが、
                   パターンは途中まで登録されたままです(メモリを
                   解放しない)。

                △MEMORY:  パターンを格納するためにメモリを確保し
                  ます。実際の大きさは、パターンの数だけ
                  super_entry_pat()で確保するので、そちらを参照し
                  てください。


------------------------------------------------------------------------
■ パターンの調査 ■■■■■■■■■■■■■■■■■■■■■■■■■■■

        登録済みのパターンを調べるためのマクロ群です。

------------------------------------------------------------------------
□ super_check_entry - パターンの存在検査

C:      int super_check_entry( int num );                  マクロ

        ------------------------------------------98N 98H AT DOS-
        super_check_entry
        -----------------------------------------------------<->-

                ● 番号 num  のパターンが登録されているかどうかを
                   判定します。

                → 0      登録されていない
                   0以外  登録されている

------------------------------------------------------------------------
□ super_getsize_pat - パターンの大きさを得る

C:      int super_getsize_pat( int num );                  マクロ

        ------------------------------------------98N 98H AT DOS-
        super_getsize_pat
        -----------------------------------------------------<->-

                ● 番号 num のパターンの大きさを得ます。

                → 0x0101 〜 0x1080  パターンの大きさ

                ★ 得られるサイズは、super_entry_pat() で指定する
                   size と同じ値で、上位 8 ビットが xdots / 8、下
                   位 8 ビットが ydots です。

------------------------------------------------------------------------
□ super_getsize_pat_x - パターンの幅を得る

C:      int super_getsize_pat_x( int num );                マクロ

        ------------------------------------------98N 98H AT DOS-
        super_getsize_pat_x
        -----------------------------------------------------<->-

                ● 番号 num のパターンの xdots を得ます。

                → 8 〜 128  パターンの横ドット数(xdots)

------------------------------------------------------------------------
□ super_getsize_pat_y - パターンの高さを得る

C:      int super_getsize_pat_y( int num );                マクロ

        ------------------------------------------98N 98H AT DOS-
        super_getsize_pat_y
        -----------------------------------------------------<->-

                ● 番号 num のパターンの ydots を得ます。

                → 1 〜 128  パターンの縦ドット数(ydots)


------------------------------------------------------------------------
■ パターンの表示(super_put系) ■■■■■■■■■■■■■■■■■■■■

        　super_put() 系の関数は、パターンの表示/消去を行います。

        　super_put() 系の関数は、 パターンを表示する際に背景を待
        避しないため、 パターンを消去するには工夫が必要です。その
        方法としては以下のようなものが考えられます。

         ・背景を裏ページに保存
         ・パターンの上に背景を再描画
         ・背景を仮想VRAMに保存

        　最初の方法は『蟹味噌』等で使われた方法ですが、 二画面切
        り換えができなくなるためちらつきが発生してしまいます。 こ
        の方法を実現している関数が super_repair() と repair_back()
        です。

        　二番目の方法は alty氏の『か〜に』等で使われています。背
        景をパターンで描画している場合には有効です。しかし、 これ
        を実現するための関数は特別には用意されていません。
        over_put_8() 等で背景を描画するか、自前の関数を使う必要が
        あります。

        　三番目の方法については仮想VRAM系の項で説明します。

        　roll 系の関数はスクロールゲーム等に使用すると便利です。

------------------------------------------------------------------------
□ repair_back, vga4_repair_back - パターンを裏画面の絵で消去(8dot単位)

C:      void repair_back( int x, int y, int num );
C:      void vga4_repair_back( int x, int y, int num );    マクロ

        ------------------------------------------98N 98H AT DOS-
        repair_back                                Ｖ  × ＊
        --------------------------------------------<repair.asm>-
        vga4_repair_back                           ×  × Ｖ
        -----------------------------------------------------<->-

                ● 左上座標が  (x,   y)の位置に表示されている番号
                   num のパターンを1ページの背景で消去します。

                ★ クリッピングは行っていません。
                ★ あらかじめ 0ページと同じ背景を 1ページにも描画
                   または転送しておく必要があります。転送は
                   graph_copy_page() 関数を利用すれば簡単です。
                ★ X 方向は 8  ドット単位で消去されてしまうので、
                   同一バイト上に表示されているパターンは一緒に消
                   去されます。
                ★ 高速形式で表示されたものでも消去できます。
                ★ super_repair() 関数よりも高速です。

------------------------------------------------------------------------
□ slice_put - パターンの指定ラインを表示(8dot単位)

C:      void slice_put( int x, int y, int num, int line );

        ------------------------------------------98N 98H AT DOS-
        slice_put                                  Ｖ  × ×
        ------------------------------------------<sliceput.asm>-

                ● 左上座標が((x &~7), y)の位置に、番号 num  のパ
                   ターンの line 行目だけを上書き表示します。

                ★ クリッピングは行っていません。

------------------------------------------------------------------------
□ super_put, vga4_super_put - パターンの表示

C:      void super_put( int x, int y, int num );
C:      void vga4_super_put(int x, int y, int num);

        ------------------------------------------98N 98H AT DOS-
        super_put                                  Ｖ  × ＊
        ------------------------------------------<superput.asm>-
        vga4_super_put                             ×  × ○
        ------------------------------------------<vg4spput.asm>-

                ● 左上座標が(x, y)の位置に、番号 num  のパターン
                   を表示します。

                ★ クリッピングは行っていません。

------------------------------------------------------------------------
□ super_put_8, vga4_super_put_8 - パターンの表示(8dot単位)

C:      void super_put_8( int x, int y, int num );
C:      void vga4_super_put_8(int x, int y, int num);

        ------------------------------------------98N 98H AT DOS-
        super_put_8                                Ｖ  × ＊
        ------------------------------------------<superpt8.asm>-
        vga4_super_put_8                           ×  × ○
        ------------------------------------------<vg4sppt8.asm>-

                ● 左上座標が(x, y)の位置に、番号 num  のパターン
                   を表示します。

                ○ xは8の倍数に切り捨てられます。

                ★ クリッピングは行っていません。
                ★ シフトが不要のため、super_put() 関数よりも高速
                   です。

------------------------------------------------------------------------
□ super_put_clip, vga4_super_put_clip - パターンの表示(y clip)

C:      void super_put_clip( int x, int y, int num );
C:      void vga4_super_put_clip(int x, int y, int num);

        ------------------------------------------98N 98H AT DOS-
        super_put_clip                             Ｖ  × ＊
        ------------------------------------------<superclp.asm>-
        vga4_super_put_clip                        ×  × Ｖ
        ------------------------------------------<vg4spclp.asm>-

                ● 左上座標が(x, y)の位置に、番号 num  のパターン
                   を表示します。

                ★ <98>Y 方向のみ 400line  でクリッピングを行って
                   います。
                ★ <AT>Y 方向のみ画面の大きさでクリッピングを行っ
                   ています。

------------------------------------------------------------------------
□ super_put_clip_8 - パターンの表示(y clip, 8dot単位)

C:      void super_put_clip_8( int x, int y, int num );

        ------------------------------------------98N 98H AT DOS-
        super_put_clip_8                           Ｖ  × ×
        ------------------------------------------<supermch.asm>-

                ● 左上座標が(x, y)の位置に、番号 num  のパターン
                   を表示します。

                ★ Y 方向のみ 400line  でクリッピングを行っていま
                   す。
                ★ X 方向の指定は 8 ドット単位です。 その間を指定
                   した場合には下位  3 ビットが切り捨てられた位置
                   になります。
                ★ シフトが不要のため、super_put_clip()関数よりも
                   高速です。

------------------------------------------------------------------------
□ super_put_tiny - 16xｎdotパターンの高速表示

C:      void super_put_tiny(  int x, int y, int num );

        ------------------------------------------98N 98H AT DOS-
        super_put_tiny                             Ｖ  × ×
        ------------------------------------------<superptt.asm>-

                ● 左上座標が(x, y)の位置に、番号 num の横幅16dot
                   のパターンを表示します。

                ★ クリッピングは行っていません。
                ★ この関数で表示するには、  パターンデータ形式を
                   super_convert_tiny  によって正常に変更されてい
                   なければなりません。

                ★ パターンの横の大きさが 16dot以外であれば、異常
                   なパターンが表示されます。

------------------------------------------------------------------------
□ super_put_tiny_small - 8xｎdotパターンの高速表示

C:      void super_put_tiny_small(  int x, int y, int num );

        ------------------------------------------98N 98H AT DOS-
        super_put_tiny_small                       Ｖ  × ×
        ------------------------------------------<supertt8.asm>-

                ● 左上座標が(x, y)の位置に、番号 num の  8xｎdot
                   パターンを表示します。

                ★ クリッピングは行っていません。
                ★ パターンの縦ドット数ｎは偶数でなければいけませ
                   ん。
                ★ この関数で表示するには、  パターンデータ形式を
                   super_convert_tiny  によって正常に変更されてい
                   なければなりません。

                ★ パターンの大きさが 8xｎdot以外であれば、異常な
                   パターンが表示されます。

------------------------------------------------------------------------
□ super_put_tiny_small_vrev - 8xｎdotパターンの高速表示(上下反転)

C:      void super_put_tiny_small_vrev(  int x, int y, int num );

        ------------------------------------------98N 98H AT DOS-
        super_put_tiny_small_vrev                  Ｖ  × ×
        ------------------------------------------<supert8v.asm>-

                ● 左上座標が(x, y)の位置に、番号 num の  8xｎdot
                   パターンを上下逆さに表示します。

                ★ クリッピングは行っていません。
                ★ パターンの縦ドット数ｎは偶数でなければいけませ
                   ん。
                ★ この関数で表示するには、  パターンデータ形式を
                   super_convert_tiny  によって正常に変更されてい
                   なければなりません。

                ★ パターンの大きさが 8xｎdot以外であれば、異常な
                   パターンが表示されます。

------------------------------------------------------------------------
□ super_put_tiny_vrev - 16xｎdotパターンの高速表示(上下反転)

C:      void super_put_tiny_vrev(  int x, int y, int num );

        ------------------------------------------98N 98H AT DOS-
        super_put_tiny_vrev                        Ｖ  × ×
        ------------------------------------------<superptv.asm>-

                ● 左上座標が(x, y)の位置に、番号 num の横幅16dot
                   のパターンを上下逆さに表示します。

                ★ クリッピングは行っていません。
                ★ この関数で表示するには、  パターンデータ形式を
                   super_convert_tiny  によって正常に変更されてい
                   なければなりません。

                ★ パターンの横の大きさが 16dot以外であれば、異常
                   なパターンが表示されます。

------------------------------------------------------------------------
□ super_put_vrev, vga4_super_put_vrev - パターンの表示(上下反転)

C:      void super_put_vrev( int x, int y, int num );
C:      void vga4_super_put_vrev(int x, int y, int num);

        ------------------------------------------98N 98H AT DOS-
        super_put_vrev                             Ｖ  × ＊
        ------------------------------------------<superpvr.asm>-
        vga4_super_put_vrev                        ×  × Ｖ
        ------------------------------------------<vg4sppvr.asm>-

                ● 左上座標が(x, y)の位置に、番号 num  のパターン
                   を上下逆転して表示します。画面下端を越えた部分
                   は上端から出てきます。

                ★ クリッピングは行っていません。

------------------------------------------------------------------------
□ super_repair - パターンを裏画面の絵で消去

C:      void super_repair( int x, int y, int num );

        ------------------------------------------98N 98H AT DOS-
        super_repair                               Ｖ  × ×
        ------------------------------------------<superrep.asm>-

                ● 左上座標が  (x,   y)の位置に表示されている番号
                   num のパターンを1ページの背景で消去します。

                ★ クリッピングは行っていません。
                ★ あらかじめ 0ページと同じ背景を 1ページにも描画
                   または転送しておく必要があります。転送は
                   graph_copy_page() 関数を利用すれば簡単です。
                ★ 高速形式で表示されたものは消去できません。

------------------------------------------------------------------------
□ super_roll_put, vga4_super_roll_put - パターンの表示(画面上下接続)

C:      void super_roll_put( int x, int y, int num );
C:      void vga4_super_roll_put(int x, int y, int num);

        ------------------------------------------98N 98H AT DOS-
        super_roll_put                             Ｖ  × ＊
        ------------------------------------------<superoll.asm>-
        vga4_super_roll_put                        ×  × Ｖ
        ------------------------------------------<vg4sprol.asm>-

                ● 左上座標が(x, y)の位置に、番号 num  のパターン
                   を表示します。画面下端を越えた部分は上端から出
                   てきます。

                ★ クリッピングは行っていません。
                ★ 引数 y は、0 ≦ y < graph_VramLines の範囲内に
                   なければなりません。
                   <98> 0 ≦ y < 400 固定です。

------------------------------------------------------------------------
□ super_roll_put_8 - パターンの表示(画面上下接続, 8dot単位)

C:      void super_roll_put_8( int x, int y, int num );

        ------------------------------------------98N 98H AT DOS-
        super_roll_put_8                           Ｖ  × ×
        ------------------------------------------<superol8.asm>-

                ● 左上座標が(x, y)の位置に、番号 num  のパターン
                   を表示します。画面下端を越えた部分は上端から出
                   てきます。

                ○ xは8の倍数に切り捨てられます。

------------------------------------------------------------------------
□ super_roll_put_tiny - 16x16dotパターンの高速表示(画面上下接続)

C:      void super_roll_put_tiny(  int x, int y, int num );

        ------------------------------------------98N 98H AT DOS-
        super_roll_put_tiny                        Ｖ  × ×
        ------------------------------------------<superrpt.asm>-

                ● 左上座標が(x, y)の位置に、番号 num の 16x16dot
                   パターンを表示します。

                ★ クリッピングは行っていません。
                ★ この関数で表示するには、  パターンデータ形式を
                   super_convert_tiny  によって正常に変更されてい
                   なければなりません。

                ★ パターンの Y 方向 400 ラインを越えて表示しよう
                   とした部分は 0 ライン以降に表示します。

                ★ 引数 y は、0 ≦ y ≦ 399  の範囲内になければな
                   りません。

                ★ パターンの大きさが 16x16dot以外であれば、 異常
                   なパターンが表示されます。


------------------------------------------------------------------------
■ キャラクタの表示(super_in系) ■■■■■■■■■■■■■■■■■■■■

        　super_in() 系の関数は、キャラクタの表示/消去を行います。

        　キャラクタを表示する際に背景を保存しているので、 複数の
        キャラクタ消去する際には、 消去する順番に気をつける必要が
        あります。通常の使用では後に表示したものから順に(表示の順
        の反対)消去していれば問題ありません。

        　それぞれのキャラクタには、1回分の背景保存バッファしかな
        いので、 同一番号のキャラクタを二ヶ所以上に表示すると正常
        な消去ができなくなります。二画面切り替えをする場合には、0
        ページ用と1ページ用の二つのキャラクタが必要となるので注意
        してください。

------------------------------------------------------------------------
□ repair_out, vga4_repair_out - キャラクタの除去(8dot単位)

C:      void repair_out( int x, int y, int num );
C:      void vga4_repair_out(int x, int y, int num);

        ------------------------------------------98N 98H AT DOS-
        repair_out                                 Ｖ  × ＊
        --------------------------------------------<repout.asm>-
        vga4_repair_out                            ×  × ○
        ------------------------------------------<vg4rpout.asm>-

                ● 左上座標が  (x,   y)の位置に表示されている番号
                   num のキャラクタを消去します。

                ★ クリッピングは行っていません。
                ★ X 方向は 8  ドット単位で消去されてしまうので、
                   同一バイト上に表示されているパターンは一緒に消
                   去されます。
                ★ super_out() 関数よりも高速です。

------------------------------------------------------------------------
□ super_in, vga4_super_in - キャラクタの表示

C:      void super_in( int x, int y, int num );
C:      void vga4_super_in(int x, int y, int num);

        ------------------------------------------98N 98H AT DOS-
        super_in                                   Ｖ  × ＊
        -------------------------------------------<superin.asm>-
        vga4_super_in                              ×  × ○
        -------------------------------------------<vg4spin.asm>-

                ● 左上座標が(x, y)の位置に、番号 num  のキャラク
                   タを表示します。

                ★ クリッピングは行っていません。

------------------------------------------------------------------------
□ super_out - キャラクタの除去

C:      void super_out( int x, int y, int num );

        ------------------------------------------98N 98H AT DOS-
        super_out                                  Ｖ  × ×
        ------------------------------------------<superout.asm>-

                ● 左上座標が  (x,   y)の位置に表示されている番号
                   num のキャラクタを消去します。

                ★ クリッピングは行っていません。


------------------------------------------------------------------------
■ 仮想VRAM系 ■■■■■■■■■■■■■■■■■■■■■■■■■■■■■

        　仮想VRAM系の関数は、super_put()  系の関数で表示されたパ
        ターンを仮想VRAMに保存されている背景で消去します。

        　仮想VRAMとしてメインメモリを 128KB(640x400の場合)  消費
        しますが、 メモリに余裕がある場合には、最も高速に二画面切
        り替えを行うことができます。

        　背景を仮想VRAMに転送する必要があるので、 スクロールゲー
        ムには適しません。

------------------------------------------------------------------------
□ 構造体／グローバル変数

unsigned virtual_seg;           仮想VRAMの先頭セグメントアドレス
                                (0=未確保)

------------------------------------------------------------------------
□ virtual_copy, vga4_virtual_copy - 仮想VRAMの確保と実画面からの転送

C:      int virtual_copy(void);
C:      int vga4_virtual_copy(void);

        ------------------------------------------98N 98H AT DOS-
        virtual_copy                               Ｖ  × ＊ ○
        -------------------------------------------<vircopy.asm>-
        vga4_virtual_copy                          ×  × Ｖ
        ------------------------------------------<vg4vcopy.asm>-

                ● 仮想VRAMを確保して、グラフィック VRAM のアクテ
                   ィブページを確保した仮想VRAMにコピーします。
                ● <AT>実画面(graph_VramWords*4ワード)と同じ大き
                   さの仮想VRAMを確保し、実画面の内容で埋めます。

                → NoError             成功
                   InsufficientMemory  仮想VRAMの為のメモリが足り
                                       ない

                ★ 仮想VRAMを確保するのは最初に呼び出された時だけ
                   です。
                ★ 二度目以降は virtual_vram_copy()  関数を呼ぶと
                   少し速いかな??

                ○ 仮想VRAMのために確保したメモリを開放するには、
                   virtual_free()を利用してください。

                △MEMORY: graph_VramWords/2  パラグラフ(640x400時
                  は8000パラグラフ)のブロックを確保します。

------------------------------------------------------------------------
□ virtual_free - 仮想VRAMの開放

C:      void virtual_free(void);

        ------------------------------------------98N 98H AT DOS-
        virtual_free
        -------------------------------------------<virfree.asm>-

                ● 仮想VRAMに使用していたメモリを開放します。

                △MEMORY:  仮想VRAMに使用していたメモリを開放しま
                  す。

------------------------------------------------------------------------
□ virtual_repair, vga4_virtual_repair - 仮想VRAMから実画面へ転送

C:      void virtual_repair( int x, int y, int num );
C:      void vga4_virtual_repair(int x, int y, int num);

        ------------------------------------------98N 98H AT DOS-
        virtual_repair                             Ｖ  × ＊
        --------------------------------------------<virrep.asm>-
        vga4_virtual_repair                        ×  × Ｖ
        -------------------------------------------<vg4vrep.asm>-

                ● 左上座標が  (x,   y)の位置に表示されている番号
                   num のパターンを仮想VRAMの背景で消去します。

                ★ クリッピングは行っていません。
                ★ あらかじめアクティブページ用の背景を仮想VRAMに
                   も転送しておく必要があります。転送は
                   virtual_copy() または vga4_virtual_copy() 関数
                   で行います。
                ★ X 方向は 8  ドット単位で消去されてしまうので、
                   同一バイト上に表示されているパターンは一緒に消
                   去されます。
                ★ 高速形式で表示されたものでも消去できます。

------------------------------------------------------------------------
□ virtual_vram_copy, vga4_virtual_vram_copy -  実画面を仮想VRAMに転送す
   る

C:      void virtual_vram_copy(void);
C:      void vga4_virtual_vram_copy(void);

        ------------------------------------------98N 98H AT DOS-
        virtual_vram_copy                          Ｖ  × ＊
        -------------------------------------------<vircopy.asm>-
        vga4_virtual_vram_copy                     ×  × Ｖ
        ------------------------------------------<vg4vcopy.asm>-

                ● グラフィック VRAM のアクティブページを、確保し
                   た仮想VRAMにコピーします。

                ★ 仮想VRAMは、virtual_copy() または
                   vga4_virtual_copy() 関数により確保済みでなけれ
                   ばなりません。


------------------------------------------------------------------------
■ plane系 ■■■■■■■■■■■■■■■■■■■■■■■■■■■■■■

        　plane系の関数は、プレーンを分離して処理を行う関数群です。
        この関数群を利用すれば色違いのパターンも実現できます。

------------------------------------------------------------------------
□ super_roll_put_1plane - パターンを指定プレーンに表示(画面上下接続)

C:      void super_roll_put_1plane( int x, int y, int num,
                                   int pattern_plane, unsigned put_plane );

        ------------------------------------------98N 98H AT DOS-
        super_roll_put_1plane                      Ｖ  × ×
        ------------------------------------------<superl1p.asm>-

                ● 左上座標が (x, y) の位置に、番号 num  のパター
                   ンのpattern_plane プレーンのパターンを、
                   put_plane プレーンに表示します。

                ★ パターンの Y 方向 400 ラインを越えて表示しよう
                   とした部分は 0 ライン以降に表示します。
                ★ 引数 y は、0 ≦ y ≦ 399  の範囲内になければな
                   りません。

                ★ pattern_plane、put_plane の指定は、
                   super_put_1plane() の項を参照してください。

------------------------------------------------------------------------
□ super_roll_put_1plane_8 - パターンを指定プレーンに表示(8dot単位, 画面
   上下接続)

C:      void super_roll_put_1plane_8( int x, int y, int num,
                                     int pattern_plane, unsigned put_plane );

        ------------------------------------------98N 98H AT DOS-
        super_roll_put_1plane_8                    Ｖ  × ×
        ------------------------------------------<superl18.asm>-

                ● 左上座標が (x, y) の位置に、番号 num  のパター
                   ンの pattern_plane プレーンのパターンを、
                   put_plane プレーンに表示します。画面下端を越え
                   た部分は上端から出てきます。

                ○ xは8の倍数に切り捨てられます。

                ★ 引数 y は、0 ≦ y ≦ 399  の範囲内になければな
                   りません。
                ★ pattern_plane、put_plane の指定は、
                   super_put_1plane() の項を参照してください。

------------------------------------------------------------------------
□ super_put_1plane, vga4_super_put_1plane -  パターンを指定プレーンに表
   示

C:      void super_put_1plane( int x, int y, int num,
                              int pattern_plane, unsigned put_plane );
C:      void vga4_super_put_1plane( int x, int y,  int  num,  int
                                   pattern_plane, unsigned
                                   put_plane );

        ------------------------------------------98N 98H AT DOS-
        super_put_1plane                           Ｖ  × ＊
        ------------------------------------------<super1pl.asm>-
        vga4_super_put_1plane                      ×  × Ｖ
        ------------------------------------------<vg4sp1pl.asm>-

                ● 左上座標が (x, y) の位置に、番号 num  のパター
                   ンの pattern_plane プレーンのパターンを、
                   put_plane プレーンに表示します。

                ★ クリッピングは行っていません。

                    ・pattern_plane の指定は
                        パターン(消去)  PATTERN_ERASE 0
                        パターン(青)    PATTERN_BLUE  1
                        パターン(赤)    PATTERN_RED   2
                        パターン(緑)    PATTERN_GREEN 3
                        パターン(輝度)  PATTERN_INTEN 4
                      の中から選択します。

                    ・put_plane の指定は
                        全プレーン消去  PLANE_ERASE 0x00c0
                        プレーン(青)    PLANE_BLUE  0xffce
                        プレーン(赤)    PLANE_RED   0xffcd
                        プレーン(緑)    PLANE_GREEN 0xffcb
                        プレーン(輝度)  PLANE_INTEN 0xffc7
                      の中から選択します。 マクロとして定義されて
                      はいませんが、GRCG に送るデータを引数に直接
                      指定することで、 任意のプレーンの消去や複数
                      のプレーンへの描画ができます。

------------------------------------------------------------------------
□ super_put_1plane_8, vga4_super_put_1plane_8 -  パターンを指定プレーン
   に表示(8dot単位)

C:      void super_put_1plane_8( int x, int y, int num,
                                int pattern_plane, unsigned put_plane );
C:      void vga4_super_put_1plane_8( int x, int y, int num,  int
                                     pattern_plane, unsigned
                                     put_plane );

        ------------------------------------------98N 98H AT DOS-
        super_put_1plane_8                         Ｖ  × ＊
        ------------------------------------------<super1p8.asm>-
        vga4_super_put_1plane_8                    ×  × Ｖ
        ------------------------------------------<vg4sp1p8.asm>-

                ● 左上座標が (x, y) の位置に、番号 num  のパター
                   ンの pattern_plane プレーンのパターンを、
                   put_plane プレーンに表示します。

                ○ xは8の倍数に切り捨てられます。

                ★ クリッピングは行っていません。
                ★ pattern_plane、put_plane の指定は、
                   super_put_1plane() の項を参照してください。


------------------------------------------------------------------------
■ window系 ■■■■■■■■■■■■■■■■■■■■■■■■■■■■■■

        　window系の関数は、 クリッピングの範囲が変更できる  clip
        系の関数と考えることができます。

        　パターンを表示する範囲を window と呼びます。

------------------------------------------------------------------------
□ super_put_rect, vga4_super_put_rect - 枠クリッピング型パターン表示

C:      void super_put_rect( int x, int y, int num );
C:      void vga4_super_put_rect(int x, int y, int num);

        ------------------------------------------98N 98H AT DOS-
        super_put_rect                             Ｖ  × ＊
        ------------------------------------------<superptr.asm>-
        vga4_super_put_rect                        ×  × Ｖ
        ------------------------------------------<vg4spptr.asm>-

                ● super_put を grc_setclip範囲でクリッピングを行
                   うようにしたものです。

------------------------------------------------------------------------
□ super_put_vrev_rect, vga4_super_put_vrev_rect -  枠クリッピング型パタ
   ーン表示(上下反転)

C:      void super_put_vrev_rect( int x, int y, int num );
C:      void vga4_super_put_vrev_rect(int x, int y, int num);

        ------------------------------------------98N 98H AT DOS-
        super_put_vrev_rect                        Ｖ  × ＊
        ------------------------------------------<supervrr.asm>-
        vga4_super_put_vrev_rect                   ×  × Ｖ
        ------------------------------------------<vg4spvrr.asm>-

                ● super_put_vrev を  grc_setclip範囲でクリッピン
                   グを行うようにしたものです。

------------------------------------------------------------------------
□ super_put_window - 上下クリップ枠に対応したパターン表示

C:      void super_put_window( int x, int y, int num );

        ------------------------------------------98N 98H AT DOS-
        super_put_window                           Ｖ  × ×
        --------------------------------------------<window.asm>-

                ● 左上座標が(x, y)の位置に、番号 num  のパターン
                   を表示します。

                ★ 上下端のみ、super_set_window  で指定された範囲
                   でクリッピングを行っています。

------------------------------------------------------------------------
□ super_set_window - 上下クリップ枠を設定する

C:      void super_set_window( int top, int bottom );

        ------------------------------------------98N 98H AT DOS-
        super_set_window                           Ｖ  × ×
        --------------------------------------------<window.asm>-

                ● window の上端を top に、下端を bottom に設定し
                   ます。

                ★ top および bottom は、0 ≦ top ≦  399、 0  ≦
                   bottom  ≦ 399 の範囲内で、top < bottom でなけ
                   ればなりません。
                ★ デフォルトは、top = 0、bottom = 399 です。


------------------------------------------------------------------------
■ over_put系 ■■■■■■■■■■■■■■■■■■■■■■■■■■■■■

        　over_put系の関数は、透明処理を行わずに上書きを行います。
        over_put_8() は super_put_8() の 4 / 5 倍以下の時間で実行
        されるので(推測値)、背景等の描画に有効です。

------------------------------------------------------------------------
□ over_put_8, vga4_over_put_8 - パターンの上書き(8dot単位)

C:      void over_put_8( int x, int y, int num );
C:      void vga4_over_put_8(int x, int y, int num);

        ------------------------------------------98N 98H AT DOS-
        over_put_8                                 Ｖ  × ＊
        ------------------------------------------<overput8.asm>-
        vga4_over_put_8                            ×  × Ｖ
        ------------------------------------------<vg4oput8.asm>-

                ● 左上座標が(x, y)の位置に、番号 num  のパターン
                   を表示します。

                ○ xは8の倍数に切り捨てられます。

                ★ クリッピングは行っていません。

------------------------------------------------------------------------
□ over_roll_put_8, vga4_over_roll_put_8 - パターンの上書き(画面上下接続,
   8dot単位)

C:      void over_roll_put_8( int x, int y, int num );
C:      void vga4_over_roll_put_8(int x, int y, int num);

        ------------------------------------------98N 98H AT DOS-
        over_roll_put_8                            Ｖ  × ＊
        ------------------------------------------<overoll8.asm>-
        vga4_over_roll_put_8                       ×  × Ｖ
        ------------------------------------------<vg4orol8.asm>-

                ● 左上座標が(x, y)の位置に、番号 num  のパターン
                   を表示します。画面下にはみ出た部分は、上端から
                   続けます。

                ← x     0〜(画面幅 - パターンの横幅)。 値は8の倍
                         数に切り捨てます。
                   y    表示位置 (0 ≦ y < graph_VramLines)
                        <98>graph_VramLinesではなく、 400ライン固
                        定です。
                   num  パターン番号


------------------------------------------------------------------------
■ 拡大/縮小/変形表示 ■■■■■■■■■■■■■■■■■■■■■■■■■

        　パターンを変形などして表示します。
        　拡大時、スムージング等は行っていないので、 大きく拡大す
        るとギザギザした感じ(モザイク)になります。

        　縮小は、ドットを間引いて描画します。

        　変形は、sinカーブ型ラスタスクロール風表示や、縦の拡大率
        をデータの縦1ラインごとに変化させてゆく表示を行います。

------------------------------------------------------------------------
□ over_small_put_8 - パターンの2分の1縮小表示(8dot単位)

C:      void over_small_put_8( int x, int y, int num );

        ------------------------------------------98N 98H AT DOS-
        over_small_put_8                           Ｖ  × ×
        ------------------------------------------<smallpt8.asm>-

                ● 左上座標が (x, y) の位置に、番号 num  のパター
                   ンを 1 / 2 の大きさに縮小して表示します。

                ○ xは8の倍数に切り捨てられます。

                ★ 表示するパターンのサイズは、xdots は 16 の倍数、
                   ydots は 2 の倍数でなければなりません。
                ★ クリッピングは行っていません。

------------------------------------------------------------------------
□ super_large_put, vga4_super_large_put - パターンの2倍拡大表示

C:      void super_large_put( int x, int y, int num );
C:      void vga4_super_large_put(int x, int y, int num);

        ------------------------------------------98N 98H AT DOS-
        super_large_put                            Ｖ  × ＊
        ------------------------------------------<largeput.asm>-
        vga4_super_large_put                       ×  × Ｖ
        ------------------------------------------<vg4lgput.asm>-

                ● 左上座標が (x, y) の位置に、番号 num  のパター
                   ンを 2 倍の大きさに拡大して表示します。

                ★ 倍率は 2 倍に固定されているが、super_zoom() 関
                   数より高速です。
                ★ クリッピングは行っていません。

------------------------------------------------------------------------
□ super_vibra_put, vga4_super_vibra_put -  パターンを縦方向に伸縮変形表
   示

C:      void super_vibra_put( int x, int y, int num, int len, int
                             ph);
C:      void vga4_super_vibra_put( int x, int y, int num, int len,
                                  int ph);

        ------------------------------------------98N 98H AT DOS-
        super_vibra_put                            Ｖ  × ＊
        ------------------------------------------<supervib.asm>-
        vga4_super_vibra_put                       ×  × Ｖ
        ------------------------------------------<vg4spvib.asm>-

                ● 左上座標が(x, y)の位置に、番号 num  のパターン
                   を、波長 len、位相 ph で縦方向に伸び縮みするよ
                   うに歪ませて表示します。
                   　位相 ph を少しずつ変化させながら表示を繰返し
                   て、パターンを波打っているように見せるのが基本
                   的な使い方です。

                   　表示速度は super_put() の1.5倍ぐらい遅い程度
                   です。

                ★ クリッピングは行っていません。
                ★ パターンの yドット数は64dotまでです。
                ★ 波長 len : 1〜?[dot]
                   位相 ph  : -32768〜32767[一周を256とする角度単
                            位]
                   これらの値はチェックしていません。
                   波長に 0を指定するとゼロ除算エラーが発生します。

------------------------------------------------------------------------
□ super_vibra_put_1plane - パターンを縦方向に揺らして表示(指定プレーン)

C:      void super_vibra_put_1plane( int x, int y, int  num,  int
                                    len, int ph, int
                                    pattern_plane, unsigned
                                    put_plane);

        ------------------------------------------98N 98H AT DOS-
        super_vibra_put_1plane                     Ｖ  × ×
        ------------------------------------------<supervb1.asm>-

                ● 左上座標が(x, y)の位置に、番号 num  のパターン
                   の pattern_plane プレーンのパターンを
                   put_plane プレーンに、波長 len、位相 ph でバネ
                   が伸び縮みするように歪ませて表示します。
                   　super_vibra_put() の plane系です。

------------------------------------------------------------------------
□ super_wave_put, vga4_super_wave_put - パターンを横方向に波状変形表示

C:      void super_wave_put( int x, int y, int num, int len, char
                            amp, int ph);
C:      void vga4_super_wave_put( int x, int y, int num, int len,
                                 char amp, int ph);

        ------------------------------------------98N 98H AT DOS-
        super_wave_put                             Ｖ  × ＊
        ------------------------------------------<superwav.asm>-
        vga4_super_wave_put                        ×  × Ｖ
        ------------------------------------------<vg4spwav.asm>-

                ● 左上座標が(x, y)の位置に、番号 num  のパターン
                   を、波長 len、振幅 amp、位相 ph で横方向にうね
                   らせて表示します。
                   　位相 ph を少しずつ変化させながら表示を繰返し
                   て、パターンを波打っているように見せるのが基本
                   的な使い方です。
                   　パラメータをいろいろ調整するとおもしろい効果
                   が得られます。
                   　例えば、波長 len を 2 や 3  とかの極端に小さ
                   い値にするとパターンが分身したように見えます。
                   　表示速度は super_put() の1.5倍ぐらい遅い程度
                   です。

                ★ クリッピングは行っていません。
                ★ パターンのyドット数は 64dotまでです。
                ★ 波長 len : -32767〜-1,1〜32767[dot]
                   振幅 amp : -127〜127[dot]
                   位相 ph  : -32768〜32767[一周を256とする角度単
                            位]
                   これらの値はチェックしていません。
                   特に波長 lenに 0を指定するとゼロ除算エラーが発
                   生します。
                ★ 負の振幅では位相が反転します。
                ★ 負の波長では位相がライン毎に反転します。
                   実際の波長は絶対値となります。

------------------------------------------------------------------------
□ super_wave_put_1plane, vga4_super_wave_put_1plane -  パターンを横方向
   に波状変形表示(指定プレーン)

C:      void super_wave_put_1plane( int x, int y,  int  num,  int
                                   len,  char  amp,  int  ph, int
                                   pattern_plane, unsigned
                                   put_plane);
C:      void vga4_super_wave_put_1plane( int x, int y,  int  num,
                                        int len, char amp, int ph,
                                        int pattern_plane,
                                        unsigned put_plane);

        ------------------------------------------98N 98H AT DOS-
        super_wave_put_1plane                      Ｖ  × ＊
        ------------------------------------------<superwb1.asm>-
        vga4_super_wave_put_1plane                 ×  × Ｖ
        ------------------------------------------<vg4spwv1.asm>-

                ● 左上座標が(x, y)の位置に、番号 num  のパターン
                   の pattern_plane プレーンのパターンを
                   put_plane プレーンに、波長 len、振幅 amp、位相
                   ph で横方向にうねらせて表示します。

                ★ super_wave_put() の plane系です。

------------------------------------------------------------------------
□ super_zoom, vga4_super_zoom - パターンの任意拡大表示

C:      void super_zoom( int x, int y, int num, int rate );
C:      void vga4_super_zoom(int x, int y, int num, int rate);

        ------------------------------------------98N 98H AT DOS-
        super_zoom                                 Ｖ  × ＊
        ------------------------------------------<superzom.asm>-
        vga4_super_zoom                            ×  × Ｖ
        ------------------------------------------<vg4spzom.asm>-

                ● 左上座標が (x, y) の位置に、番号 num  のパター
                   ンを rate 倍の大きさに拡大して表示します。

                ★ super_change_erase_pat()、
                   super_change_erase_bfnt()、
                   bfnt_change_erase_pat() 関数による消去パターン
                   の変更には対応していません。
                ★ 透明色が color 0 以外のパターンを表示した場合、
                   透明色以外に color 0 も透明色となり、 背景が残
                   って表示されます。

------------------------------------------------------------------------
□ super_zoom_put, vga4_super_zoom_put - パターンの拡大/縮小表示

C:      void super_zoom_put( int x,  int  y,  int  num,  unsigned
                            x_rate, int y_rate);
C:      void vga4_super_zoom_put( int x, int y, int num, unsigned
                                 x_rate, int y_rate);

        ------------------------------------------98N 98H AT DOS-
        super_zoom_put                             Ｖ  × ＊
        ------------------------------------------<superzpt.asm>-
        vga4_super_zoom_put                        ×  × Ｖ
        ------------------------------------------<vg4spzpt.asm>-

                ● 左上座標が(x, y)の位置に、番号 num  のパターン
                   を x方向に (x_rate / 256)倍、y方向に (y_rate /
                   256)倍に拡大または縮小して表示します。 拡大/縮
                   小の中心は(x, y)固定です。
                   　y_rateが負の場合は、縦反転されたパターンを、
                   -y_rateとして表示します。このため、 x_rateは約
                   256倍までですが、y_rateは約128倍までしかできま
                   せん。
                   　super_zoom() と異なるのは、縮小ができること、
                   倍率を 1/256単位で単位で指定できること、 x方向
                   とy方向の倍率を別々に指定できることです。
                   　表示速度は super_zoom() よりわずかに遅い程度
                   です。とはいっても内部で grcg_boxfill() を使っ
                   て 1ドットずつ表示しているので super_put()  と
                   は比較にならないくらい低速です。

                ★ x_rate や y_rate には 0 を指定してはいけません。
                ★ 透明色について super_zoom() と同じ制限がありま
                   す。
                ○ grc_setclip範囲でクリッピングします。

------------------------------------------------------------------------
□ super_zoom_put_1plane - パターンの拡大/縮小表示(指定プレーン)

C:      void super_zoom_put_1plane(  int  x,  int  y,  int   num,
                                   unsigned x_rate, unsigned
                                   y_rate,   int   pattern_plane,
                                   unsigned put_plane);

        ------------------------------------------98N 98H AT DOS-
        super_zoom_put_1plane                      Ｖ  × ×
        ------------------------------------------<superz1p.asm>-

                ● 左上座標が(x, y)の位置に、番号 num  のパターン
                   の  pattern_plane プレーンのパターンを x方向に
                   (x_rate / 256)倍、y方向に (y_rate / 256)倍に拡
                   大または縮小して表示します。
                   　要するに super_zoom_put()  の  plane系です。
                   (「plane系」参照)

                ★ plane系関数は通常の(plane系でない)関数より4倍
                   ぐらい高速なのが普通ですが、この関数に限っては
                   super_zoom_put()とほとんど速度が変わりません。

                ★ x_rate や y_rate には 0 を指定してはいけません。
                ★ 透明色について super_zoom() と同じ制限がありま
                   す。
                ○ grc_setclip範囲でクリッピングします。

------------------------------------------------------------------------
□ super_zoom_v_put - パターンの縦拡大/縮小表示

C:      void super_zoom_v_put( int x, int y,  int  num,  unsigned
                              rate);

        ------------------------------------------98N 98H AT DOS-
        super_zoom_v_put                           Ｖ  × ＊
        ------------------------------------------<superzmv.asm>-

                ● 左上座標が(x, y)の位置に、番号 num  のパターン
                   を、 y方向に(rate / 256)倍に拡大または縮小して
                   表示します。拡大/縮小の中心は(x, y)固定です。

                ★ rate には 0 を指定してはいけません。
                ★ クリッピングはしていません。

------------------------------------------------------------------------
□ super_zoom_v_put_1plane, vga4_super_zoom_v_put_1plane -  パターンの縦
   拡大/縮小表示(指定プレーン)

C:      super_zoom_v_put_1plane( int x, int y, int num,  unsigned
                                rate, int pattern_plane, unsigned
                                put_plane);
C:      void vga4_super_zoom_v_put_1plane( int x, int y, int num,
                                          unsigned rate, int
                                          pattern_plane, unsigned
                                          put_plane );

        ------------------------------------------98N 98H AT DOS-
        super_zoom_v_put_1plane                    Ｖ  × ＊
        ------------------------------------------<superzv1.asm>-
        vga4_super_zoom_v_put_1plane               ×  × Ｖ
        ------------------------------------------<vg4spzv1.asm>-

                ● 左上座標が(x, y)の位置に、番号 num  のパターン
                   の pattern_plane プレーンのパターンを
                   put_plane  プレーンに、y方向に(rate / 256)倍に
                   拡大または縮小して表示します。 拡大/縮小の中心
                   は(x, y)固定です。
                   　super_zoom_v_put() の plane系です。


------------------------------------------------------------------------
■ 図形描画・設定関係 ■■■■■■■■■■■■■■■■■■■■■■■■■

        grc_setclipは、グラフィック画面に描画する際、クリッピング
        を行う関数のための座標範囲を設定する関数です。
        この関数により、 (対応している関数を使えば)画面の任意の長
        方形領域にのみ、 はみださないように描画させることができま
        す。

------------------------------------------------------------------------
□ 構造体／グローバル変数

        ● クリッピング関連の変数
const int ClipXL ;              クリップ枠左端のx座標
const int ClipXW ;              クリップ枠左右端のx座標の差
const int ClipXR ;              クリップ枠右端のx座標
const int ClipYT ;              クリップ枠上端のy座標
const int ClipYH ;              クリップ枠上下端のy座標の差
const int ClipYB ;              クリップ枠下端のy座標
const unsigned ClipYT_seg ;     クリップ枠上端の、x = 0  の地点の
                                VRAM(青プレーン)セグメントアドレ
                                ス。graph_VramSeg, ClipYT  に基づ
                                いて grc_setclip で計算されます。
const unsigned ClipYB_adr       クリップ枠下端の、x = 0  の地点の
                                ClipYT_seg  からの  VRAM オフセッ
                                トアドレス

------------------------------------------------------------------------
□ grc_setclip - クリップ枠を設定する

C:      int  grc_setclip( int xl, int yt, int xr, int yb );

        ------------------------------------------98N 98H AT DOS-
        grc_setclip
        ----------------------------------------------<clip.asm>-

                ● 画面の描画クリップ枠を設定します。
                   指定領域が完全に画面の外に出ていると、中途半端
                   に設定して 0 を返します。 この場合はすぐに再設
                   定して下さい。
                   名前がClipで始まる変数の設定を行います。

                ○ 初期値は、(0,0)〜(639,399)に設定してあります。
                   また、graph_start, graph_enter, graph_400line,
                   graph_200line などによって画面モードを変更した
                   場合、自動的に画面全体に設定されます。


------------------------------------------------------------------------
■ 図形描画・色設定 ■■■■■■■■■■■■■■■■■■■■■■■■■■

        　図形描画関数は、 色や演算をあらかじめ設定してから呼び出
        します。そのための色などの指定を行う関数です。
        　アクセスプレーン、色、演算などが指定できます。

        　98では、grcg_setcolorなどで色を指定し、一連のグラフィッ
        クの描画が終わったら必ず grcg_offを実行してください。
        　VGAでは、vgc_setcolorで色を指定します。

        ・なお、関数名の頭にある grcg_ は、98搭載のグラフィック描
          画補助ハードウェア・グラフィックチャージャ(GRCG)を、
          vgc_は、VGAのグラフィックコントローラ(GC)を制御して描画
          することを意味します。

------------------------------------------------------------------------
□ 構造体／グローバル変数

typedef struct Point {          座標を表します。
  int x,y ;
} Point ;

long SolidTile[0..15]           あらかじめ用意された単色を表す
                                1lineタイルの配列です。
                                grcg_settile_1line()に指定できま
                                す。

------------------------------------------------------------------------
□ 定数

        ● GRCG モード値(grcg_setcolor,grcg_setmode)
        表記    値      意味
        GC_OFF  0       　GRCG のスイッチを切る。grcg_off()  と同
                        じです。
        GC_TDW  0x80    　書き込みが起こると、 タイルレジスタの内
                        容を書き込む。 書き込もうとしたデータは無
                        視される。GC_TCR と同じモード。
        GC_TCR  0x80    　読み込みが起こると、 タイルレジスタと一
                        致する色を持つドットだけ1を立てたビットパ
                        ターンが読み込まれる。GC_TDW と同じモード。
        GC_RMW  0xc0    　書き込みが起こると、 ビットが立ってると
                        ころはタイルレジスタの対応するドットが書
                        き込まれ、 立っていない所は現在の内容が保
                        存される。読み込んではならない。

        ● 描画演算指定(vgc_setcolor)
        表記            値      意味
        VGA_PSET        0x00f0  PSET(通常)描画モード
        VGA_AND         0x08f0  AND描画モード
        VGA_OR          0x10f0  OR描画モード
        VGA_XOR         0x18f0  XOR描画モード

        ● アクセスプレーン指定(grcg_setcolor)
        表記            値      意味
        GC_B            0x0e    青プレーンをアクセスする
        GC_R            0x0d    赤プレーンをアクセスする
        GC_BR           0x0c            :
        GC_G            0x0b    赤プレーンをアクセスする
        GC_BG           0x0a            :
        GC_RG           0x09
        GC_BRG          0x08            :
        GC_I            0x07    輝度プレーンをアクセスする
        GC_BI           0x06            :
        GC_RI           0x05
        GC_BRI          0x04
        GC_GI           0x03
        GC_BGI          0x02
        GC_RGI          0x01            :
        GC_BRGI         0x00     全プレーンをアクセスする

        ・以下の表の詳細はVGAに関する資料を参照してください。

        ● VGAレジスタインデックスなど
        表記            値      意味
        VGA_PORT        0x03ce
        VGA_COLOR_CMP_REG 2
        VGA_READPLANE_REG 4     ←readplaneは下位2bitにプレーン番
                                  号を書く
        VGA_MODE_REG      5     描画関数ごとに要設定
        VGA_MULTI_REG     6
        VGA_DISABLECMP    7
        VGA_BITMASK_REG   8     描画関数ごとに要設定

        ● VGA_MODE_REGレジスタに設定する内容
        表記            値      意味
        VGA_READPLANE   0       readmap選択regの場所をそのまま読
                                む
        VGA_COMPARE     8       読み込み時色比較レジスタと一致し
                                たらbit on

        ● GCのモード値
        表記            値      意味
        VGA_NORMAL      0       通常モード
        VGA_LATCH       1       コピーモード
        VGA_FILL        2       塗り潰しモード
        VGA_CHAR        3       文字描画モード

------------------------------------------------------------------------
□ grcg_and - GRCGの描画モード(AND)設定

C:      void grcg_and( int mode, int color );

        ------------------------------------------98N 98H AT DOS-
        grcg_and                                   Ｖ  × ＊
        ------------------------------------------<gc_andor.asm>-

                ● GRCGのモードレジスタに modeを設定し、 タイルレ
                   ジスタに  color に相当する単色を設定します。ま
                   た、modeのアクセスプレーンを color  により編集
                   し、論理積演算と同様の描画が出来るようにします。

                   　mode の値については grcg_setmode 参照。

                例: grcg_and( GC_RMW,5 );
                        全プレーンにアクセスする。
                        描画は、５の色で論理積を取る。

------------------------------------------------------------------------
□ grcg_off - GRCGのスイッチを切る

C:      void grcg_off(void);

        ------------------------------------------98N 98H AT DOS-
        grcg_off                                   Ｖ  × ＊
        ------------------------------------------<gc_setco.asm>-

                ● GRCGのモードレジスタに 0を設定して、スイッチを
                   切ります。GRCGを使用した後は、必ず実行してくだ
                   さい。

                ★ デフォルトでマクロになっていますが、#undef
                   grcg_off とすることにより、 関数呼び出しにでき
                   ます。

------------------------------------------------------------------------
□ grcg_or - GRCGの描画モード(OR)設定

C:      void grcg_or( int mode, int color );

        ------------------------------------------98N 98H AT DOS-
        grcg_or                                    Ｖ  × ＊
        ------------------------------------------<gc_andor.asm>-

                ● GRCGのモードレジスタに modeを設定し、 タイルレ
                   ジスタに  color に相当する単色を設定します。ま
                   た、modeのアクセスプレーンを color  により編集
                   し、論理和演算と同様の描画が出来るようにします。
                   　mode の値については grcg_setmode 参照。

                例: grcg_or( GC_RMW,5 );
                        全プレーンにアクセスする。
                        描画は、５の色で論理和を取る。

------------------------------------------------------------------------
□ grcg_setcolor - GRCGのモードおよび色設定

C:      void grcg_setcolor( int mode, int color );

        ------------------------------------------98N 98H AT DOS-
        grcg_setcolor                              Ｖ  × ＊
        ------------------------------------------<gc_setco.asm>-

                ● GRCGのモードレジスタに modeを設定し、 タイルレ
                   ジスタに color に相当する単色を設定します。
                   mode に設定する値は、 grcg_setmodeを参照してく
                   ださい。

                例: grcg_setcolor( GC_RMW|GC_BG,0 );
                        青と緑のプレーンにアクセスする。
                        タイルレジスタは全て 00h。

------------------------------------------------------------------------
□ grcg_setmode - GRCGのモード設定

C:      void grcg_setmode( int mode );                     マクロ

        ------------------------------------------98N 98H AT DOS-
        grcg_setmode                               Ｖ  × ×
        -----------------------------------------------------<->-

                ● GRCGのモードレジスタに modeを設定します。

                ← mode には、以下の定数が使えます。
                        GC_OFF  　GRCG のスイッチを切る。
                                grcg_off() と同じです。
                        GC_TDW  　書き込みが起こると、 タイルレジ
                                スタの内容を書き込む。 書き込もう
                                としたデータは無視される。
                                GC_TCR と同じモード。
                        GC_TCR  　読み込みが起こると、 タイルレジ
                                スタと一致する色を持つドットだけ1
                                を立てたビットパターンが読み込ま
                                れる。GC_TDW と同じモード。
                        GC_RMW  　書き込みが起こると、 ビットが立
                                ってるところはタイルレジスタの対
                                応するドットが書き込まれ、 立って
                                いない所は現在の内容が保存される。
                                読み込んではならない。

                   また、さらに以下の定数を複数 |  (論理和)で組み
                   合せて使うことが出来ます。    デフォルトは
                   GC_BRGI です。

                        GC_[B][R][G][I]　アクセスプレーンの制御
                                        []内は省略可能、ただし
                                        全て省略することはでき
                                        ない。

                例: grcg_setmode( GC_RMW|GC_BG );
                        青と緑のプレーンにアクセスする。

------------------------------------------------------------------------
□ grcg_settile_1line - GRCGのモードおよびタイルパターン(1line)設定

C:      void grcg_settile_1line( int mode, long tile );

        ------------------------------------------98N 98H AT DOS-
        grcg_settile_1line                         Ｖ  × ×
        ------------------------------------------<gc_tile1.asm>-

                ● GRCGのモードレジスタに modeを設定し、 タイルレ
                   ジスタに tile で指定したタイルパターンを設定し
                   ます。(横8ドット、縦1ラインのみ)

                   　mode に設定する値については、 grcg_setmode()
                   の項を参照してください。

                   　tile は、4バイトのデータを設定し、最下位バイ
                   トを青プレーン、再上位バイトを輝度プレーンとし
                   ます。(例1)
                   　B,R,G,I をプログラムで別々に扱いたいときは、
                   例2のようにすると簡単です。

                例1: 赤と青の交互パターンを設定する場合
                                               /* I G R B */
                    grcg_settile_1line( GC_RMW, 0x0000AA55L );

                例2: 各プレーンを別々に扱う
                     char tile[4] ;
                     tile[0] = 0x55 ;   /* B */
                     tile[1] = 0xaa ;   /* R */
                     tile[2] = 0x00 ;   /* G */
                     tile[3] = 0x00 ;   /* I */
                     grcg_settile_1line(GC_RMW,*(long *)tile);

------------------------------------------------------------------------
□ vgc_setcolor - 描画色の指定

C:      void vgc_setcolor(int mask,int color);

        ------------------------------------------98N 98H AT DOS-
        vgc_setcolor                               ×  × ○
        ------------------------------------------<vgcsetco.asm>-

                ● 描画するための色を GC に設定します。

                ← mask(mode)  描画演算指定と描画プレーン指定の論
                               理和
                               (GC_PSET | GC_BRGI) など。 GC_BRGI
                               は 0 なので、通常は VGA_PSETだけで
                               良い。
                   color       0〜15。描画色。

                ○ この指定は、 vgc_*以外の画面操作関数を実行する
                   と無効になります。
                ○ ビットマスクレジスタは0ffh、モードレジスタには
                   VGA_CHAR を設定します。
                ○ 直接ポートアクセスして描画する場合、論理演算指
                   定は VGA_MODE_REG に VGA_LATCH  を指定すると無
                   効になります。


------------------------------------------------------------------------
■ 図形描画 ■■■■■■■■■■■■■■■■■■■■■■■■■■■■■■

        　"図形描画・色設定"項で説明されている関数によって設定さ
        れた色や演算モードに従って、図形を描画します。

------------------------------------------------------------------------
□ grc_clip_line - 直線データのクリッピング

C:      int grc_clip_line( Point * p1, Point * p2 );

        ------------------------------------------98N 98H AT DOS-
        grc_clip_line
        ------------------------------------------<gc_clipl.asm>-

                ● p1,p2 を両端とする線分の、クリップ枠に入り切る
                   部分の両端を p1,p2に入れなおします。

                → 0  クリップ枠から完全に外れている
                   1  p1,p2  はクリップ枠に入り切る線分を表すよう
                      になった

                ○ grc_setclip範囲でクリッピングします。

------------------------------------------------------------------------
□ grc_clip_polygon_n - 凸/凹多角形データのクリッピング

C:      int grc_clip_polygon_n( Point * dest,  int  ndest,  const
                               Point * src, int nsrc );

        ------------------------------------------98N 98H AT DOS-
        grc_clip_polygon_n
        ------------------------------------------<gc_clipn.asm>-

                ● 多角形の頂点座標リストを渡すと、クリップ枠に入
                   り切る部分だけの新しい図形データを作成します。

                ← src[]  座標リスト
                   nsrc   点数
                   dest   格納先
                   ndest  格納先の最大要素数

                → -1    src は完全に枠内。src を利用せよ。
                    0    完全に枠外。描画できません。
                    1〜  dest[]に格納した点数を返します。

                ○ なお、dest と src は一致させることができます。
                   この場合、戻り値に -1 が返ることはありません。

                ○ grc_setclip範囲でクリッピングします。
                ○ この関数は描画は行いません。

                ★ ndest には、凸多角形の場合 nsrc+4 以上確保して
                   下さい。 凹多角形の場合は、nsrc*2 以上になりま
                   す。
                ★ dest[] は、必ず ndest 要素全てが書き換えられま
                   す。以前の値が残っていることは期待しないで下さ
                   い。

                例 :
                        grcg_polygon_cx の例を参照

------------------------------------------------------------------------
□ grcg_boxfill, vgc_boxfill - 長方形描画

C:      void grcg_boxfill(int x1,int y1,int x2,int y2);
C:      void vgc_boxfill(int x1,int y1,int x2,int y2);

        ------------------------------------------98N 98H AT DOS-
        grcg_boxfill                               Ｖ  × ＊
        ------------------------------------------<gc_boxfi.asm>-
        vgc_boxfill                                ×  × ○
        ------------------------------------------<vgcboxfi.asm>-

                ● 長方形を塗り潰します。

                ← x1,y1  第1頂点の座標
                   x2,y2  第2頂点の座標

                ○ grc_setclip範囲でクリッピングします。
                ○ 色は、grcg_setcolor または vgc_setcolor で指定
                   します。

------------------------------------------------------------------------
□ grcg_byteboxfill_x, vgc_byteboxfill_x - 横8ドット単位の長方形描画

C:      void grcg_byteboxfill_x( int x1,int y1,int x2,int y2);
C:      void vgc_byteboxfill_x( int x1,int y1,int x2,int y2);

        ------------------------------------------98N 98H AT DOS-
        grcg_byteboxfill_x                         Ｖ  × ＊
        ------------------------------------------<gc_byteb.asm>-
        vgc_byteboxfill_x                          ×  × ○
        ------------------------------------------<vgcbyteb.asm>-

                ● 長方形塗り潰しを行います。座標は、横方向が8dot
                   単位になります。

                ← x1,y1  第1頂点の座標
                   x2,y2  第2頂点の座標
                   ・横方向の座標はドットを 8  で割った値で指定し
                     ます。

                ○ 色は、grcg_setcolor または vgc_setcolor で指定
                   します。
                ○ y座標のみ、grc_setclip範囲でクリッピングします。

                ○ 速度追求のために存在します。

                ★ x1,x2 の値は  0〜(graph_VramWidth-1)でなければ
                   なりません。
                   x1 ≦ x2, y1 ≦ y2 でなければなりません。
                   横のクリッピングは行っていません。

------------------------------------------------------------------------
□ grcg_bytemesh_x, vgc_bytemesh_x - 横8ドット単位の市松模様塗り潰し

C:      void grcg_bytemesh_x( int x1,int y1,int x2,int y2);
C:      void vgc_bytemesh_x( int x1,int y1,int x2,int y2);

        ------------------------------------------98N 98H AT DOS-
        grcg_bytemesh_x                            Ｖ  × ＊
        ------------------------------------------<gc_bmesh.asm>-
        vgc_bytemesh_x                             ×  × ○
        ------------------------------------------<vgcbmesh.asm>-

                ● ドット単位の市松模様で長方形塗り潰しを行います。
                   座標は、横方向が8dot単位になります。

                ← x1,y1  第1頂点の座標
                   x2,y2  第2頂点の座標
                   ・横方向の座標はドットを 8  で割った値で指定し
                     ます。

                ○ 色は、grcg_setcolor または vgc_setcolor で指定
                   します。
                ○ yが偶数の所は、graph_MeshByte 変数の値で、 yが
                   奇数のところは  graph_MeshByteの反転のパターン
                   で書き込まれます。

                ★ x1,x2 の値は  0〜(graph_VramWidth-1)でなければ
                   なりません。
                   x1 ≦ x2, y1 ≦ y2 でなければなりません。
                   横のクリッピングは行っていません。

------------------------------------------------------------------------
□ grcg_circle, vgc_circle - 円描画

C:      void grcg_circle( int x, int y, int r );
C:      void vgc_circle( int x, int y, int r );

        ------------------------------------------98N 98H AT DOS-
        grcg_circle                                Ｖ  × ＊
        ------------------------------------------<gc_circl.asm>-
        vgc_circle                                 ×  × ○
        ------------------------------------------<vgccircl.asm>-

                ● 円の輪郭を描画します。

                ← x,y  中心点の座標
                   r    x方向の半径 ( 1以上 )

                ○ grc_setclip範囲でクリッピングします。
                ○ 色は、grcg_setcolor または vgc_setcolor で指定
                   します。
                ○ 完全にクリップ枠に入り切る場合は内部で
                   grcg_circle_x または vgc_circle_x を呼び出して
                   います。
                ○ 640x200(縦倍)時は、 縦を半分に縮小して見た目が
                   真円になるように描画します。

------------------------------------------------------------------------
□ grcg_circle_x, vgc_circle_x - 円描画(クリッピングなし)

C:      void grcg_circle_x( int x, int y, int r );
C:      void vgc_circle_x( int x, int y, int r );

        ------------------------------------------98N 98H AT DOS-
        grcg_circle_x                              Ｖ  × ＊
        ------------------------------------------<gc_circx.asm>-
        vgc_circle_x                               ×  × ○
        ------------------------------------------<vgccircx.asm>-

                ● 円の輪郭を描画します。

                ← x,y  中心点の座標
                   r    半径 ( 1以上 )

                ○ 色は、grcg_setcolor または vgc_setcolor で指定
                   します。
                ○ この関数を使う場合、grcg_circle または
                   vgc_circle  を全く呼ばければ実行形式のサイズが
                   小さくなります。
                ○ 640x200(縦倍)時は、 縦を半分に縮小して見た目が
                   真円になるように描画します。

                ★ クリッピングは行っていません。

------------------------------------------------------------------------
□ grcg_circlefill, vgc_circlefill - 円塗りつぶし

C:      void grcg_circlefill( int x, int y, int r );
C:      void vgc_circlefill( int x, int y, int r );

        ------------------------------------------98N 98H AT DOS-
        grcg_circlefill                            Ｖ  × ＊
        ------------------------------------------<gc_circf.asm>-
        vgc_circlefill                             ×  × ○
        ------------------------------------------<vgccircf.asm>-

                ● 円を塗り潰します。

                ← x,y  中心点の座標
                   r    半径

                ○ grc_setclip範囲でクリッピングします。
                ○ 色は、grcg_setcolor または vgc_setcolor で指定
                   します。
                ○ 真円になるためには、1dotが正方形であることが必
                   要です。

------------------------------------------------------------------------
□ grcg_fill - クリップ枠全面塗りつぶし

C:      void grcg_fill(void);

        ------------------------------------------98N 98H AT DOS-
        grcg_fill                                  Ｖ  × ＊
        -------------------------------------------<gc_fill.asm>-

                ● クリップ枠全体を塗りつぶします。

                ○ 非常に速度を要求する場面では、制限がいろいろあ
                   りますが、grcg_byteboxfill_x  を利用すると便利
                   です。

------------------------------------------------------------------------
□ grcg_hline, vgc_hline - 水平線描画

C:      void grcg_hline(int x1,int x2,int y);
C:      void vgc_hline(int x1,int x2,int y);

        ------------------------------------------98N 98H AT DOS-
        grcg_hline                                 Ｖ  × ＊
        ------------------------------------------<gc_hline.asm>-
        vgc_hline                                  ×  × ○
        ------------------------------------------<vgchline.asm>-

                ● 水平線を描画します。

                ← x1,x2  左右端のそれぞれのx座標
                   y      描画y座標

                ○ grc_setclip範囲でクリッピングします。
                ○ 色は、grcg_setcolor または vgc_setcolor で指定
                   します。

------------------------------------------------------------------------
□ grcg_line, vgc_line - 直線描画

C:      void grcg_line(int x1,int y1,int x2,int y2);
C:      void vgc_line(int x1,int y1,int x2,int y2);

        ------------------------------------------98N 98H AT DOS-
        grcg_line                                  Ｖ  × ＊
        -------------------------------------------<gc_line.asm>-
        vgc_line                                   ×  × ○
        -------------------------------------------<vgcline.asm>-

                ● 直線を描画します。

                ← x1,y1  第1頂点の座標
                   x2,y2  第2頂点の座標

                ○ grc_setclip範囲でクリッピングします。
                ○ 色は、grcg_setcolor または vgc_setcolor で指定
                   します。

------------------------------------------------------------------------
□ grcg_polygon_c, vgc_polygon_c - 凸多角形描画

C:      void grcg_polygon_c( const Point * pts, int npoint );
C:      void vgc_polygon_c( const Point * pts, int npoint );

        ------------------------------------------98N 98H AT DOS-
        grcg_polygon_c                             Ｖ  × ＊
        ------------------------------------------<gc_polgc.asm>-
        vgc_polygon_c                              ×  × ○
        ------------------------------------------<vgcpolgc.asm>-

                ● pts[]に座標リストを渡して凸多角形を描画します。

                ← npoint  点の数を指定。(3以上)

                ○ 色は、grcg_setcolor または vgc_setcolor で指定
                   します。
                ○ grc_setclip範囲でクリッピングします。
                ○ grcg_polygon_cx と grc_clip_polygon_n の組み合
                   せを利用した方が高速です。

                ★ 凸多角形にならないデータを渡されると、ゼロ除算
                   エラーが発生することがあります。

------------------------------------------------------------------------
□ grcg_polygon_cx, vgc_polygon_cx - 凸多角形描画(クリッピングなし)

C:      void grcg_polygon_cx( const Point * pts, int npoint );
C:      void vgc_polygon_cx( const Point * pts, int npoint );

        ------------------------------------------98N 98H AT DOS-
        grcg_polygon_cx                            Ｖ  × ＊
        ------------------------------------------<gc_polcx.asm>-
        vgc_polygon_cx                             ×  × ○
        ------------------------------------------<vgcpolcx.asm>-

                ● pts[]に座標リストを渡して凸多角形を描画します。

                ← npoint  点の数を指定。
                           0以下ならば描画しません。
                           1 ならば、点を描画します。
                           2 ならば、直線を描画します。

                ○ 色は、grcg_setcolor または vgc_setcolor で指定
                   します。
                ○ データレベルでのクリッピングについては、
                   grc_clip_polygon_n 参照
                ○ grc_setclip範囲でクリッピングします。
                ○ grcg_polygon_cよりも約 5%高速です。 描画する図
                   形がクリップ枠に必ず入り切る場合に利用してくだ
                   さい。  なお、  クリップ枠に入らないデータも、
                   grc_clip_polygon_n  によって必ず入り切るデータ
                   に変換するすることができます。この場合、次の例
                   のように描画の必要がない場面では描画の準備もス
                   キップすることができるので、より合理的になりま
                   す。

                例 :
                   Point p[MAX] ;
                   int np ;
                   (この間にp[0..np-1]に各頂点を設定する)
                   np = grc_clip_polygon_n(p,MAX,p,np);
                   if ( np > 0 ) {
                        /* 色設定 */
                        grcg_setcolor( GC_RMW, 5 );
                        /* 描画 */
                        grcg_polygon_cx( p, np );
                        /* 後処理 */
                        grcg_off();
                   }

                ★ クリッピングは行っていません。
                ★ 凸多角形にならないデータを渡されると、ゼロ除算
                   エラーが発生することがあります。

------------------------------------------------------------------------
□ grcg_polygon_vcx, vgc_polygon_vcx -  凸多角形描画(クリッピングなし,可
   変引数)

C:      void grcg_polygon_vcx( int npoint, int x1, int y1, ... );
C:      void vgc_polygon_vcx( int npoint, int x1, int y1, ... );

        ------------------------------------------98N 98H AT DOS-
        grcg_polygon_vcx                           Ｖ  × ＊
        ------------------------------------------<gc_plvcx.asm>-
        vgc_polygon_vcx                            ×  × ○
        ------------------------------------------<vgcplvcx.asm>-

                ● 座標リストを直接引数にならべて渡して凸多角形を
                   描画します。npointに点の数を指定します。
                     npoint ≦ 0 ならば描画しません。
                     npoint = 1 ならば、点を描画します。
                     npoint = 2 ならば、直線を描画します。
                ★ 凸多角形にならないデータを渡されると、ゼロ除算
                   エラーが発生することがあります。

                ○ grcg_polygon_cx と処理内容は同一です。

------------------------------------------------------------------------
□ grcg_pset, vgc_pset - 点描画

C:      void grcg_pset(int x,int y);
C:      void vgc_pset(int x,int y);

        ------------------------------------------98N 98H AT DOS-
        grcg_pset                                  Ｖ  × ＊
        -------------------------------------------<gc_pset.asm>-
        vgc_pset                                   ×  × ○
        -------------------------------------------<vgcpset.asm>-

                ● 点を描画します。

                ← x,y  描画座標

                ○ grc_setclip範囲でクリッピングします。
                ○ 色は、grcg_setcolor または vgc_setcolor で指定
                   します。

------------------------------------------------------------------------
□ grcg_round_boxfill, vgc_round_boxfill - 角の丸い長方形描画

C:      void grcg_round_boxfill( int x1, int y1, int x2, int  y2,
                                unsigned r );
C:      void vgc_round_boxfill( int x1, int y1, int x2,  int  y2,
                               unsigned r );

        ------------------------------------------98N 98H AT DOS-
        grcg_round_boxfill                         Ｖ  × ＊
        ------------------------------------------<gc_rboxf.asm>-
        vgc_round_boxfill                          ×  × ○
        ------------------------------------------<vgcrboxf.asm>-

                ● 四隅を丸くした長方形塗り潰しを行います。

                ← x1,y1  第1頂点の座標
                   x2,y2  第2頂点の座標
                   r      四隅の円の半径

                ○ grc_setclip範囲でクリッピングします。
                ○ 色は、grcg_setcolor または vgc_setcolor で指定
                   します。

------------------------------------------------------------------------
□ grcg_thick_line, vgc_thick_line - 四角いペンによる直線描画

C:      void grcg_thick_line( int x1, int y1,  int  x2,  int  y2,
                             unsigned wid, unsigned hei );
C:      void vgc_thick_line( int x1, int  y1,  int  x2,  int  y2,
                            unsigned wid, unsigned hei );

        ------------------------------------------98N 98H AT DOS-
        grcg_thick_line                            Ｖ  × ＊
        ------------------------------------------<gc_thicl.asm>-
        vgc_thick_line                             ×  × ○
        ------------------------------------------<vgcthicl.asm>-

                ● (x1,y1)から(x1+wid,y1+hei)の長方形と、 (y2,y2)
                   から(y2+wid,y2+hei)の長方形を両端とする太い直
                   線を描画します。

                ← x1,y1  第1頂点の座標
                   x2,y2  第2頂点の座標
                   wid    線を構成する横の太さ
                   hei    線を構成する縦の太さ

                ○ grc_setclip範囲でクリッピングします。
                ○ 色は、grcg_setcolor または vgc_setcolor で指定
                   します。

                ○ 内部で grcg_polygon_c, grcg_boxfill, grcg_line
                   を呼び出しています。

------------------------------------------------------------------------
□ grcg_trapezoid, vgc_trapezoid - 台形塗り潰し

C:      void grcg_trapezoid( int y1, int x11, int  x12,  int  y2,
                            int x21, int x22 );
C:      void vgc_trapezoid( int y1, int x11, int x12, int y2, int
                           x21, int x22 );

        ------------------------------------------98N 98H AT DOS-
        grcg_trapezoid                             Ｖ  × ＊
        -------------------------------------------<gc_zoid.asm>-
        vgc_trapezoid                              ×  × ○
        ------------------------------------------<vgc_zoid.asm>-

                ● (x11,y1),(x12,y1),(x21,y2),(x22,y2) の４点を
                   この順に結ぶ四辺形を塗りつぶして描画します。
                   (下図参照)

                           (x11,y1)  (x12,y1)
                                +-------+
                               ･         ･
                              ･           ･
                             ･             ･
                            +---------------+
                        (x21,y2)        (x22,y2)

                   　上の辺と下の辺の向きが逆の場合は、下図の様に
                   交差した図形を描画します。

                             (x11,y1)    (x12,y1)
                                +-----------+
                                  ･       ･
                                    ･   ･
                                      ･
                                    ･   ･
                                  +-------+
                              (x22,y2)  (x21,y2)

                ← y1       上底のy座標
                   x11,x12  上底の2つのx座標
                   y2       下底のy座標
                   x21,x22  下底の2つのx座標

                ○ grc_setclip範囲でクリッピングします。
                ○ 色は、grcg_setcolor または vgc_setcolor で指定
                   します。

------------------------------------------------------------------------
□ grcg_triangle, vgc_triangle - 三角形塗り潰し

C:      void grcg_triangle( int x1,int y1,  int  x2,int  y2,  int
                           x3,int y3 );
C:      void vgc_triangle( int x1,int  y1,  int  x2,int  y2,  int
                          x3,int y3 );

        ------------------------------------------98N 98H AT DOS-
        grcg_triangle                              Ｖ  × ＊
        ------------------------------------------<gc_trian.asm>-
        vgc_triangle                               ×  × ○
        ------------------------------------------<vgctrian.asm>-

                ● 三角形塗り潰しを行います。

                ← x1,y1  第1頂点の座標
                   x2,y2  第2頂点の座標
                   x3,y3  第3頂点の座標

                ○ 色は、grcg_setcolor または vgc_setcolor で指定
                   します。
                ○ grc_setclip範囲でクリッピングします。
                ○ クリッピングの速度が多少遅いので、呼び出し回数
                   に比べて実際にクリップ枠内に現れる比率が低いと
                   きには、 凸多角形(grcg_polygon_cx)を使用してく
                   ださい。

------------------------------------------------------------------------
□ grcg_triangle_x - 三角形描画(クリッピングなし)

C:      void grcg_triangle_x( Point * pts );

        ------------------------------------------98N 98H AT DOS-
        grcg_triangle_x                            Ｖ  × ＊
        ------------------------------------------<gc_trian.asm>-

                ● 三角形を描画します。引数の pts は必ず  3点でな
                   ければなりません。 grc_clip_polygon_n の結果が
                   3 になったときに呼び出すと高速に三角形を描画す
                   ることができます。

------------------------------------------------------------------------
□ grcg_vline, vgc_vline - 垂直線描画

C:      void grcg_vline(int x,int y1,int y2);
C:      void vgc_vline(int x,int y1,int y2);

        ------------------------------------------98N 98H AT DOS-
        grcg_vline                                 Ｖ  × ＊
        ------------------------------------------<gc_vline.asm>-
        vgc_vline                                  ×  × ○
        ------------------------------------------<vgcvline.asm>-

                ● 垂直線を描画します。

                ← x      描画 x座標
                   y1,y2  上下端のそれぞれのy座標

                ○ grc_setclip範囲でクリッピングします。
                ○ 色は、grcg_setcolor または vgc_setcolor で指定
                   します。

------------------------------------------------------------------------
□ vgc_byteboxfill_x_pset - 長方形塗り潰し(8dot単位,演算なし)

C:      void vgc_byteboxfill_x_pset(int x1,int y1,int x2,int y2);

        ------------------------------------------98N 98H AT DOS-
        vgc_byteboxfill_x_pset                     ×  × ○
        ------------------------------------------<vgcbytbp.asm>-

                ● 長方形塗り潰しを行います。座標は、横方向が8dot
                   単位になります。 演算を省いたため、 処理速度が
                   vgc_byteboxfill_x よりも高速です。

                ← x1,y1  第1頂点の座標
                   x2,y2  第2頂点の座標
                   ・横方向の座標はドットを 8  で割った値で指定し
                     ます。

                ○ 色は、vgc_setcolor で指定します。ただし、 演算
                   モードはVGA_PSET固定です。

                ★ x1,x2 の値は  0〜(graph_VramWidth-1)でなければ
                   なりません。
                   x1 ≦ x2, y1 ≦ y2 でなければなりません。
                   横のクリッピングは行っていません。


------------------------------------------------------------------------
□ vgc_line2 - 直線描画(ラインスタイルつき)

C:      void vgc_line2(  int  x1,int  y1,int  x2,int  y2,unsigned
                       lstyle);

        ------------------------------------------98N 98H AT DOS-
        vgc_line2                                  ×  × ○
        ------------------------------------------<vgcline2.asm>-

                ● ラインスタイルを指定して直線を描画します。

                ← x1,y1   第1頂点の座標
                   x2,y2   第2頂点の座標
                   lstyle  ラインスタイル。16dot周期で、値が1のビ
                           ットの部分に描画します。

                ○ grc_setclip範囲でクリッピングします。
                ○ 色は、vgc_setcolor で指定します。


------------------------------------------------------------------------
■ PC-9801 GDCによる描画 ■■■■■■■■■■■■■■■■■■■■■■■

        PC-9801シリーズには、 GDCという描画ハードウェアが装備され
        ています。ただし古いので、できることは限られていますが。

------------------------------------------------------------------------
□ 構造体／グローバル変数

int GDCUsed ;           <98> GDC の描画を行ったので VRAM アクセス
                        には注意を要する状態になっている場合を表
                        す場合に、 0  以外になります。  gdc_line,
                        gdc_circle  によって設定され、gdc_wait に
                        よって参照、設定されます。 gdc_line,
                        gdc_circle  以外の手段によって GDC 描画を
                        行った場合、 自分でこの変数に値を設定して
                        ください。

------------------------------------------------------------------------
□ gdc_circle - GDC による円描画

C:      void gdc_circle( int x, int y, unsigned r );

        ------------------------------------------98N 98H AT DOS-
        gdc_circle                                 ○  × ＊
        ------------------------------------------<gdccircl.asm>-

                ● GDC を利用して、円の描画を開始します。

                ○ GDC の特性として、CPU の動作と平行して描画を行
                   うので、この手続きを実行した後も GDC  の描画は
                   続いています。GDC 以外の手段で VRAM をアクセス
                   する場合は、必ず gdc_wait を実行して描画完了を
                   確認してください。
                ○ 半径が 0 のときは描画しません。
                ○ GDCの周波数は、2.5MHz/5MHzを自動判別します。
                ○ grc_setclipの範囲でクリッピングします。
                ○ 真円になるためには、1dotが正方形であることが必
                   要です。

------------------------------------------------------------------------
□ gdc_line - GDC による直線描画

C:      void gdc_line( int x1,int y1,int x2,int y2 );

        ------------------------------------------98N 98H AT DOS-
        gdc_line                                   ○  × ＊
        -------------------------------------------<gdcline.asm>-

                ● GDC を利用して、直線の描画を開始します。

                ○ GDC の特性として、CPU の動作と平行して描画を行
                   うので、この手続きを実行した後も GDC  の描画は
                   続いています。GDC 以外の手段で VRAM をアクセス
                   する場合は、必ず gdc_wait を実行して描画完了を
                   確認してください。
                ○ GDCの周波数は、2.5MHz/5MHzを自動判別します。
                ○ grc_setclipの範囲でクリッピングします。

------------------------------------------------------------------------
□ gdc_setaccessplane - VRAM アクセスプレーンの設定

C:      void gdc_setaccessplane(int plane);                マクロ

        ------------------------------------------98N 98H AT DOS-
        gdc_setaccessplane                         ○  × ＊
        -----------------------------------------------------<->-

                ● GDC 描画時の、アクセスを許可する VRAM プレーン
                   を設定します。 plane に設定する値は、
                   grcg_setmode に与えるプレーン情報が使えます。

                例: 赤と青のプレーンに描画する場合
                    gdc_setaccessplane( GC_BR );

------------------------------------------------------------------------
□ gdc_setcolor - 描画色と演算の設定

C:      void gdc_setcolor(int color);                      マクロ

        ------------------------------------------98N 98H AT DOS-
        gdc_setcolor                               ○  × ＊
        -----------------------------------------------------<->-

                ● GDC による描画色と演算モードを設定します。
                   色(0〜15)と、 以下の演算モード定数の論理和の結
                   果を color に設定します。
                      GDC_PSET
                      GDC_XOR
                      GDC_OR
                      GDC_AND

                例: 7番の色で XOR 描画する場合
                      gdc_setcolor( GDC_XOR | 7 );

------------------------------------------------------------------------
□ gdc_setlinestyle - ラインスタイルの設定

C:      void gdc_setlinestyle(unsigned style);             マクロ

        ------------------------------------------98N 98H AT DOS-
        gdc_setlinestyle                           ○  × ＊
        -----------------------------------------------------<->-

                ● GDC 描画のためのラインスタイルを設定します。

------------------------------------------------------------------------
□ gdc_wait - GDC 描画完了待ち

C:      void gdc_wait(void);

        ------------------------------------------98N 98H AT DOS-
        gdc_wait                                   ○  × ＊
        -------------------------------------------<gdcwait.asm>-

                ● GDC 描画開始後、完全に描画が完了するまで待ちま
                   す。GDC による描画を行った場合、  次に他の手段
                   で VRAM をアクセスする前に必ず実行してください。

                ○ GDC 描画の後、完了を待たずに他の手段で VRAM を
                   アクセスすると、画面にゴミが残ってしまう場合が
                   あります。
                ○ GDCUsed 変数が 0  以外に設定されている場合にの
                   み、完了を待つ動作を行います。
                   　これにより、不要な完了待ちの時間が省けます。
                   詳しくは GDCUsed 変数の項を参照してください。


------------------------------------------------------------------------
■ PC-9801 EGC操作 ■■■■■■■■■■■■■■■■■■■■■■■■■■

        　PC-9801VX 以降の機種に搭載されているハードウェア
        EGC(Enhanced Graphic Charger) は、 その以前の機種に搭載さ
        れている GRCG 以上に強力な機能を持っています。
        　EPSON PC-286系、PC-386系は  EGCが搭載されていない機種が
        結構ありますので、注意してください。

        　egc_set*や egc_select*系関数で使われる  EGCのレジスタな
        どの意味は、別途資料を入手してください。

------------------------------------------------------------------------
□ egc_end - EGCの終了処理

C:      void egc_end(void);

        ------------------------------------------98N 98H AT DOS-
        egc_end                                    Ｖ  × ×
        -----------------------------------------------<egc.asm>-

                ● egc_start と同じです。

------------------------------------------------------------------------
□ egc_off - EGCをGRCG互換モードに設定する

C:      void egc_off(void);

        ------------------------------------------98N 98H AT DOS-
        egc_off                                    Ｖ  × ×
        -----------------------------------------------<egc.asm>-

                ● EGCを GRCG互換モードに設定し、スイッチを切りま
                   す。

                ★  EGC非搭載機で実行するとハングアップする場合が
                    あります。

------------------------------------------------------------------------
□ egc_on - EGCを拡張モードに設定する

C:      void egc_on(void);

        ------------------------------------------98N 98H AT DOS-
        egc_on                                     Ｖ  × ×
        -----------------------------------------------<egc.asm>-

                ● EGCは、起動時は GRCG  互換モードになっているた
                   め GRCG 用のプログラムがそのまま使えます。しか
                   し、 EGC本来の性能を発揮するには拡張モードにし
                   なければなりません。この関数(手続き)では、拡張
                   モードに設定することで以後 GRCG より多くの機能
                   を用いて grcg_* 描画関数を使うことが出来ます。

                ★ EGC非搭載機で実行するとハングアップする場合が
                   あります。
                ★ EGCのスイッチが入っている時には GRCG  操作関数
                   は使用しないで下さい。使用すると誤動作します。

------------------------------------------------------------------------
□ egc_scroll_left - EGCによる円筒左スクロール

C:      void egc_scroll_left(int dots);

        ------------------------------------------98N 98H AT DOS-
        egc_scroll_left                            Ｖ  × ×
        -------------------------------------------<egcscrl.asm>-

                ● グラフィック画面全体を、dot ドットだけ左にスク
                   ロールします。画面の左端からはみ出した部分は右
                   端に回って表示される。

                ★ 引数 dot は、1 ≦ dot ≦ 15 でなければなりませ
                   ん。この範囲外の引数を与えた場合の動作は不定で
                   す。
                ★ 16 ドット以上のスクロールは、 graph_scroll()な
                   どと併用する必要がある。

------------------------------------------------------------------------
□ egc_scroll_right - EGCによる円筒右スクロール

C:      void egc_scroll_right(int dots);

        ------------------------------------------98N 98H AT DOS-
        egc_scroll_right                           Ｖ  × ×
        -------------------------------------------<egcscrr.asm>-

                ● グラフィック画面全体を、dot ドットだけ右にスク
                   ロールします。画面の右端からはみ出した部分は左
                   端に回って表示される。

                ★ 引数 dot は、1 ≦ dot ≦ 15 でなければなりませ
                   ん。この範囲外の引数を与えた場合の動作は不定で
                   す。
                ★ 16 ドット以上のスクロールは、 graph_scroll()な
                   どと併用する必要がある。

------------------------------------------------------------------------
□ egc_selectfg - P入力にFG色を選択

C:      void egc_selectfg(void);                           マクロ

        ------------------------------------------98N 98H AT DOS-
        egc_selectfg                               Ｖ  × ×
        -----------------------------------------------------<->-

                ● 描画色にフォアグラウンド色を利用するようにしま
                   す。

------------------------------------------------------------------------
□ egc_selectbg - P入力にBG色を選択

C:      void egc_selectbg(void);                           マクロ

        ------------------------------------------98N 98H AT DOS-
        egc_selectbg                               Ｖ  × ×
        -----------------------------------------------------<->-

                ● 描画色にバックグラウンド色を利用するようにしま
                   す。

------------------------------------------------------------------------
□ egc_selectpat - P入力にパターンレジスタを選択

C:      void egc_selectpat(void);                          マクロ

        ------------------------------------------98N 98H AT DOS-
        egc_selectpat                              Ｖ  × ×
        -----------------------------------------------------<->-

                ● 描画色にパターンレジスタを利用するようにします。
                   (デフォルト)

------------------------------------------------------------------------
□ egc_setbgcolor - BG色の設定

C:      void egc_setbgcolor(int color);                    マクロ

        ------------------------------------------98N 98H AT DOS-
        egc_setbgcolor                             Ｖ  × ×
        -----------------------------------------------------<->-

                ● バックグラウンド色を設定します。

------------------------------------------------------------------------
□ egc_setfgcolor - FG色の設定

C:      void egc_setfgcolor(int color);                    マクロ

        ------------------------------------------98N 98H AT DOS-
        egc_setfgcolor                             Ｖ  × ×
        -----------------------------------------------------<->-

                ● フォアグラウンド色を設定します。

------------------------------------------------------------------------
□ egc_setrop - EGCのモードとROPを設定する

C:      void egc_setrop(int mode_rop);                     マクロ

        ------------------------------------------98N 98H AT DOS-
        egc_setrop                                 Ｖ  × ×
        -----------------------------------------------------<->-

                ● モードとラスタオペレーションを設定します。

------------------------------------------------------------------------
□ egc_shift_down - EGCによる部分下スクロール

C:      void egc_shift_down( int x1, int y1, int x2, int y2,  int
                            dots);

        ------------------------------------------98N 98H AT DOS-
        egc_shift_down                             Ｖ  × ×
        -------------------------------------------<egcsftd.asm>-

                ● グラフィック画面の(x1, y1) - (x2,  y2)の範囲を
                   dot  ドットだけ下にシフトします。 シフトされる
                   範囲の上端 dot  ドット分の領域は関数を呼ぶ前の
                   まま変わりません。

                ★ 引数 x1、x2 は 0 ≦ x1 ≦ 639 で、x1 < x2 の範
                   囲内でなければなりません。
                ★ 引数 y1、y2 は 0 ≦ y1 ≦ 399、0 ≦ y2 ≦ (399
                   - dot) で y1 < y2 でなければなりません。
                ★ 引数 dot は、dot ≧ 1 でなければなりません。こ
                   の範囲外の引数を与えた場合の動作は不定です。

------------------------------------------------------------------------
□ egc_shift_down_all - EGCによる下スクロール

C:      void egc_shift_down_all(int dots);

        ------------------------------------------98N 98H AT DOS-
        egc_shift_down_all                         Ｖ  × ×
        ------------------------------------------<egcsftda.asm>-

                ● グラフィック画面全体を、dot ドットだけ下にシフ
                   トします。画面の上端 dot ドット分の領域は、 関
                   数を呼ぶ前のまま変わりません。

                ★ 引数 dot は、dot ≧ 1 でなければなりません。こ
                   の範囲外の引数を与えた場合の動作は不定です。

------------------------------------------------------------------------
□ egc_shift_left - EGCによる部分左スクロール

C:      void egc_shift_left( int x1, int y1, int x2, int y2, int dots);

        ------------------------------------------98N 98H AT DOS-
        egc_shift_left                             Ｖ  × ×
        -------------------------------------------<egcsftl.asm>-

                ● グラフィック画面の(x1, y1) - (x2,  y2)の範囲を
                   dot  ドットだけ左にシフトします。 シフトされる
                   範囲の右端 dot  ドット分の領域は関数を呼ぶ前の
                   まま変わりません。

                ★ 引数 x1、x2 は dot ≦ x1 ≦ 639、0  ≦  x2  ≦
                   639 で x1 < x2 の範囲内でなければなりません。
                ★ 引数 y1、y2 は 0 ≦ y1 ≦ 399、0 ≦ y2 ≦  399
                   で y1 < y2 の範囲内でなければなりません。
                ★ 引数 dot は、dot ≧ 1 でなければなりません。こ
                   の範囲外の引数を与えた場合の動作は不定です。

------------------------------------------------------------------------
□ egc_shift_left_all - EGCによる左スクロール

C:      void egc_shift_left_all(int dots);

        ------------------------------------------98N 98H AT DOS-
        egc_shift_left_all                         Ｖ  × ×
        ------------------------------------------<egcsftla.asm>-

                ● グラフィック画面全体を、dot ドットだけ左にシフ
                   トします。画面の右端 dot ドット分の領域は、 関
                   数を呼ぶ前のまま変わりません。

                ★ 引数 dot は、dot ≧ 1 でなければなりません。こ
                   の範囲外の引数を与えた場合の動作は不定です。

------------------------------------------------------------------------
□ egc_shift_right - EGCによる部分右スクロール

C:      void egc_shift_right( int x1, int y1, int x2, int y2, int dots);

        ------------------------------------------98N 98H AT DOS-
        egc_shift_right                            Ｖ  × ×
        -------------------------------------------<egcsftr.asm>-

                ● グラフィック画面の(x1, y1) - (x2,  y2)の範囲を
                   dot  ドットだけ右にシフトします。 シフトされる
                   範囲の左端 dot  ドット分の領域は関数を呼ぶ前の
                   まま変わりません。

                ★ 引数 x1、x2 は 0 ≦ x1 ≦ 639、0 ≦ x2 ≦ (639
                   - dot) でx1 < x2 の範囲内でなければなりません。
                ★ 引数 y1、y2 は 0 ≦ y1 ≦ 399、0 ≦ y2 ≦  399
                   で y1 < y2 の範囲内でなければなりません。
                ★ 引数 dot は、dot ≧ 1 でなければなりません。こ
                   の範囲外の引数を与えた場合の動作は不定です。

------------------------------------------------------------------------
□ egc_shift_right_all - EGCによる右スクロール

C:      void egc_shift_right_all(int dots);

        ------------------------------------------98N 98H AT DOS-
        egc_shift_right_all                        Ｖ  × ×
        ------------------------------------------<egcsftra.asm>-

                ● グラフィック画面全体を、dot ドットだけ右にシフ
                   トします。画面の左端 dot ドット分の領域は、 関
                   数を呼ぶ前のまま変わりません。

                ★ 引数 dot は、dot ≧ 1 でなければなりません。こ
                   の範囲外の引数を与えた場合の動作は不定です。

------------------------------------------------------------------------
□ egc_shift_up - EGCによる部分上スクロール

C:      void egc_shift_up( int x1, int y1, int x2, int y2, int dots);

        ------------------------------------------98N 98H AT DOS-
        egc_shift_up                               Ｖ  × ×
        -------------------------------------------<egcsftu.asm>-

                ● グラフィック画面の(x1, y1) - (x2,  y2)の範囲を
                   dot  ドットだけ上にシフトします。 シフトされる
                   範囲の下端 dot  ドット分の領域は関数を呼ぶ前の
                   まま変わりません。

                ★ 引数 x1、x2 は 0 ≦ x1 ≦ 639 で、x1 < x2 の範
                   囲内でなければなりません。
                ★ 引数 y1、y2 は dot ≦ y1 ≦ 399、0  ≦  y2  ≦
                   399 で y1 < y2の範囲内でなければなりません。
                ★ 引数 dot は、dot ≧ 1 でなければなりません。こ
                   の範囲外の引数を与えた場合の動作は不定です。

------------------------------------------------------------------------
□ egc_shift_up_all - EGCによる上スクロール

C:      void egc_shift_up_all(int dots);

        ------------------------------------------98N 98H AT DOS-
        egc_shift_up_all                           Ｖ  × ×
        ------------------------------------------<egcsftua.asm>-

                ● グラフィック画面全体を、dot ドットだけ上にシフ
                   トします。画面の下端 dot ドット分の領域は、 関
                   数を呼ぶ前のまま変わりません。

                ★ 引数 dot は、dot ≧ 1 でなければなりません。こ
                   の範囲外の引数を与えた場合の動作は不定です。

------------------------------------------------------------------------
□ egc_start - EGCの初期設定

C:      void egc_start(void);

        ------------------------------------------98N 98H AT DOS-
        egc_start                                  Ｖ  × ×
        -----------------------------------------------<egc.asm>-

                ● EGCの各種レジスタを初期設定し、EGCのスイッチを
                   切ります。 EGCはレジスタの値を読み取ることがで
                   きないので、安定動作のためには利用する前に
                   egc_start によって全てのレジスタを通常設定にし
                   て下さい。 また、終了前には egc_end を呼び出し
                   て下さい。

                ○ EGC搭載機ではプログラム起動時にこれを行うべき
                   です。 (一部のアプリケーションに拡張モードにし
                   たまま終了してしまうものがあるため)
                ○ egc_start()とegc_end()は一つのルーチンの別名で
                   す。

                ★ EGC非搭載機で実行するとハングアップする場合が
                   あります。必ず EGCの存在確認をしてから実行して
                   ください。

                利用法の骨格 :
                        if ( has_egc() ) {
                            egc_start();/* 起動時 */
                            egc_on();
                            egc レジスタ設定
                            grcg_描画 ;
                            egc_off();
                            egc_end(); /* 終了時 */
                        }

------------------------------------------------------------------------
□ has_egc - EGCが利用できるかどうかの判定

C:      int has_egc(void);                                 マクロ

        ------------------------------------------98N 98H AT DOS-
        has_egc                                    Ｖ  × ×
        -----------------------------------------------------<->-

                ● EGCが利用できる環境であれば、0以外を返します。


------------------------------------------------------------------------
■ 割り込み ■■■■■■■■■■■■■■■■■■■■■■■■■■■■■■


------------------------------------------------------------------------
■ VSYNC割り込み ■■■■■■■■■■■■■■■■■■■■■■■■■■■

        　VSYNC割り込みは、CRTの垂直帰線、 すなわち画面全体の表示
        一周ごとに発生する割り込みです。
        　PC-9801 シリーズのノーマルモードで通常の640x400ドット用
        CRTを接続している場合は1秒間に約57回の頻度で発生します。
        　VGAの場合、標準VGAのビデオモードの場合は、1秒間に約60回
        の頻度で発生しますが、 VGA自体にVSYNC割り込みが付いている
        と仮定できないため、 擬似的にタイマ割り込みを使って実現し
        ています。

        　この簡易版処理は、この割り込みを利用して、 二つのカウン
        タ変数を増加します。　アプリケーションは、この値を0にして
        から経過した時間を、 直接変数を参照することにより知ること
        ができます。

------------------------------------------------------------------------
□ 構造体／グローバル変数

unsigned vsync_Count1;  どちらも、VSYNC割り込み毎に 1 ずつ
unsigned vsync_Count2;  増加する変数です。
                        65535の次は 0 になってしまいますので、 長
                        時間の計測には向きません。
                        使うときは、まず 0 に設定してください。

void (far * vsync_Proc)(void);
                        VSYNC割り込みルーチンから呼ばれるサブルー
                        チンのアドレス。
                        vsync_proc_set()によって設定されます。

unsigned vsync_Delay;   VSYNC割り込みを遅らせる値。 VSYNC割り込み
                        が一回発生するごとにこの値を内部の見えな
                        いカウンタに加算してゆき、65535を越えるご
                        とに一回、VSYNC割り込みがかからなかったこ
                        とにします。これにより、VSYNC割り込みの頻
                        度を微妙に少なくすることができます。 初期
                        値は0。

void (far interrupt * vsync_OldVect)(void);
                        vsync_start()実行前のVSYNC割り込みのベク
                        タ内容。
                        vsync_end()で使用されます。

unsigned vsync_Freq     <AT>擬似vsync割り込みの周期

------------------------------------------------------------------------
□ vsync_end, vga_vsync_end - VSYNC割り込みの使用終了

C:      void vsync_end(void);
C:      void vga_vsync_end(void);

        ------------------------------------------98N 98H AT DOS-
        vsync_end                                  ○     ＊
        ---------------------------------------------<vsync.asm>-
        vga_vsync_end                              ×  × ○
        ------------------------------------------<vgavsync.asm>-

                ● VSYNC 割り込みが設定されていれば、それを解除し
                   ます。設定されていなければ何もしません。

                ★ 一度vsync_startを実行したら、 プログラムを終了
                   するまでにこれを実行する必要があります。
                   　これを守らなかった場合、あとで暴走することに
                   なります。

------------------------------------------------------------------------
□ vsync_enter - VSYNC割り込みのチェイン設定

C:      void vsync_enter(void);

        ------------------------------------------98N 98H AT DOS-
        vsync_enter                                ○     ×
        ------------------------------------------<vsyncent.asm>-

                ● すでに他のプログラム(主に常駐ソフト)によって使
                   用されている VSYNC 割り込みを活かしたまま、 さ
                   らに VSYNC 割り込み処理を追加設定します。
                   　また、カウンタ変数を0に設定します。

                   カウンタ変数:
                     vsync_Count1, vsync_Count2

                ○ すでに vsync_start  が実行されている場合にも使
                   えますが、 解除のために  vsync_leave  を使うと
                   master.lib は VSYNC 割り込みを起動前の状態に復
                   元してしまうので、VSYNC 割り込み機能を続けて使
                   いたい場合はもう一度   vsync_start/vsync_enter
                   を実行する必要があります。

                ★ 一度設定したら、プログラムを終了するまでに
                   vsync_leave を実行する必要があります。
                   　実行せずに終了した場合、あとで暴走することに
                   なります。

------------------------------------------------------------------------
□ vsync_leave - VSYNC割り込みのチェイン解放

C:      void vsync_leave(void);

        ------------------------------------------98N 98H AT DOS-
        vsync_leave                                ○     ×
        ---------------------------------------------<vsync.asm>-

                ● VSYNC 割り込みが設定されていれば、それを解除し
                   ます。設定されていなければ何もしません。

                ★ 一度 vsync_enter を実行したら、 プログラムを終
                   了するまでにこれを実行する必要があります。
                   　これを守らなかった場合、あとで暴走することに
                   なります。

------------------------------------------------------------------------
□ vsync_proc_reset - VSYNC毎に実行する関数の指定解除

C:      void vsync_proc_reset(void);                       マクロ

        ------------------------------------------98N 98H AT DOS-
        vsync_proc_reset
        -----------------------------------------------------<->-

                ● vsync_proc_set()の指定を解除します。

------------------------------------------------------------------------
□ vsync_proc_set - VSYNC毎に実行する関数の指定

C:      void vsync_proc_set( (void (far *func)(void)) );   マクロ

        ------------------------------------------98N 98H AT DOS-
        vsync_proc_set
        -----------------------------------------------------<->-

                ● この指定を行うと、vsync_start後であればvsync割
                   り込み発生ごとに、vsync_Count1などの処理の後に
                   funcを呼び出します。

                ← func  引数なし、 戻り値なしのfar関数へのポイン
                         タ。

------------------------------------------------------------------------
□ vsync_start, vga_vsync_start -  VSYNC割り込みの設定およびカウンタリセ
   ット

C:      void vsync_start(void);
C:      void vga_vsync_start(void);

        ------------------------------------------98N 98H AT DOS-
        vsync_start                                ○     ＊
        ---------------------------------------------<vsync.asm>-
        vga_vsync_start                            ×  × ○
        ------------------------------------------<vgavsync.asm>-

                ● VSYNC 割り込みがまだ設定されていなければ、設定
                   します。
                   　設定されていてもいなくてもカウンタ変数を0に
                   設定します。
                   <AT>インターバル割り込みの周期を細工して、
                   VSYNC 割り込みを擬似的に実現します。また、従来
                   のベクタアドレスへも、 1秒あたり18.2回になるよ
                   うに呼び出します。

                   カウンタ変数:
                     vsync_Count1, vsync_Count2

                ○ この関数を実行すると、以下の変数が動作するよう
                   になります。
                    vsync_Count1   vsyncごとに1増加
                    vsync_Count2   vsyncごとに1増加
                    vsync_Proc     NULLでなければ vsyncごとに呼び
                                   出される

                ★ 一度設定したら、プログラムを終了するまでに
                   vsync_end または vga_vsync_end  を実行する必要
                   があります。
                   　実行せずに終了した場合、あとで暴走することに
                   なります。

                ★<vsync_start> vsync_Delayは、VGAや98の31kHzモー
                  ドでもvsync割り込みが56.42Hz(98ノーマルモードと
                  同じ)になるように、適切な値が設定されます。ただ
                  し 98での  30行BIOSなどの拡張モードは正常に追跡
                  しません。 また、この設定をキャンセルして、実際
                  のvsyncの速度に一致させたい場合は、vsync_start()
                  実行後に vsync_Delay変数を0にしてください。
                ○ <98>VSYNC割り込み(INT 0ah)を使用しています。
                ○ <AT>タイマ割り込み(INT 08h)を使用しています。
                ★ <AT>インターバル割り込みの周期を変更している常
                   駐ソフトなどとは非常に相性が悪いでしょう。

------------------------------------------------------------------------
□ vsync_wait, vga_vsync_wait - 次のVSYNC開始を待つ

C:      void vsync_wait(void);
C:      void vga_vsync_wait(void);

        ------------------------------------------98N 98H AT DOS-
        vsync_wait                                 ○     ＊
        ------------------------------------------<vsyncwai.asm>-
        vga_vsync_wait                             ×  × ○
        ------------------------------------------<vgavwait.asm>-

                ● 次の VSYNC(正確にはVBLANK,  CRT垂直帰線区間)の
                   開始を待ちます。
                   　vsync_startが実行されていれば、 vsync_Count1
                   が変化するまで待ち、実行されていなければ I/Oポ
                   ートを監視して開始を待ちます。
                   　すでに垂直帰線区間の最中であった場合、次の開
                   始まで待つことになります。

                ○ vga_vsync_startが実行されているのなら、
                   vsync_Count1が変化するのを待ちます。実行されて
                   いないのなら、VGAのポートからvsyncの状態を読み
                   取り、開始を待ちます。


------------------------------------------------------------------------
■ タイマ割り込み ■■■■■■■■■■■■■■■■■■■■■■■■■■■

        　タイマ割り込みは、 基準周波数の整数倍の任意の周期で発生
        させることのできる割り込みです。
        　ただし、基準周波数は、機種によって異なります。
        　この割り込みを利用して、カウンタ変数を増加します。
        　アプリケーションは、この値を0にしてから経過した時間を、
        直接変数を参照することにより知ることができます。

------------------------------------------------------------------------
□ 構造体／グローバル変数

unsigned long timer_Count;      タイマ割り込み毎に 1 ずつ増加する
                                変数です。

void (far * timer_Proc)(void);
                        タイマ割り込みルーチンから呼ばれるサブル
                        ーチンのアドレス。
                        timer_start()によって設定されます。

------------------------------------------------------------------------
□ timer_end - タイマ割り込みの使用停止

C:      void timer_end(void);

        ------------------------------------------98N 98H AT DOS-
        timer_end                                  ○     ×
        ---------------------------------------------<timer.asm>-

                ● タイマ割り込みが設定されていれば、それを解除し
                   ます。設定されていなければ何もしません。

                ★ timer_startによって呼び出しを禁止していた、 以
                   前のタイマ割り込み処理が呼び出されるようになり
                   ます。
                ★ 周期は、既定値(10ms)に設定されます。

                ★ 一度timer_startを実行したら、 プログラムを終了
                   するまでにこれを実行する必要があります。
                   　これを守らなかった場合、あとで暴走することに
                   なります。

------------------------------------------------------------------------
□ timer_start - タイマ割り込みの設定およびカウンタリセット

C:      int timer_start( unsigned count, void (far *proc)(void) );

        ------------------------------------------98N 98H AT DOS-
        timer_start                                ○     ×
        ---------------------------------------------<timer.asm>-

                ● タイマ割り込みがまだ設定されていなければ、設定
                   します。
                   　設定されていてもいなくてもカウンタ変数を0に
                   設定します。

                ← count   割り込みの周期
                   proc    割り込み処理ルーチンのアドレス

                → 1(True)   　成功
                   0(False)  　すでに timer_startが実行され、動作
                             中であるので失敗
                             　この場合は timer_endを先に実行して
                             ください。

                   カウンタ変数:
                     timer_Count

                ★ 以前にタイマ割り込みとして動作していたルーチン
                   は呼び出されなくなります。

                ★ 一度設定したら、プログラムを終了するまでに
                   timer_endを実行する必要があります。
                   　実行せずに終了した場合、あとで暴走することに
                   なります。


------------------------------------------------------------------------
■ 音関係 ■■■■■■■■■■■■■■■■■■■■■■■■■■■■■■■


------------------------------------------------------------------------
■ BEEP音関係 ■■■■■■■■■■■■■■■■■■■■■■■■■■■■■

        　BEEP音のon/off、および周波数の指定を行います。
        　演奏を行いたい場合は、"BEEP音によるBGMと効果音の再生"項
        を参照してください。

------------------------------------------------------------------------
□ 定数

        ● beep_freq()の引数
        表記            値      意味
        SYS_BEEP_FREQ   2000    BEEP周波数のシステム既定値
        BEEP_FREQ_MIN   38      BEEP周波数の最小値
        BEEP_FREQ_MAX   65535   BEEP周波数の最大値

------------------------------------------------------------------------
□ beep_end - BEEP音の停止と周波数の復帰

C:      void beep_end(void);                               マクロ

        ------------------------------------------98N 98H AT DOS-
        beep_end                                   ○  × ＊
        -----------------------------------------------------<->-

                ● BEEP音を止め、周波数をシステム既定値に再設定し
                   ます。

------------------------------------------------------------------------
□ beep_freq, vbeep_freq - BEEP音の周波数を設定する

C:      void beep_freq( unsigned freq );
C:      void vbeep_freq( unsigned freq );

        ------------------------------------------98N 98H AT DOS-
        beep_freq                                  Ｖ  × ＊
        ------------------------------------------<beepfreq.asm>-
        vbeep_freq                                 ×  × ○
        ------------------------------------------<vbeepfrq.asm>-

                ● freqには、BEEP_FREQ_MIN 〜 BEEP_FREQ_MAX  の値
                   が使えます。
                   範囲外の値を指定するとゼロ除算エラーが発生しま
                   す。
                   鳴っている最中でも指定できます。

------------------------------------------------------------------------
□ beep_off - BEEP音を止める

C:      void beep_off(void);                               マクロ

        ------------------------------------------98N 98H AT DOS-
        beep_off                                   ○     ＊
        -----------------------------------------------------<->-

                ● BEEP音を止めます。

------------------------------------------------------------------------
□ beep_on - BEEP音を鳴らす

C:      void beep_on(void);                                マクロ

        ------------------------------------------98N 98H AT DOS-
        beep_on                                    ○     ＊
        -----------------------------------------------------<->-

                ● BEEP音を鳴らします。以後止めるまで鳴り続けます。


------------------------------------------------------------------------
■ BEEP PCM関係 ■■■■■■■■■■■■■■■■■■■■■■■■■■■■

        　98内蔵のBEEP音源を利用して、量子化ビット数が8bitのPCMデ
        ータを再生します。このデータは、"SPK"として知られる形式で
        す。
        　このデータをメインメモリに読み込み、pcm_convertを用いて
        再生データに変換すると、pcm_playで再生することができます。
        　再生できる周波数は、一応10〜40kHz?ぐらい(コンピュータの
        速度などに依存)で、通常は22kHzを用います。

------------------------------------------------------------------------
□ pcm_convert - PCMデータの変換

C:      void pcm_convert(  void far * dest, const void far * src,
                         unsigned rate, unsigned long size );

        ------------------------------------------98N 98H AT DOS-
        pcm_convert                                Ｖ  ×
        ------------------------------------------<pcmconvt.asm>-

                ● 8bitPCMデータをpcm_play用の再生データに変換し
                   ます。

                ← src  PCMデータ
                   size そのバイト数(64KBを超えてかまいません)
                   dest 変換結果の格納先(srcと一致して構いません)
                   rate 再生周期、通常はマクロ PCM_22kHz を指定し
                        て下さい。 大きな値を指定すると周期が長く
                        (再生周波数は低く)なります。しかし255まで
                        しか指定できませんので注意してください。
                        なお、 マクロ PCM_22kHzは実行時に条件判定
                        を行う文になっているので、 あらかじめ結果
                        を変数などに入れ、 それを利用すると実行形
                        式のサイズと実行時間の節約になります。

------------------------------------------------------------------------
□ pcm_play - PCMデータの再生

C:      void pcm_play( const void far * pcm,unsigned rate,unsigned long size);

        ------------------------------------------98N 98H AT DOS-
        pcm_play                                   Ｖ  × ×
        -------------------------------------------<pcmplay.asm>-

                ● pcm_convertによって変換されたPCMデータを再生し
                   ます。
                   再生中は、 VSYNC割り込みとタイマ割り込みを禁止
                   しています。 また、 終了時に  BEEP音の周波数を
                   2kHz(既定値)に、タイマ割り込みの周期を 10ms(既
                   定値)に設定します。 rate,sizeにはpcm_convertで
                   指定した値を指定して下さい。
                   なお、実際の再生周波数はかなり大雑把です。マシ
                   ンによっても誤差が出ますので注意してください。

                ○ 音質を改善したい場合、呼び出し直前にCLI(),  直
                   後にSTI()を実行することで、多少効果があります。
                   ただし割り込みを禁止することから、演奏中はキー
                   入力や他の演奏などは止まります。


------------------------------------------------------------------------
■ BEEP音によるBGMと効果音の再生 ■■■■■■■■■■■■■■■■■■■

        　BEEP音のみしか鳴らない環境においても、三重和音によるBGM
        演奏や、同時に効果音を鳴らしたりするための関数群です。
        　★この機能はDOS BOX内では何も起こりません。

        　bgm_init で準備し、bgm_finishで後始末をします。

------------------------------------------------------------------------
□ 構造体／グローバル変数

        ● ステータス構造体(bgm_read_status)
typedef struct BSTAT BSTAT;
struct BSTAT {
    int music;    演奏処理 BGM_STAT_ON/OFF
    int sound;    効果音処理 BGM_STAT_ON/OFF
    int play;     演奏中か否か BGM_STAT_PLAY/MUTE
    int effect;   効果音出力中か否か BGM_STAT_PLAY/MUTE
    int repeat;   リピート演奏か否か BGM_STAT_REPT/1TIM
    int mnum;     登録曲数
    int rnum;     セレクト中曲番号
    int tempo;    現在のテンポ
    int snum;     登録効果音数
    int fnum;     セレクト中効果音番号
} BSTAT;

        ● グローバルデータ構造体
typedef struct BGM_GLB BGM_GLB;
struct BGM_GLB {
    int imr;                    インターラプト・マスク・レジスタ
    unsigned int tval;          タイマ設定値
    int tp;                     テンポ
    int rflg;                   BGM ON/OFF
    int pnum;                   パート数
    int pcnt;                   パートカウンタ
    int fin;                    パート終了フラグ
    int rep;                    リピート ON/OFF
    int tcnt;                   処理カウンタ（4回に 1回処理）
    int bufsiz;                 楽譜バッファのサイズ
    int buflast;                楽譜バッファのラスト
    int mnum;                   登録曲数
    int mcnt;                   セレクト中曲番号
    int track[BGM_MUSIC_MAX];   曲のトラックナンバー
    int mask;                   パートマスク情報
    int mtp[BGM_MUSIC_MAX];     曲ごとのテンポ情報
    int effect;                 効果音 ON/OFF
    int snum;                   登録効果音数
    int scnt;                   セレクト中効果音番号
    int music;                  演奏処理 ON/OFF
    int sound;                  効果音処理 ON/OFF
    int init;                   イニシャライズ実行フラグ
    unsigned long clockbase;    tempo120時のタイマカウント
};

        ● パート構造体
typedef struct BGM_PART BGM_PART;
struct BGM_PART {
    unsigned char far *ptr;     楽譜ポインタ
    unsigned char far *mbuf;    楽譜バッファ
    char note;                  現在の音符
    int oct;                    現在のオクターブ
    int len;                    現在の音長
    int dflen;                  デフォルトの音長
    int lcnt;                   音長カウンタ
    int mask;                   パートマスク ON/OFF
    int tnt;                    テヌート ON/OFF
};

        ● 効果音構造体
typedef struct BGM_ESOUND BGM_ESOUND;
struct BGM_ESOUND {
    unsigned int far *sptr;     効果音データポインタ
    unsigned int far *sbuf;     効果音データバッファ
};

        ● 内部管理データ実体(普通は直接操作しないでください)
BGM_GLB bgm_glb;
BGM_PART bgm_part[BGM_PART_MAX];
BGM_ESOUND bgm_esound[BGM_SOUND_MAX];

------------------------------------------------------------------------
□ 定数

        ● BGMステータス(BSTAT)構造体のメンバの値
        表記            値      意味
        BGM_STAT_ON     1       効果音/曲演奏処理ON
        BGM_STAT_OFF    0       効果音/曲演奏処理OFF
        BGM_STAT_PLAY   1       効果音出力/曲演奏中
        BGM_STAT_MUTE   0       効果音/曲演奏停止中
        BGM_STAT_REPT   1       リピート演奏をする
        BGM_STAT_1TIM   0       リピート演奏をしない

        ● bgm_read_data() の引数
        表記            値      意味
        BGM_MES_ON      1       データファイル中のコメントを表示
                                する
        BGM_MES_OFF     0       データファイル中のコメントを表示
                                しない

        ● bgm_set_mode() の引数
        表記            値      意味
        BGM_MUSIC       1       曲演奏を許可する
        BGM_SOUND       2       効果音出力を許可する

        ● 管理できる総曲数など
        表記            値      意味
        BGM_MUSIC_MAX   16      曲数
        BGM_PART_MAX    3       曲のパート数
        BGM_SOUND_MAX   16      効果音数

------------------------------------------------------------------------
□ bgm_cont_play - 曲の演奏の再開

C:      int bgm_cont_play(void);

        ------------------------------------------98N 98H AT DOS-
        bgm_cont_play
        ------------------------------------------<b_c_play.asm>-

                ● 中断した曲の演奏を再開します。

                → NoError         正常終了
                   GeneralFailure  演奏中である

------------------------------------------------------------------------
□ bgm_finish - 演奏機能の後始末

C:      void bgm_finish(void);

        ------------------------------------------98N 98H AT DOS-
        bgm_finish                                 Ｖ  × ○ ○
        ------------------------------------------<b_inifin.asm>-

                ● 演奏機能の後始末をします。

                ○ 最後に一度だけ実行します。

                例:
                　bgm_initを参照してください。

------------------------------------------------------------------------
□ bgm_init - 演奏機能の準備

C:      int bgm_init(int bufsiz);

        ------------------------------------------98N 98H AT DOS-
        bgm_init                                   Ｖ  × ○ ○
        ------------------------------------------<b_inifin.asm>-

                ● 演奏機能を開始します。

                ← bufsiz  1パートあたりのバッファサイズ
                           通常は4096程度でいいですが、
                           bgm_read_data()   で曲を読み込むときに
                           InsufficientMemory  が返ってくるような
                           時に増やしてみてください。

                → NoError              成功
                   InsufficientMemory   メモリ不足

                ★ この関数を実行したら、DOSに戻るまでに必ず
                   bgm_finishを実行してください。

                ○ 内部で get_machine()を呼び出しています。
                ○ <AT>RTC割り込み(INT 70h)を使用しています。
                ○ <98>タイマ割り込みを使用しています。
                ○ 最初に一度だけ実行します。

                △MEMORY: bufsiz*3+512*16バイトのメモリを確保しま
                  す。

                例: 初期化と後始末だけの骨格
                  int main(void){
                      bgm_init(4096);     /* 初期化 */
                      bgm_finish();       /* 後始末 */
                      return 0;
                  }

------------------------------------------------------------------------
□ bgm_read_data - BGMファイルから曲データを読み込む

C:      int bgm_read_data(const char *fname, int tempo, int mes);

        ------------------------------------------98N 98H AT DOS-
        bgm_read_data                              Ｖ  × ○ ○
        ------------------------------------------<b_r_data.asm>-

                ● 曲データを読み込みます。

                ← fname  曲データファイル名
                   tempo  その曲のデフォルトテンポ(0,30-240)
                   mes    データファイル中のメッセージを表示する
                          か否か。
                          する(BGM_MES_ON),しない(BGM_MES_OFF)

                → NoError             正常終了
                   FileNotFound        ファイルが開けない
                   InvalidData         登録曲総数が 16 曲を越えた
                   InsufficientMemory  データバッファが足りない
                   InvalidFormat       ファイルの書式が異常

                ○ 曲データには読み込んだ順番に曲番号 1,2,3,…,16
                   が付きます。以後、曲を指定するときはこの番号で
                   指定します。
                   　tempo として 0  を指定するとその曲のテンポは
                   120  に設定されます。ただし,曲データ内でテンポ
                   を指定している場合はそれが最優先されます。

                △MEMORY:  一時的にファイルサイズ分のメモリを確保
                  して作業します。このため、ファイルサイズは 64KB
                  未満である必要もあります。

------------------------------------------------------------------------
□ bgm_read_sdata - EFSファイルから効果音データを読み込む

C:      int bgm_read_sdata(const char *fname);

        ------------------------------------------98N 98H AT DOS-
        bgm_read_sdata                                       ○
        ------------------------------------------<b_r_sdat.asm>-

                ● 効果音データを読み込みます。

                ← fname   効果音データファイル名

                → NoError        正常終了
                   FileNotFound   ファイルオープンエラー
                   InvalidFormat  データフォーマットエラー

                ○ 効果音データには読み込んだ順番に効果音番号
                   1,2,3,…,16 が付きます。 以後,効果音を指定する
                   ときはこの番号で指定します。
                   　データは 1つのファイルにあっても複数のファイ
                   ルに分かれていても構いません。また合計  16個を
                   越えた場合は無視されます。

------------------------------------------------------------------------
□ bgm_read_status - 演奏機能の状態の読み取り

C:      void bgm_read_status(BSTAT *bsp);

        ------------------------------------------98N 98H AT DOS-
        bgm_read_status
        ------------------------------------------<b_r_stat.asm>-

                ● 演奏機能の現在の状態を読み出します。

                ← bsp  状態のコピーの格納先

                ○ BSTAT構造体の内容については、 「構造体／グロー
                   バル変数」を参照してください。

------------------------------------------------------------------------
□ bgm_repeat_off - 曲のくり返し演奏を行わない

C:      void bgm_repeat_off(void);

        ------------------------------------------98N 98H AT DOS-
        bgm_repeat_off
        ------------------------------------------<b_repeat.asm>-

                ● 演奏している曲の最後に達すると自動的に先頭から
                   演奏を続ける(リピート)機能を無効にします。

                ○ bgm_init実行後は有効になっています。

------------------------------------------------------------------------
□ bgm_repeat_on - 曲のくり返し演奏を行う

C:      void bgm_repeat_on(void);

        ------------------------------------------98N 98H AT DOS-
        bgm_repeat_on
        ------------------------------------------<b_repeat.asm>-

                ● 演奏している曲の最後に達すると自動的に先頭から
                   演奏を続ける(リピート)機能を有効にします。

                ○ bgm_init実行後は有効になっています。

------------------------------------------------------------------------
□ bgm_select_music - 演奏する曲の選択

C:      int bgm_select_music(int num);

        ------------------------------------------98N 98H AT DOS-
        bgm_select_music                           Ｖ  × ○
        ------------------------------------------<b_s_msic.asm>-

                ● 演奏する曲を選択します。

                ← num  曲番号(1〜)

                → NoError      正常終了
                   InvalidData  曲番号が異常

                ○ 選択しても演奏開始はしません。

                例:
                  int main(void){
                      bgm_init(4096);
                      /* sample.bgmをデフォルトテンポでメッセージ
                      表示OFFで読み込む */
                      bgm_read_data("sample.bgm",0,BGM_MES_OFF);
                      bgm_finish();
                      return 0;
                  }

------------------------------------------------------------------------
□ bgm_set_mode - 曲演奏／効果音出力動作の可否を設定

C:      void bgm_set_mode(int mode);

        ------------------------------------------98N 98H AT DOS-
        bgm_set_mode                               Ｖ  × ○
        ------------------------------------------<b_s_mode.asm>-

                ● 曲演奏,効果音出力の機能の有無を設定します。

                ← mode   BGM_MUSIC, BGM_SOUND の組み合わせで出力
                          の可否を指定します。

                例:
                  int main(void){
                      bgm_init(4096);
                      /* 全て機能(デフォルト) */
                      bgm_set_mode(BGM_MUSIC + BGM_SOUND);

                      /* 曲演奏のみ機能 */
                      bgm_set_mode(BGM_MUSIC);

                      /* どちらも機能しない */
                      bgm_set_mode(0);

                      bgm_finish();
                      return 0;
                  }

------------------------------------------------------------------------
□ bgm_set_tempo - 曲のテンポを設定

C:      int bgm_set_tempo(int tempo);

        ------------------------------------------98N 98H AT DOS-
        bgm_set_tempo
        ------------------------------------------<b_s_temp.asm>-

                ● 曲演奏のテンポを設定します。

                ← tempo  テンポ(30〜240)

                → NoError      正常終了
                   InvalidData  範囲エラー

                ○ 演奏中でも自由に設定できます。

------------------------------------------------------------------------
□ bgm_sound - 効果音出力の開始

C:      int bgm_sound(int num);

        ------------------------------------------98N 98H AT DOS-
        bgm_sound                                  Ｖ  × ○
        -------------------------------------------<b_sound.asm>-

                ● 効果音を出力(開始)します。

                ← num  効果音番号(1〜16)

                → NoError      正常終了
                   InvalidData  効果音番号が異常

------------------------------------------------------------------------
□ bgm_start_play - 曲の演奏の開始

C:      int bgm_start_play(void);

        ------------------------------------------98N 98H AT DOS-
        bgm_start_play                             Ｖ  × ○
        ------------------------------------------<b_st_ply.asm>-

                ● 選択されている曲の演奏を開始します。

                → NoError      正常終了
                   InvalidData  曲番号が異常

                ○ 演奏途中なら最初から演奏します。テンポはデフォ
                   ルトに戻ります。

------------------------------------------------------------------------
□ bgm_stop_play - 曲の演奏の中断

C:      int bgm_stop_play(void);

        ------------------------------------------98N 98H AT DOS-
        bgm_stop_play                              Ｖ  × ○
        ------------------------------------------<b_sp_ply.asm>-

                ● 曲の演奏を中断します。

                → NoError         正常終了
                   GeneralFailure  演奏中ではない

                ○ 中断後は bgm_cont_play()  によって演奏を再開で
                   きます。

------------------------------------------------------------------------
□ bgm_stop_sound - 効果音出力の停止

C:      int bgm_stop_sound(void);

        ------------------------------------------98N 98H AT DOS-
        bgm_stop_sound                             Ｖ  × ○ ○
        ------------------------------------------<b_sp_snd.asm>-

                ● 効果音の出力を中断します。

                → NoError         正常終了
                   GeneralFailure  出力中ではない

                ★ 中断した効果音を続きから鳴らすことはできません。

------------------------------------------------------------------------
□ bgm_wait_play - 演奏中の曲の終了待ち

C:      int bgm_wait_play(void);

        ------------------------------------------98N 98H AT DOS-
        bgm_wait_play
        ------------------------------------------<b_w_play.asm>-

                ● 演奏中の曲が終わるまで待ちます。

                → NoError         正常終了
                   GeneralFailure  演奏中ではない

------------------------------------------------------------------------
□ bgm_wait_sound - 効果音出力の終了待ち

C:      int bgm_wait_sound(void);

        ------------------------------------------98N 98H AT DOS-
        bgm_wait_sound
        -------------------------------------------<b_w_snd.asm>-

                ● 効果音の出力が終わるまで待ちます。

                → NoError         正常終了
                   GeneralFailure  出力中ではない


------------------------------------------------------------------------
■ 通信関係 ■■■■■■■■■■■■■■■■■■■■■■■■■■■■■■


------------------------------------------------------------------------
■ PC-9801 RS-232C関係 ■■■■■■■■■■■■■■■■■■■■■■■■

        　PC-9801のRS-232Cを直接制御するルーチン集です。
        　仕様は、次のようになっています。
        ---------------------------------------------------------
        通信ポート      現在は本体内蔵のみ
        通信速度        150, 300, 600, 1200,  2400,  4800,  9600,
                        19200, 31250, 38400bps
        データ長        7,8bit
        パリティ        なし,偶数,奇数
        ストップビット  1bit,1.5bit,2bit
        フロー制御      なし・XON/XOFF・RS/CSの３種類の中から一つ
                        選択
        シフト制御      なし
        送信バッファ    2048バイト・リングバッファ
        受信バッファ    6144バイト・リングバッファ、 フロー開始は
                        4096バイト溜ったとき。 満杯のときに受信し
                        た文字は捨てる。
        送信方法        送信割り込み
        受信方法        受信割り込み
        フロー制御方法  送受信割り込みで行います。 XON/XOFFフロー
                        時は、 XOFFを送信したあとはさらに文字を受
                        信するたびに XOFFを送信する仕様になってい
                        るので注意してください。
                        ソフトフロー制御のときに XON/XOFFを受信し
                        た場合、 これらの文字は受信バッファに格納
                        されずに停止／再開動作だけ行います。
        ---------------------------------------------------------

------------------------------------------------------------------------
□ 定数

        ● sio_start() の param 引数のビット要素
        表記            値      意味
        SIO_Nxx         0x00    パリティなし
        SIO_Oxx         0x10    奇数パリティ
        SIO_Exx         0x30    偶数パリティ

        SIO_x7x         0x08    データ長 7bit
        SIO_x8x         0x0c    データ長 8bit

        SIO_xx1         0x40    ストップビット長 1bit
        SIO_xx2         0x80    ストップビット長 1.5bit
        SIO_xx3         0xc0    ストップビット長 2bit

        ● sio_start() の flow 引数の値
        表記            値      意味
        SIO_FLOW_NONE   0       フロー制御なし
        SIO_FLOW_HARD   1       ハードウェア(RS/CS)フロー
        SIO_FLOW_SOFT   2       ソフト(XON/XOFF)フロー

        ● sio_start(), sio_setspeed() の speed の値
        表記            値      意味
        SIO_MIDI        128     31250bps
        SIO_38400       9       38400bps
        SIO_19200       8       19200bps
        SIO_9600        7        9600bps
        SIO_4800        6        4800bps
        SIO_2400        5        2400bps
        SIO_1200        4        1200bps
        SIO_600         3         600bps
        SIO_300         2         300bps
        SIO_150         1         150bps

        ● sio_bit_on(), sio_bit_off() の mask値
        表記            値      意味
        SIO_ER          0x02    sio_bit_on/off() DTR
        SIO_ERRCLR      0x10    sio_bit_on/off()  Errorフラグクリ
                                ア
        SIO_RS          0x20    sio_bit_on/off() RTS
        SIO_BREAK       0x80    sio_bit_on/off() ブレーク信号

        ● sio_read_err() の戻り値のビット要素
        表記            値      意味
        SIO_PERR        0x08    パリティエラー
        SIO_OERR        0x10    オーバーランエラー
        SIO_FERR        0x20    フレーミングエラー

        ● sio_read_signal() の戻り値のビット要素
        表記            値      意味
        SIO_CI          0x80    着呼検出
        SIO_CS          0x40    送信可
        SIO_CD          0x20    キャリア検出

        ● バッファサイズ定数
        表記                    値      意味
        SIO_SENDBUF_SIZE        2048    送信バッファサイズ
        SIO_RECEIVEBUF_SIZE     6144    受信バッファサイズ

------------------------------------------------------------------------
□ sio_bit_off - DTR,RTS,BREAK制御線OFF

C:      void sio_bit_off( int port, int mask );

        ------------------------------------------98N 98H AT DOS-
        sio_bit_off                                ○     ×
        --------------------------------------------<siobit.asm>-

                ● DTR,RTS,BRAK信号線のいずれか１〜３本を OFF  に
                   します。

                ← SIO_ER(DTR信号), SIO_RS(RTS信号), SIO_BREAK(ブ
                   レーク信号) のどれか、 または複数を論理和(|)で
                   組み合せて OFFにする線を指定

------------------------------------------------------------------------
□ sio_bit_on - DTR,RTS,BREAK制御線ON

C:      void sio_bit_on( int port, int mask );

        ------------------------------------------98N 98H AT DOS-
        sio_bit_on                                 ○     ×
        --------------------------------------------<siobit.asm>-

                ● DTR,RTS,BRAK信号線のいずれか１〜３本を ON にし
                   ます。

                ← SIO_ER(DTR信号), SIO_RS(RTS信号), SIO_BREAK(ブ
                   レーク信号) のどれか、 または複数を論理和(|)で
                   組み合せて ONにする線を指定

------------------------------------------------------------------------
□ sio_disable - (RS-232C割り込み禁止)

C:      void sio_disable( int port );

        ------------------------------------------98N 98H AT DOS-
        sio_disable                                ○     ×
        ------------------------------------------<siostart.asm>-

                ● 送信・受信割り込みを禁止します。通常は呼ばない
                   で下さい。

------------------------------------------------------------------------
□ sio_enable - (RS-232C割り込み許可)

C:      void sio_enable( int port );

        ------------------------------------------98N 98H AT DOS-
        sio_enable                                 ○     ×
        ------------------------------------------<siostart.asm>-

                ● 送信・受信割り込みを許可します。通常は呼ばない
                   で下さい。

------------------------------------------------------------------------
□ sio_end - RS-232C制御ルーチンの開放(1)

C:      void sio_end( int port );

        ------------------------------------------98N 98H AT DOS-
        sio_end                                    ○     × ○
        ------------------------------------------<siostart.asm>-

                ● 各信号線をすべて OFF にして、sio_start  によっ
                   てフックした割り込みを解除します。また送受信割
                   り込みを禁止します。 sio_start(sio_enter) を実
                   行した場合、かならず sio_end または  sio_leave
                   を実行してください。

------------------------------------------------------------------------
□ sio_enter - RS-232C制御ルーチンの初期化(2)

C:      void sio_enter( int port, int flow );              マクロ

        ------------------------------------------98N 98H AT DOS-
        sio_enter                                  ○     × ○
        -----------------------------------------------------<->-

                ● sio_*関数群の変数などを、RS-232Cハードウェアの
                   各種パラメータを一切タッチせずに初期化します。
                   また、まだ割り込みベクタをフックしていない場合
                   はフックします。

                ← flow         フロー制御の選択。  SIO_FLOW_NONE
                                (なし),   SIO_FLOW_HARD  (RS/CS),
                                SIO_FLOW_SOFT  (XON/XOFF)のどれか
                                を指定してください。

------------------------------------------------------------------------
□ sio_error_reset - パリティエラーなどのフラグをクリアする

C:      void sio_error_reset( int port );                  マクロ

        ------------------------------------------98N 98H AT DOS-
        sio_error_reset                            ○     ×
        -----------------------------------------------------<->-

                ● 物理通信エラーフラグ(パリティ,オーバーラン,フ
                   レーミングエラー)をクリアします。

------------------------------------------------------------------------
□ sio_getc - 1文字受信

C:      int sio_getc( int port );

        ------------------------------------------98N 98H AT DOS-
        sio_getc                                   ○     ×
        -------------------------------------------<sioread.asm>-

                ● 1バイトのデータを受信バッファから抜き取ります。

                → 0〜255  受信したデータ
                   -1      受信バッファが空

------------------------------------------------------------------------
□ sio_leave - RS-232C制御ルーチンの開放(2)

C:      void sio_leave( int port );

        ------------------------------------------98N 98H AT DOS-
        sio_leave                                  ○     × ○
        ------------------------------------------<siostart.asm>-

                ● 各信号線はそのままに、sio_start によってフック
                   した割り込みを解除します。また送受信割り込みを
                   禁止します。sio_start(sio_enter)  を実行した場
                   合、かならず sio_end または sio_leave を実行し
                   てください。

------------------------------------------------------------------------
□ sio_putc - 1文字送信

C:      int sio_putc( int port, int c );

        ------------------------------------------98N 98H AT DOS-
        sio_putc                                   ○     ×
        -------------------------------------------<sioputc.asm>-

                ● 1バイトのデータを送信バッファに追加します。

                → 1 成功
                   0 送信バッファが満杯なので失敗

------------------------------------------------------------------------
□ sio_putp - パスカル文字列送信

C:       unsigned sio_putp( int port, const char * passtr );

        ------------------------------------------98N 98H AT DOS-
        sio_putp                                   ○     ×
        -------------------------------------------<sioputp.asm>-

                ● パスカル文字列を送信バッファに追加します。

                → 1〜 格納した文字数
                   0 送信バッファが満杯なので失敗

------------------------------------------------------------------------
□ sio_puts - 文字列送信

C:      unsigned sio_puts( int port, const char * str );

        ------------------------------------------98N 98H AT DOS-
        sio_puts                                   ○     ×
        -------------------------------------------<sioputs.asm>-

                ● 文字列を送信バッファに追加します。

                → 1〜 格納した文字数
                   0 送信バッファが満杯なので失敗

------------------------------------------------------------------------
□ sio_read - データブロック受信

C:      unsigned sio_read( int port, void * recbuf, unsigned reclen );

        ------------------------------------------98N 98H AT DOS-
        sio_read                                   ○     ×
        -------------------------------------------<sioread.asm>-

                ● 複数バイトのデータを一括して受信バッファから引
                   き取ります。

                ← recbuf       受取り先の先頭アドレス
                   reclen       最大受取り長(バイト数)

                → 引き取ることの出来たバイト数 (0〜6144)
                   受信バッファが空ならば 0 になります。また、 満
                   杯のときでも最大 6144バイトしか引き取れません。

------------------------------------------------------------------------
□ sio_read_dr - DR(DSR)信号線読み取り

C:      int sio_read_dr( int port );

        ------------------------------------------98N 98H AT DOS-
        sio_read_dr                                ○     ×
        ------------------------------------------<siosigna.asm>-

                ● DR信号線を読み取ります。

                → 0以外 ON
                   0     OFF

------------------------------------------------------------------------
□ sio_read_err - パリティエラーなどのフラグを読む

C:      int sio_read_err( int port );

        ------------------------------------------98N 98H AT DOS-
        sio_read_err                               ○     ×
        ------------------------------------------<siosigna.asm>-

                ● 物理通信エラーフラグを読みます。エラーは３種類
                   あり、そのビットの組み合せで返します。これらの
                   フラグは、一度発生するとクリアするまで立ったま
                   まです。

                  SIO_PERR      パリティエラー
                  SIO_OERR      オーバーランエラー
                  SIO_FERR      フレーミングエラー

------------------------------------------------------------------------
□ sio_read_signal - CI,CS,CD信号線読み取り

C:      int sio_read_signal( int port );

        ------------------------------------------98N 98H AT DOS-
        sio_read_signal                            ○     ×
        ------------------------------------------<siosigna.asm>-

                ● 各信号線の情報を得ます。

                → CIがONなら SIO_CI, CSがONならSIO_CS,  CDがONな
                   らSIO_CD の各ビットの論理和を返します。結果と、
                   目的の信号線に対応した定数の論理積の結果が   0
                   でなければ ONという事になります。

------------------------------------------------------------------------
□ sio_receivebuf_len - 受信バッファ内のバイト数を得る

C:      unsigned sio_receivebuf_len( int port );           マクロ

        ------------------------------------------98N 98H AT DOS-
        sio_receivebuf_len                         ○
        -----------------------------------------------------<->-

                ● 受信バッファに溜っているデータのバイト数を得ま
                   す。

                → バイト数(0〜6144)

------------------------------------------------------------------------
□ sio_sendbuf_len - 送信バッファ内のバイト数を得る

C:      unsigned sio_sendbuf_len( int port );              マクロ

        ------------------------------------------98N 98H AT DOS-
        sio_sendbuf_len                            ○
        -----------------------------------------------------<->-

                ● 送信バッファに溜っている未送信データのバイト数
                   を得ます。

                → バイト数(0〜2048)

------------------------------------------------------------------------
□ sio_sendbuf_space - 送信バッファ内の空きバイト数を得る

C:      unsigned sio_sendbuf_space( int port );            マクロ

        ------------------------------------------98N 98H AT DOS-
        sio_sendbuf_space                          ○
        -----------------------------------------------------<->-

                ● 送信バッファにこれから追加できる空きのバイト数
                   を得ます。

                → バイト数(0〜2048)

------------------------------------------------------------------------
□ sio_setspeed - RS-232C速度指定

C:      void sio_setspeed( int port, int speed );

        ------------------------------------------98N 98H AT DOS-
        sio_setspeed                               ○     ×
        ------------------------------------------<siostart.asm>-

                ● 通信速度を変更します。送信／受信を行っている最
                   中に行うと文字が化けるので注意してください。

                ← speed        sio_startのspeed参照

------------------------------------------------------------------------
□ sio_start - RS-232C制御ルーチンの初期化(1)

C:      void sio_start( int port, int speed, int param, int flow );

        ------------------------------------------98N 98H AT DOS-
        sio_start                                  ○     × ○
        ------------------------------------------<siostart.asm>-

                ● RS-232Cの各種パラメータを初期化します。 また、
                   まだ割り込みベクタをフックしていない場合はフッ
                   クします。
                   　一度でもこの関数を実行したアプリケーションは、
                   終了までに必ず sio_end または sio_leave を呼び
                   出して下さい。呼び出さないと、終了してからハン
                   グアップします。

                ← port         ポート番号。0なら本体内蔵ポート。
                   speed        転送速度。SIO_150  (150bps)  から
                                SIO_38400 (38400bps) のどれか一つ、
                                または SIO_MIDI(31250bps)。なお、
                                動作クロックが   8MHz系の機種では
                                SIO_19200 と SIO_38400 を指定して
                                も SIO_9600 に丸めてしまいます。
                   param        通信パラメータ。通常はSIO_N81を使
                                用します。SIO_E72など、パラメータ
                                のすべての組み合せの定数が用意し
                                てあります。このN81などの文字列は、
                                N88BASICのOPEN(COM:)の説明を参照
                                してください。
                   flow         フロー制御の選択。  SIO_FLOW_NONE
                                (なし),   SIO_FLOW_HARD  (RS/CS),
                                SIO_FLOW_SOFT  (XON/XOFF)のどれか
                                を指定してください。

------------------------------------------------------------------------
□ sio_write - データブロック送信

C:      unsigned sio_write(int port, const void * senddata, unsigned sendlen);

        ------------------------------------------98N 98H AT DOS-
        sio_write                                  ○     ×
        ------------------------------------------<siowrite.asm>-

                ● 複数バイトのデータを一括して送信バッファに追加
                   します。

                ← senddata     送信するデータの先頭アドレス
                   sendlen      送信するデータの長さ(バイト数)

                → 送信バッファに追加できたバイト数 (0〜2048)
                   送信バッファが満杯なら 0 になります。また、 空
                   の状態でも最大 2048バイトしか格納できません。

                ○ sio_sendbuf_space()の結果が sendlen 以上である
                   ことを確認してから sio_write()を実行すれば、か
                   ならず完全に格納できます。


------------------------------------------------------------------------
■ その他 ■■■■■■■■■■■■■■■■■■■■■■■■■■■■■■■


------------------------------------------------------------------------
■ その他 ■■■■■■■■■■■■■■■■■■■■■■■■■■■■■■■

        乱数や細かいマクロがいくつか定義してあります。

------------------------------------------------------------------------
□ 構造体／グローバル変数

short SinTable8[256], CosTable8[256] ;  三角関数Sin8,Cos8の配列で
                                        す。
char AtanTable8[256] ;                  Atan8の配列です。
short SinTableDeg[360], CosTableDeg[360] ;   SinDec,CosDegの配列。
char AtanTableDeg[360] ;                AtanDegの配列。
long random_seed ;                      irandで使う乱数作業変数。

------------------------------------------------------------------------
□ Atan8 - アークタンジェント(256度系)

C:      int Atan8(int a);                                  マクロ

        ------------------------------------------98N 98H AT DOS-
        Atan8
        -----------------------------------------------------<->-

                ● 三角関数の逆正接を得ます。

                ← 傾き a は、0〜255で、256が傾き y=x  に相当しま
                   す。

                → 結果の角度は、0〜32になります。

                ○ AtanTable8を参照しています。

------------------------------------------------------------------------
□ AtanDeg - アークタンジェント(360度系)

C:      int AtanDeg(int a);                                マクロ

        ------------------------------------------98N 98H AT DOS-
        AtanDeg
        -----------------------------------------------------<->-

                ● 三角関数の逆正接を得ます。

                ← 傾き a は、0〜255で、256が傾き y=x  に相当しま
                   す。

                → 結果の角度は、0〜45になります。

                ○ AtanTableDegを参照しています。

------------------------------------------------------------------------
□ BYTE2PARA - バイト数をパラグラフ数に変換する

C:      unsigned BYTE2PARA( unsigned long bytelen );       マクロ

        ------------------------------------------98N 98H AT DOS-
        BYTE2PARA
        -----------------------------------------------------<->-

                ● バイト数を 16で割り余りがあるなら 1足す、 に相
                   当する計算をします。

                ← 1Mバイト以内のバイト数 (0〜0xffff0L)

                → パラグラフ数

                ★ 範囲外の値を指定すると結果の値は信頼できません。

------------------------------------------------------------------------
□ FP2LONG - farポインタを0:0からのlongオフセットに変換

C:      long FP2LONG( void far * fp );                     マクロ

        ------------------------------------------98N 98H AT DOS-
        FP2LONG
        -----------------------------------------------------<->-

                ● farポインタを、 0:0番地からの20bitオフセット値
                   に変換して、long値として返します。

                → 20bitオフセットアドレス

------------------------------------------------------------------------
□ FPADD - farポインタにlongオフセットを加算

C:      void far * FPADD( void far * fp, long offset );    マクロ

        ------------------------------------------98N 98H AT DOS-
        FPADD
        -----------------------------------------------------<->-

                ● farポインタに任意のオフセット値を加算し、 正規
                   化します。

                → 加算結果のfarポインタ

------------------------------------------------------------------------
□ FP_REGULAR - farポインタの正規化

C:      void far * FP_REGULAR( void far * ptr );           マクロ

        ------------------------------------------98N 98H AT DOS-
        FP_REGULAR
        -----------------------------------------------------<->-

                ● farポインタを正規化した値を得ます。

                → 正規化したポインタ。ここで型が void far  *にな
                   ることに注意してください。変数を正規化する場合、
                   同じ変数に値を代入する場合でもキャストが必要で
                   す。
                  例:  void regptr(char far * p)
                     {
                         p = (char far *)FP_REGULAR(p);
                     }

                ★ ポインタの正規化とは、オフセット値が  0x0000〜
                   0x000fの間になるようにセグメント値を補正するこ
                   とです。
                ★ なお、このマクロは引数 ptr を 2 度評価していま
                   すので、副作用に気を付けて下さい。

------------------------------------------------------------------------
□ FP_REGULAR_SEG - farポインタの正規セグメントを得る

C:      unsigned FP_REGULAR_SEG( void far * ptr );         マクロ

        ------------------------------------------98N 98H AT DOS-
        FP_REGULAR_SEG
        -----------------------------------------------------<->-

                ● farポインタを正規化したセグメント部分を得ます。

                → セグメント

------------------------------------------------------------------------
□ FP_REGULAR_OFF - farポインタの正規オフセットを得る

C:      unsigned FP_REGULAR_OFF( void far * ptr );         マクロ

        ------------------------------------------98N 98H AT DOS-
        FP_REGULAR_OFF
        -----------------------------------------------------<->-

                ● farポインタを正規化したオフセット部を得ます。

                → オフセット

------------------------------------------------------------------------
□ get_ds - データセグメントを得る

C:      int get_ds(void);                                  マクロ

        ------------------------------------------98N 98H AT DOS-
        get_ds
        -----------------------------------------------------<->-

                ● DS レジスタの値を得る(segread() 関数のサブセッ
                   ト風)。

                → DS レジスタの値

                ★ 厳密には DS レジスタの内容ではなく、DGROUP  セ
                   グメントの値です。Borland の C言語 Huge モデル
                   以外(マイクロソフトは全て)では、 C言語のコード
                   の中では常に DS にこの値が設定されています。

------------------------------------------------------------------------
□ iatan2 - (x,y)の角度を得る(アークタンジェント)(256度系)

C:      int iatan2( int y, int x );

        ------------------------------------------98N 98H AT DOS-
        iatan2
        --------------------------------------------<iatan2.asm>-

                ● y/xのアークタンジェントを得ます。 得られる角度
                   は、 0〜255となります。ただし、x,y がともに0の
                   場合、0を返します。

                ○ AtanTable8を参照しています。

------------------------------------------------------------------------
□ iatan2deg - (x,y)の角度を得る(アークタンジェント)(360度系)

C:      int iatan2deg( int y, int x );

        ------------------------------------------98N 98H AT DOS-
        iatan2deg
        ------------------------------------------<iatandeg.asm>-

                ● y/xのアークタンジェントを得ます。

                → 得られる角度は、0〜360となります。ただし、 x,y
                   がともに0の場合、0を返します。

                ○ AtanTableDegを参照しています。

------------------------------------------------------------------------
□ ihypot - 距離

C:      int ihypot( int x, int y );

        ------------------------------------------98N 98H AT DOS-
        ihypot
        ---------------------------------------------<isqrt.asm>-

                ● (x,y) の距離を得ます。
                   　途中計算にオーバーフローが発生しなければ、結
                   果は 0 〜32767になります。結果は小数第一位で四
                   捨五入しています。

                ★ 精度が非常に低いので、誤差に注意してください。

------------------------------------------------------------------------
□ INPB, INPW - I/Oポートからの読み込み(バイト/ワード)

C:      int INPB(int port);                                マクロ
C:      int INPW(int port);                                マクロ

        ------------------------------------------98N 98H AT DOS-
        INPB
        INPW
        -----------------------------------------------------<->-

                ● I/Oポートから読み込みます。

                ○ このマクロは、Microsoft系と  Borland系の違いを
                   吸収するために存在します。これらのマクロを使う
                   ことで、どちらのコンパイラでも警告なしで通るよ
                   うなソースファイルの作成を助けます。
                ○ INPBはバイト値、 INPWはワード値(16bit)を読み込
                   みます。

------------------------------------------------------------------------
□ irand - 擬似乱数

C:      int irand(void);

        ------------------------------------------98N 98H AT DOS-
        irand
        --------------------------------------------<random.asm>-

                ● 擬似乱数を返します。標準ライブラリの  rand()と
                   同一仕様です。

                → 乱数 0〜32767

                ○ この関数は、Borland C++ 3.1の rand()と同じ計算
                   式で乱数を生成しています。 式自体は、 seed   =
                   seed * 22695477 + 1, そしてこの結果の上位16bit
                   を、最上位ビットを落として返しています。

                ○ 標準ライブラリの srand(),rand()をそれぞれ
                   irand_init(),irand()に置換えることによって、わ
                   ずかなサイズ縮小と高速化を計ることができるかも
                   しれません。

------------------------------------------------------------------------
□ irand_init - 乱数系列の初期化

C:      void irand_init( long seedval );                   マクロ

        ------------------------------------------98N 98H AT DOS-
        irand_init
        -----------------------------------------------------<->-

                ● 乱数系列を初期化します。この値の初期値は 1  で
                   す。
                   　0 を入れると、次回の irand()は 0 になり、 そ
                   の次が irand_init(1)実行直後と同じ値から始まり
                   ます。
                   　この値に現在の秒などの値を入れることで、起動
                   毎にも乱数を最初から不規則にすることができます。

                ○ 標準ライブラリの srand(),rand()をそれぞれ
                   irand_init(),irand()に置換えることによって、わ
                   ずかなサイズ縮小と高速化を計ることができるかも
                   しれません。

                ○ random_seed に seedvalを設定しているだけです。

------------------------------------------------------------------------
□ isqrt - 平方根

C:      int isqrt( long x );

        ------------------------------------------98N 98H AT DOS-
        isqrt
        ---------------------------------------------<isqrt.asm>-

                ● x の平方根を得ます。x は、以下の範囲にないとオ
                   ーバーフローとして、0を返します。
                   0 ≦ x ＜ 32767.5↑2
                   ( 0 ≦ x ≦ 1073709056(3FFF8000h) )
                   　オーバーフローでなければ、結果は 0 〜32767に
                   なります。結果は小数第一位で四捨五入しています。
                   　結果が0になった場合、入力値が0でなければオー
                   バーフローということになります。

                ★ 精度が非常に低いので、誤差に注意してください。

------------------------------------------------------------------------
□ LONG2FP - 0:0からのlongオフセットをfarポインタに変換

C:      void far * LONG2FP( long );                        マクロ

        ------------------------------------------98N 98H AT DOS-
        LONG2FP
        -----------------------------------------------------<->-

                ● 0:0番地からの20bitオフセット値であるlong値をも
                   とに、正規化されたfarポインタを作成します。

                → farポインタ

------------------------------------------------------------------------
□ MK_FP - segment,offsetからfarポインタを合成

C:      void far * MK_FP( unsigned seg,unsigned off );     マクロ

        ------------------------------------------98N 98H AT DOS-
        MK_FP
        -----------------------------------------------------<->-

                ● セグメント値とオフセット値からfarポインタを作
                   成します。
                   (BorlandのC処理系で定義されているものと同等で
                   す。MSCに存在しないので定義しています。)

------------------------------------------------------------------------
□ OUTB, OUTW - I/Oポートへの書き込み(バイト/ワード)

C:      void OUTB(int port,int data);                      マクロ
C:      void OUTW(int port,int data);                      マクロ

        ------------------------------------------98N 98H AT DOS-
        OUTB
        OUTW
        -----------------------------------------------------<->-

                ● I/Oポートに書き込みます。

                ○ このマクロは、Microsoft系と  Borland系の違いを
                   吸収するために存在します。これらのマクロを使う
                   ことで、どちらのコンパイラでも警告なしで通るよ
                   うなソースファイルの作成を助けます。
                ○ OUTBはバイト値、 OUTWはワード値(16bit)を書き込
                   みます。

------------------------------------------------------------------------
□ peekb2 - メモリからの1バイト読み出し

C:      unsigned char peekb2( int segment, int offset );   マクロ

        ------------------------------------------98N 98H AT DOS-
        peekb2
        -----------------------------------------------------<->-

                ● segment:offset 番地の 1バイトを得ます。

------------------------------------------------------------------------
□ poke2 - メモリを指定データで埋める

C:      void poke2( int segment, int offset, int c, int count);
        マクロ

        ------------------------------------------98N 98H AT DOS-
        poke2
        -----------------------------------------------------<->-

                ● segment:offset 番地から count バイト を c で埋
                   めます。

                ★ _fmemset関数を呼び出しています。この関数が付属
                   していないコンパイラではこのままでは使えません。
                   また、string.hのインクルードが必要です。

------------------------------------------------------------------------
□ pokeb2 - メモリへの1バイト書き込み

C:      unsigned char pokeb2( int segment, int offset,
                             unsigned char c);             マクロ

        ------------------------------------------98N 98H AT DOS-
        pokeb2
        -----------------------------------------------------<->-

                ● segment:offset 番地の1バイトに c  を書き込みま
                   す。

------------------------------------------------------------------------
□ SEG2FP - セグメント値をポインタに変換する

C:      void far * SEG2FP( unsigned seg );                 マクロ

        ------------------------------------------98N 98H AT DOS-
        SEG2FP
        -----------------------------------------------------<->-

                ● セグメント値 seg, オフセット値 0 の  farポイン
                   タを作成します。

                → farポインタ

------------------------------------------------------------------------
□ Sin8, Cos8 - サイン、コサイン(256度系)

C:      int Sin8(int r);                                   マクロ
C:      int Cos8(int r);                                   マクロ

        ------------------------------------------98N 98H AT DOS-
        Sin8
        Cos8
        -----------------------------------------------------<->-

                ● 三角関数の正弦、余弦を得ます。
                   　角度rは、0〜255で、64が直角になります。256が
                   一周になりますが、このため角度を 1バイトで持つ
                   ことが出来ます。  8bit以上の角度が渡されても、
                   8bit に丸められます。
                   　結果の値は、-256 〜 256 となります。目的のデ
                   ータとの乗算結果を 8bit 右シフトすることで、三
                   角関数との積を得ることができます。オーバーフロ
                   ーが起こり易いため、 途中計算はできるだけ long
                   整数で行うようにしてください。

                ○ この256度系の角度処理を利用することにより、 角
                   度を 8bit 値で扱うことができ、メモリ効率の向上
                   を図れます。
                ○ SinTable8を参照しています。

                ★ 精度が非常に低いので、誤差に注意してください。

                例 :
                    vx = (int)(( (long)x*Cos8(kakudo) )>>8) + cx;
                    vy = (int)(( (long)y*Sin8(kakudo) )>>8) + cy;

------------------------------------------------------------------------
□ SinDeg, CosDeg - サイン、コサイン(360度系)

C:      int SinDeg(int r);                                 マクロ
C:      int CosDeg(int r);                                 マクロ

        ------------------------------------------98N 98H AT DOS-
        SinDeg
        CosDeg
        -----------------------------------------------------<->-

                ● 三角関数の正弦、余弦を得ます。

                ← 角度rは、0〜360で、90が直角になります。

                → 結果の値は、-256 〜 256 となります。

                ○ 目的のデータとの乗算結果を 8bit 右シフトするこ
                   とで、三角関数との積を得ることができます。オー
                   バーフローが起こり易いため、途中計算はできるだ
                   け long 整数で行うようにしてください。

                ★ 精度が非常に低いので、誤差に注意してください。

                ○ SinTableDegを参照しています。

                例 :
                    vx = (int)(( (long)x*CosDeg(kakudo)  )>>8)  +
                    cx;
                    vy = (int)(( (long)y*SinDeg(kakudo)  )>>8)  +
                    cy;

------------------------------------------------------------------------
[END OF MASTER.MAN]
