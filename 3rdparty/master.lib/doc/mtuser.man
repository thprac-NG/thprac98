ますたーりぶ 0.22k
ゆーざーずまにゅある
いいかげんで申し訳ない(^^;

=============================================================================

■ はじめに

        　このファイルには、 master.lib を使ってプログラムを作る時に、
        定型的にやってほしいことや、問題になりやすい点、およびＱ＆Ａを
        収録してあります。私のところに質問する前に、まずこのファイルと、
        関連する master.man を良く読んでください。


=============================================================================

■ 98からDOS/Vへの移行の際の注意点

        ●ジョイスティックに対応したプログラムが、終了するとハングアッ
          プしてしまう場合、js_endが実行されていない場合があります。
          98ではjs_endは実行しなくても害はありませんでしたが、DOS/V で
          は js_end(at_js_end)を実行しないと確実に暴走します。
          　サンプルとして添付していた PROGRAMS.LZHの中のソースが、 こ
          れに該当してしまっていました(^^;

        ●グラフィックとテキストを両方使うプログラムについて(1)
          この場合の初期化/終了処理は、必ず外側にテキスト、内側にグラ
          フィックの処理を移動してください。
          例:○良い例                   ×悪い例
             text_backup(1);            graph_start();
             graph_start();             text_backup(1);
             ...                        ...
             graph_end();               text_restore();
             text_restore();            graph_end();

        ●グラフィックとテキストを両方使うプログラムについて(2)
          テキスト画面は、透明ではありません。文字を書くと、文字の背景
          は塗り潰されるようになります。また、文字はグラフィック画面に
          描かれてしまうので、グラフィックの表示ページを切り替えたり、
          スクロールしたり、グラフィックを同じ場所に書いたりすると、そ
          この文字は消えたり移動したりしてまいます。
          　これを回避するには、グラフィックを描画するごとに、文字を
          書き直すなどする必要があります。
          　また、文字で上書きする性質上、その地点のグラフィックは破壊
          されていることになりますので、そこにも注意してください。

■ 間違って他機種用の関数を使わないようにする

        　ソースファイルの先頭など、#include "master.h"が実行されるより
        前に、以下の文を書きましょう。
          #define MASTERV  0  /* 98専用の場合 */
          #define MASTER98 0  /* DOS/V専用の場合 */
        　こうすることで、間違った機種用の関数を使うことが回避されます。
        もちろん、両用のプログラムを作るときはこんなことしてはいけません
        (笑)
        　さて、このときの回避の動作ですが、98専用の場合は、DOS/V関数は
        ヘッダにないものとみなされます。つまり、呼んでも「そんな関数は
        知らない」という警告、またはエラーがコンパイル時に現れます。
        　DOS/V専用の場合は、98用関数を使おうとすると、相当するDOS/Vの
        関数やその組み合わせに置き換えられます。この機能によって、宣伝
        文句である「再コンパイルで98用プログラムがDOS/V用になる」という
        ことが実現されるわけです。
        　なお、ソースを変更しなくても、コンパイルオプションによって
        同等の定義を行うほうがより奇麗ですね。以下のように。
          bcc -DMASTER98=0 hoge.c
          cl -DMASTERV=0 hoge.c


=============================================================================

■ grcg_off()を忘れないように

        　gc_poly の関数で描画するときは、grcg_setcolor() を使いますね。
        この関数は GRCG という98内蔵のグラフィックアクセラレータのスイ
        ッチを入れるのですが、これが生きているあいだはグラフィック画面
        に対する CPU からのアクセスが加工されます。 gc_poly の描画関数
        はこれを利用しているのですが、gc_poly 以外のグラフィックルーチ
        ンは、スイッチが入っていると誤動作、悪くはハングアップします。
        　これを防ぐ為に、gc_poly の描画関数以外を呼び出す前には、必ず
        grcg_off() を実行して下さい。 また、そうなる可能性のある場面で
        も付けるようにしてください。 (プログラム終了時、子プロセス起動
        時、キー入力待ちのときなど)


■ text_backup() text_restore() は、bios30_push()/bios30_pop()を呼んでます

        　text_backup(),text_restore() は、 正確に画面情報を保存、復元
        するために bios30_push() や bios30_pop()  を内部でよびだしてい
        ます。このために、bios30_push() して bios30_setmode() を呼び出
        すという動作は、 必ず text_backup() と text_restore() の間で実
        行して下さい。 というのも、bios30_setmode() を実行すると、テキ
        スト VRAM の新たに画面に出てくる部分の内容が消去される場合があ
        るからです。
        　なお、TT の1.05までは push/pop のスタックが1段しかありません
        でしたが、 現在の TT 1.50以降や、30bios のほとんど最初のバージ
        ョンからは、 スタックが8段(30bios)または16段(TT)使えますので、
        二重に push したところでほとんど問題が発生することはないと思わ
        れます。


利用を推奨するプログラムパーツ ==============================================

■ 30行BIOS対応(98)

        　PC-9801ノーマルモードで、400line以下の表示モードで動作し、グ
        ラフィック画面を利用するプログラムの場合、以下の文を使用すると
        30 行 BIOS を利用しているユーザーがモードを切り替えなくて済み、
        便利です。

        プログラム起動時, graph_start などよりも前に実行する処理

        C                 共通              Pascal
        text_backup(1);                     Text_Backup(True);
                          bios30_setline(25);
                          bios30_setmode(BIOS30_NORMALLINE|BIOS30_VGA);

        ※ bios30_* は、内部で bios30_exist を呼び出して存在判定を行い、
           存在していなければ何もしないようになっているので、 このよう
           に記述して大丈夫です。

        ※ 30bios ではノーマルモードに設定すると、GDC 描画時にノイズが
           残る機種が多いので、ノイズの出ない行間なし25行に設定します。

        プログラム終了時、graph_end などよりも後に実行する処理

        C                                   Pascal
        text_restore();                     Text_Restore;

        　テキスト画面を保存せず、 消去して終了する場合は、text_backup
        は bios30_push に、text_restore は bios30_pop に置換えることも
        できます。この場合、テキスト消去は text_clear で行うようにして、
        push->pop の間では DOS  を通したテキスト画面出力は行わないよう
        にして下さい。

        　なお、   graph_start    などのグラフィック画面設定よりも前に
        30bios の設定を行う必要がある理由は、 30matic(c)lucifer に対応
        するためです。 30matic  はグラフィック画面領域設定を行うまでに
        30bios の制御が行われなければ 30bios  未対応アプリケーションで
        あると判断して push、ノーマルモード設定を行います。

■ 常駐パレット対応(98)

        　PC-9801 ノーマルモードで、プログラム終了時に画面を復帰する場
        合、 graph_backup ではパレットは待避していないため、パレットの
        復帰が問題になります。

        　起動時の画面をそのまま編集する事を目的としたプログラムの場合、
        以下の処理を実行すると簡単です。

        開始
        graph_enter() ;
        ・ 画面を 400line、 アナログパレットモードで表示し、常駐パレッ
           トが存在すれば、Palettes に読み込み、ハードウェアパレットに
           設定します。

        終了
        graph_leave() ;
        ・ Palettes の内容を常駐パレットとハードウェアパレットに設定し
           て、400line, アナログパレットモードで表示します。


        　また、起動時の画面をただ単に待避して、プログラムは完全にグラ
        フィック画面を独占使用したあとに、復帰する処理は以下のようにな
        ります。

        開始
        graph_backup(G_ALLPAGE) ;
        ・ GVRAM の内容( 表裏とも) を EMS に待避します。

        終了
        graph_restore() ;
        graph_enter() ;
        ・ GVRAM の内容を復元するとともに、 常駐パレットの内容をハード
           ウェアパレットに設定し、画面を表示します。


        ★ なお、 MASTER.LIB では常駐パレットの 200line フラグは対応し
        ていません。常に 400line になります。


■ パターンの描画速度(98)

        　super_put などでパターンを描画する際の速度の実測値を以下に示
        します。ターゲットとする機種に対する表示パターン数などの目安に
        してください。(測定誤差が結構あるので注意)


            機種: PC-9801vm2
             CPU: V30
           Clock: 10MHz
           VSYNC:     17.3262ms
Size(x,y) super_put(0,0)  super_put(9,1)  super_put_8     over_put_8
192x255:     144.7277ms      154.4063ms       55.8943ms       26.5922ms
128x128:      49.8852ms       52.4060ms       19.4278ms        9.6097ms
 64x 64:      13.4293ms       14.4771ms        5.3308ms        3.0196ms
 32x 32:       3.9916ms        4.1861ms        1.6552ms        1.0925ms
 16x 16:       1.3460ms        1.5690ms        0.6188ms        0.4777ms
  8x  8:       0.5916ms        0.7495ms        0.4243ms        0.3308ms

            機種: PC-9801RA21
             CPU: Cx486DRx2(cache on)
           Clock: 40MHz
           VSYNC:     17.3575ms
Size(x,y) super_put(0,0)  super_put(9,1)  super_put_8     over_put_8
192x255:      33.2006ms       35.1411ms       27.3531ms       19.9129ms
128x128:      11.1739ms       11.6768ms        8.8053ms        6.3834ms
 64x 64:       3.0737ms        3.2531ms        2.2253ms        1.6125ms
 32x 32:       0.9252ms        0.9879ms        0.5916ms        0.4154ms
 16x 16:       0.3255ms        0.3605ms        0.1745ms        0.1180ms
  8x  8:       0.1220ms        0.1924ms        0.1143ms        0.0683ms

        　あとは、32x32dotの値のみ機種ごとに並べます。(遅い順(笑))

機種                 super_put(0,0)super_put(9,1)super_put_8   over_put_8
PC-9801VF2             4.6844ms      4.9854ms      1.8599ms      1.3461ms
PC-9801VM2             3.9916ms      4.1861ms      1.6552ms      1.0925ms
PC-9801VX2 (10MHz改)   2.0633ms      2.1736ms      0.8687ms      0.8789ms
PC-9801RX2             1.7549ms      1.8497ms      0.7645ms      0.5505ms
PC-9801LX2             1.7248ms      1.8127ms      0.7482ms      0.5513ms
PC-9801RA5             1.6090ms      1.5830ms      0.8248ms      0.6169ms
PC-9801NS/E            1.4843ms      1.4112ms      0.6936ms      0.5333ms
PC-9801DS2             1.3777ms      1.2540ms      0.6730ms      0.4702ms
PC-9801CS5             1.3601ms      1.2329ms      0.6470ms      0.4652ms
PC-9801RL              1.3395ms      1.2687ms      0.6774ms      0.4231ms
PC-9801T/F5            1.2044ms      1.0750ms      0.5761ms      0.4227ms
PC-9801NC              1.1783ms      1.0477ms      0.5826ms      0.4101ms
PC-9801DA5             1.1348ms      0.9887ms      0.5672ms      0.4048ms
PC-9801DA              1.1096ms      0.9916ms      0.5708ms      0.4073ms
PC-9801RA21(Cx486DRx2) 0.9252ms      0.9879ms      0.5916ms      0.4154ms
PC-9801EX  (Cx486SLC倍)0.8935ms      1.0416ms      0.5733ms      0.3873ms
PC-9801RA21(Cx486DLC倍)0.8915ms      0.9724ms      0.5688ms      0.4052ms
PC-386NoteAR2          0.8386ms      0.7548ms      0.4040ms      0.2770ms
PC-386GS + Cx486DLC    0.7649ms      0.8825ms      0.4199ms      0.3275ms
PC-9801FA              0.7161ms      0.7316ms      0.4902ms      0.2819ms
PC-9801DX/U2+PK-X486/87SL
                       0.7051ms      0.7491ms      0.4866ms      0.2445ms
PC-H98S model8         0.6410ms      0.6410ms      0.4517ms      0.2979ms
PC-9801 NS/R           0.5934ms      0.7116ms      0.3069ms      0.2058ms
PC-9801NA              0.4663ms      0.5635ms      0.2815ms      0.1631ms
PC-9821As/U2           0.2795ms      0.3373ms      0.1359ms      0.0980ms
PC-9821Ne              0.2742ms      0.3328ms      0.1428ms      0.0964ms
PC-9821Ap2/U2          0.2046ms      0.2046ms      0.1411ms      0.0667ms
PC-486HX               0.1810ms      0.1839ms      0.1281ms      0.0821ms


■ キー入力(98)

        　PC-9801 シリーズで、特殊キーも含めたキー入力を行う場合、以下
        の処理を実行することになります。

        プログラム開始時 :
        key_start() ;

        キー入力があれば読み取り、なければ素通り
        a = key_scan() ;
        if ( a == 0xffff )
            dos_puts( " 押されてない "CRLF ) ;

        キー入力があるまで待ち、その内容を得る
        a = key_wait() ;

        プログラム終了時 :
        key_end() ;


■ ファイル名にデフォルトの拡張子をつける(DOS)

        　MS-DOS のファイル名処理のときに、 よくユーザー入力で省略され
        た拡張子を補う事があります。
        　この処理は以下のようにするのが簡単です。

        ・文字列 filename に、拡張子 .ABC をデフォルトとして付加する
        　if ( strchr( file_basename( filename ), '.' ) == NULL ) {
        　    strcat( filename, ".ABC" ) ;
          }


■ Ｑ ＆ Ａ =================================================================

        ここでは、ネット上での質問と、解答を抜粋して並べます。

        --------------------------------------------------------------
        Ｑ.
        　wfont, wkanji  などの圧縮データはどうやって作るのですか?
        　何かツールとかがあるのでしょうか?
                                     (ArtsLink la femy/fem21464 (TAT))
        Ａ.
        　圧縮フォント(wfont)の ANK部分は、ただの8x8dot fontです。
        　全角部分は 2  プレーン使って縦に半分に圧縮して表示するってや
        つです。
        wlook でも使われてるやりかた。
                                                                (恋塚)

        --------------------------------------------------------------
        Ｑ.
        　公開された ver0.20 の super_in が正常に動作しません。
        　super_put などに差し替えると正常動作しました。
        　super_in 関数実行後にハングアップしてしまいます。
        　ちなみにＣ言語用のライブラリです。
        　コンパイラは TURBO C 2.0 を使っています
                                (ArtsLink la femy/fem21537 (Y.YABUKI))
        Ａ.
        　super_put と較べてるところをみると、キャラクターとして登録せ
        ずにパターン番号で super_in してしまったとか...(^^;
                                   (ArtsLink la femy/fem20054 (M.Kit))


        --------------------------------------------------------------
        Ｑ.
        　hmem_allocbyte( GB_GETSIZE( 0, 0, 79, 399 ) );
        　と、 画面全体まで大きくとるとテキストVRAM やグラフィックVRAM
        の領域に重なるようにメモリが確保されてしまいます。  hmem_alloc
        でもおなじでした。
                                         (ascii-net/net22516 (Grouch))
        Ａ.
        　hmem_lallocate( GB_GETSIZE( 0, 0, 79, 399 ) )  に変えてみて
               ~~~~~~~~~
        ください。(hmem_allocbyte()ではありません)
        　そのままだと、 16bit の int 型で計算するので、  全体に必要な
        128KB というのは int ではオーバーフローしてしまい、 本来の値よ
        り遥かに小さな値が結果として返されているのです。
        　よって、long計算に直すことで値が正しくなります。
                                                                (恋塚)


        --------------------------------------------------------------
        Ｑ.
        　現在のアナログパレット状況をグローバル変数    Palletes    に
        入れる関数が欲しいんですが‥‥ (^^;
        　pallete_show(); の逆の働きです。
                                  (ArtsLink la femy/fem21099 (伊藤徳彦)
        Ａ.
        　ハードウェアパレットが読める機種は
                PC-H98シリーズ
                PC-9821シリーズ
                PC-98GS
                PC-9801B 以降, 98NOTE も最近の機種 ?
        　だけだよね。
        　これらの機種は、 4096色中16色の他に、16777216色中256色や、そ
        れ以上の同時発色モードを持っているので、読む前にどのモードかも
        判別する必要もあるよな。
                                                                (恋塚)


        --------------------------------------------------------------
        Ｑ.
        　master.lib の super.lib 部分なんですが repair_back または、 
        super_repair がうまく使えません。
        　8x8 のパターンを PLANE1 で戻したいんだけど、 16x8 のエリアが
        黒く(0?)なってしまうのです...(;_;)

        　graph_copy_page( 1 ) した後、 アクセスプレーンを0 に戻して、
        やってますがうまく、いきません。思い当たるところ、手順など教え
        て下さい。

        　super_put_8 と repair_back の組み合わせなんですが。
        あ、途中で grcg_hline (grcg_setcolorと)も使ってますが...
                                  (ArtsLink la femy/fem20054 (M.Kit))

        Ａ.
        　grcg_setcolor  やったのなら   grcg_off   しないと駄目ですぜ
        repair 系は VRAM 読んでるからねー
        　それと、 repair_back は、横方向は 8の倍数に丸め、さらに 8dot
        余分に復元しています。
                                                                (恋塚)

        --------------------------------------------------------------
        Ｑ.
        　げろーん、そうだったんですか〜
        　GDC と GRCG と EGC と VRAM 直と、 組み合わせて使う場合の注意
        とかよく分からないよ〜
        TDW と RMW の違いもいまいちわからん
                                  (ArtsLink la femy/fem20054 (M.Kit))

        Ａ.
        　VRAM直書きのつもりでも、GRCG が ON になってると、GRCG の機能
        が生きちゃってるっていうことですね、今回のは。

        　EGC は GRCG のちょっと高機能なやつと思えばよくて、EGC の機種
        だと GDC  の描画にもグラフィックチャージャとしての機能が有効に
        なるということだけが違います。

        　基本的には、 VRAM 直書きをやるときには GRCG を(使わなければ)
        OFF にする必要がありますね!?

        　gc_poly.lib を利用する場合には、 連続して gc_poly.lib の関数
        で描画するとき以外は GRCG を OFF にしておいたほうが安全かと。

                                                              (Kazumi)

        --------------------------------------------------------------
        Ｑ.
        　なかなか、 ややこしいっすねそこらへんは mouse つかうともっと
        ややこしいっす
                                                                (SuCa)
        Ａ.
        　そうかなあ
        　mouse cursor  が出ているときは一切グラフィック画面を使っては
        いけないというだけの話だと思うけど。
                                                                (恋塚)

        --------------------------------------------------------------
        Ｑ.
        　うーんと、dos_findnextの挙動がちょっと怪しいのですが。
        なんか、標準関数のと違うみたい。
                                (ArtsLink la femy/fem21226 (らいおん))

        Ａ.
        　どこかを   findnext   してる途中で、    他のところをそのまま
        findfirst したら、前の findnext は忘れてしまいます。これは DOS
        function の仕様です。
        　つまり、DTA に次に検索するときのための情報が保存されているの
        に、ひとつの DTA を共有する場合は上書きされてしまうからですね。
        　こーゆーことをやるために、DTA のセーブ -> 設定 -> 検索 -> 元
        にもどす、という手順を踏んでいるんだな < MSC/BC の関数
        　同じ事をやる場合、 再帰的にやるとわかっている場面では DTA 取
        得関数が master.lib にないので、MSC/BC 付属関数使って下さい。
        　なお、 途中で別の検索にはいらず、 連続して一気に読む場面では
        master.lib 版のほうが効率が良くなります。

        　あ、ちなみに DTA をローカル変数に持ち、関数の中で dos_setdta
        を実行している関数が、同様の関数を呼び出したときには、帰ってき
        たときにもう一度 dos_setdta を実行すれば検索が継続できますね。
                                                                (恋塚)

        --------------------------------------------------------------
        Ｑ.
        　master.libで半角ｶﾅと2Byte半角を出したいのですが。

        　今、通信ソフトを作っていまして、text_putc() でテキストに出力
        していましたが、半角カナと 2byte半角の部分が豆腐になってしまう
        ので何とか普通に表示したいと思って、 とりあえず下記((a) 半角カ
        ナ/(b)2byte半角)のような関数を作って対応してますが、master.lib
        の他の関数との兼ねあいは、大丈夫でしょうか？　ちなみに今のとこ
        ろおかしな動作はしてませんが(^^;

        　また、「ここはこうした方が……」という事がありましたら教えて
        下さい。

        *-------------------------------------------------------------
        |extern unsigned xp; // 出力位置
        |extern unsigned   putLine;   // 出力行(他の関数で変わります)
        |
        |//-----( (a)半角カナ )---------------------------------------
        (省略)
        |//-----( (b)２Byte半角 )-------------------------------------
        |void    putZenkaku( unsigned ch )      // ch : 全角文字
        |{
        |  text_putc( xp, putLine, ch );        // 全角文字の表示
        |  if( 0x8540u <= ch && ch <= 0x869Eu ){// 2byte半角文字なら
        |    text_putc( xp+1, putLine, ' ' );   // 右半分をSpaceで潰す
        |  }
        |  else{
        |    xp++;
        |  }
        |  xp++;
        |}
        *-------------------------------------------------------------
                        (NIFTY-Serve/FGALAM MES10/HFC02457(加府 美良))

        Ａ.
        　半角カナは対応しています。
        　符号拡張に気を付けてください。
        text_putc( 0,0, 'ｱ' ) ;                 ×
        text_putc( 0,0, (unsigned char)'ｱ' ) ;  ○
        text_putc( 0,0, 'ｱ' & 0xff ) ;          ○
        　昔の MSC3 などでは、char -> unsigned int への暗黙の変換では、
        char -> unsigned char -> unsigned int に変換されていましたが、
        ANSI が出来たときに、 char -> int -> unsigned int に変わりまし
        たので、charとしてみてマイナスの値である半角カナは、符号拡張さ
        れてしまいます。
        　例えば、以下のコードを実行すると、
           unsigned char a = 'ｱ' ;
           char b = 'ｱ' ;
           printf( "%04x %04x", a,b ) ;
        　以下のような表示がされます。
           00b1 ffb1
        　つまり、符号ビットが拡張されて、0ffhが上位に追加されてしまっ
        ているのです。このことが、カナを見えなくしているだけでした。
                                                                (恋塚)
        --------------------------------------------------------------
        Ｑ.
        　DOS/Vですが、font_entry_cgrom()をちゃんと実行しているのに、
        graph_font_puts()とかで半角が出てくれません。

        Ａ.
        　font_entry_cgrom()は、実行するより前に必ず text_start()を
        実行してください。正確には、font_at_init()がテキストモードの間
        に実行されていればいいんですけどね。
                                                                (恋塚)
        --------------------------------------------------------------
[EOF]